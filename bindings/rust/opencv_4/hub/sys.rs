use crate::{mod_prelude_types::*, core};

#[cfg(feature = "contrib")]
mod aruco_sys {
	use super::*;

	extern "C" {
		pub fn cv_aruco_calibrateCameraAruco_const__InputArrayX_const__InputArrayX_const__InputArrayX_const_Ptr_Board_X_Size_const__InputOutputArrayX_const__InputOutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_int_TermCriteria(corners: *mut c_void, ids: *mut c_void, counter: *mut c_void, board: *mut c_void, image_size: *const core::Size, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvecs: *mut c_void, tvecs: *mut c_void, std_deviations_intrinsics: *mut c_void, std_deviations_extrinsics: *mut c_void, per_view_errors: *mut c_void, flags: i32, criteria: *mut c_void) -> Result<f64>;
		pub fn cv_aruco_calibrateCameraAruco_const__InputArrayX_const__InputArrayX_const__InputArrayX_const_Ptr_Board_X_Size_const__InputOutputArrayX_const__InputOutputArrayX_const__OutputArrayX_const__OutputArrayX_int_TermCriteria(corners: *mut c_void, ids: *mut c_void, counter: *mut c_void, board: *mut c_void, image_size: *const core::Size, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvecs: *mut c_void, tvecs: *mut c_void, flags: i32, criteria: *mut c_void) -> Result<f64>;
		pub fn cv_aruco_calibrateCameraCharuco_const__InputArrayX_const__InputArrayX_const_Ptr_CharucoBoard_X_Size_const__InputOutputArrayX_const__InputOutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_int_TermCriteria(charuco_corners: *mut c_void, charuco_ids: *mut c_void, board: *mut c_void, image_size: *const core::Size, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvecs: *mut c_void, tvecs: *mut c_void, std_deviations_intrinsics: *mut c_void, std_deviations_extrinsics: *mut c_void, per_view_errors: *mut c_void, flags: i32, criteria: *mut c_void) -> Result<f64>;
		pub fn cv_aruco_calibrateCameraCharuco_const__InputArrayX_const__InputArrayX_const_Ptr_CharucoBoard_X_Size_const__InputOutputArrayX_const__InputOutputArrayX_const__OutputArrayX_const__OutputArrayX_int_TermCriteria(charuco_corners: *mut c_void, charuco_ids: *mut c_void, board: *mut c_void, image_size: *const core::Size, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvecs: *mut c_void, tvecs: *mut c_void, flags: i32, criteria: *mut c_void) -> Result<f64>;
		pub fn cv_aruco_detectCharucoDiamond_const__InputArrayX_const__InputArrayX_const__InputArrayX_float_const__OutputArrayX_const__OutputArrayX_const__InputArrayX_const__InputArrayX(image: *mut c_void, marker_corners: *mut c_void, marker_ids: *mut c_void, square_marker_length_rate: f32, diamond_corners: *mut c_void, diamond_ids: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void) -> Result_void;
		pub fn cv_aruco_detectMarkers_const__InputArrayX_const_Ptr_Dictionary_X_const__OutputArrayX_const__OutputArrayX_const_Ptr_DetectorParameters_X_const__OutputArrayX_const__InputArrayX_const__InputArrayX(image: *mut c_void, dictionary: *mut c_void, corners: *mut c_void, ids: *mut c_void, parameters: *mut c_void, rejected_img_points: *mut c_void, camera_matrix: *mut c_void, dist_coeff: *mut c_void) -> Result_void;
		pub fn cv_aruco_drawAxis_const__InputOutputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_float(image: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, length: f32) -> Result_void;
		pub fn cv_aruco_drawCharucoDiamond_const_Ptr_Dictionary_X_Vec4i_int_int_const__OutputArrayX_int_int(dictionary: *mut c_void, ids: *const core::Vec4i, square_length: i32, marker_length: i32, img: *mut c_void, margin_size: i32, border_bits: i32) -> Result_void;
		pub fn cv_aruco_drawDetectedCornersCharuco_const__InputOutputArrayX_const__InputArrayX_const__InputArrayX_Scalar(image: *mut c_void, charuco_corners: *mut c_void, charuco_ids: *mut c_void, corner_color: *const core::Scalar) -> Result_void;
		pub fn cv_aruco_drawDetectedDiamonds_const__InputOutputArrayX_const__InputArrayX_const__InputArrayX_Scalar(image: *mut c_void, diamond_corners: *mut c_void, diamond_ids: *mut c_void, border_color: *const core::Scalar) -> Result_void;
		pub fn cv_aruco_drawDetectedMarkers_const__InputOutputArrayX_const__InputArrayX_const__InputArrayX_Scalar(image: *mut c_void, corners: *mut c_void, ids: *mut c_void, border_color: *const core::Scalar) -> Result_void;
		pub fn cv_aruco_drawMarker_const_Ptr_Dictionary_X_int_int_const__OutputArrayX_int(dictionary: *mut c_void, id: i32, side_pixels: i32, img: *mut c_void, border_bits: i32) -> Result_void;
		pub fn cv_aruco_drawPlanarBoard_const_Ptr_Board_X_Size_const__OutputArrayX_int_int(board: *mut c_void, out_size: *const core::Size, img: *mut c_void, margin_size: i32, border_bits: i32) -> Result_void;
		pub fn cv_aruco_estimatePoseBoard_const__InputArrayX_const__InputArrayX_const_Ptr_Board_X_const__InputArrayX_const__InputArrayX_const__InputOutputArrayX_const__InputOutputArrayX_bool(corners: *mut c_void, ids: *mut c_void, board: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, use_extrinsic_guess: bool) -> Result<i32>;
		pub fn cv_aruco_estimatePoseCharucoBoard_const__InputArrayX_const__InputArrayX_const_Ptr_CharucoBoard_X_const__InputArrayX_const__InputArrayX_const__InputOutputArrayX_const__InputOutputArrayX_bool(charuco_corners: *mut c_void, charuco_ids: *mut c_void, board: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, use_extrinsic_guess: bool) -> Result<bool>;
		pub fn cv_aruco_estimatePoseSingleMarkers_const__InputArrayX_float_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX(corners: *mut c_void, marker_length: f32, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvecs: *mut c_void, tvecs: *mut c_void, _obj_points: *mut c_void) -> Result_void;
		pub fn cv_aruco_generateCustomDictionary_int_int_const_Ptr_Dictionary_X_int(n_markers: i32, marker_size: i32, base_dictionary: *mut c_void, random_seed: i32) -> Result<*mut c_void>;
		pub fn cv_aruco_generateCustomDictionary_int_int_int(n_markers: i32, marker_size: i32, random_seed: i32) -> Result<*mut c_void>;
		pub fn cv_aruco_getBoardObjectAndImagePoints_const_Ptr_Board_X_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(board: *mut c_void, detected_corners: *mut c_void, detected_ids: *mut c_void, obj_points: *mut c_void, img_points: *mut c_void) -> Result_void;
		pub fn cv_aruco_getPredefinedDictionary_PREDEFINED_DICTIONARY_NAME(name: crate::aruco::PREDEFINED_DICTIONARY_NAME) -> Result<*mut c_void>;
		pub fn cv_aruco_getPredefinedDictionary_int(dict: i32) -> Result<*mut c_void>;
		pub fn cv_aruco_interpolateCornersCharuco_const__InputArrayX_const__InputArrayX_const__InputArrayX_const_Ptr_CharucoBoard_X_const__OutputArrayX_const__OutputArrayX_const__InputArrayX_const__InputArrayX_int(marker_corners: *mut c_void, marker_ids: *mut c_void, image: *mut c_void, board: *mut c_void, charuco_corners: *mut c_void, charuco_ids: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, min_markers: i32) -> Result<i32>;
		pub fn cv_aruco_refineDetectedMarkers_const__InputArrayX_const_Ptr_Board_X_const__InputOutputArrayX_const__InputOutputArrayX_const__InputOutputArrayX_const__InputArrayX_const__InputArrayX_float_float_bool_const__OutputArrayX_const_Ptr_DetectorParameters_X(image: *mut c_void, board: *mut c_void, detected_corners: *mut c_void, detected_ids: *mut c_void, rejected_corners: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, min_rep_distance: f32, error_correction_rate: f32, check_all_orders: bool, recovered_idxs: *mut c_void, parameters: *mut c_void) -> Result_void;
		pub fn cv_aruco_Board_objPoints(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_aruco_Board_setObjPoints_vector_vector_Point3f__(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_aruco_Board_dictionary(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_aruco_Board_setDictionary_Ptr_Dictionary_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_aruco_Board_ids(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_aruco_Board_setIds_vector_int_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_aruco_Board_create_const__InputArrayX_const_Ptr_Dictionary_X_const__InputArrayX(obj_points: *mut c_void, dictionary: *mut c_void, ids: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_aruco_CharucoBoard_chessboardCorners(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_aruco_CharucoBoard_setChessboardCorners_vector_Point3f_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_aruco_CharucoBoard_nearestMarkerIdx(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_aruco_CharucoBoard_setNearestMarkerIdx_vector_vector_int__(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_aruco_CharucoBoard_nearestMarkerCorners(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_aruco_CharucoBoard_setNearestMarkerCorners_vector_vector_int__(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_aruco_CharucoBoard_draw_Size_const__OutputArrayX_int_int(instance: *mut c_void, out_size: *const core::Size, img: *mut c_void, margin_size: i32, border_bits: i32) -> Result_void;
		pub fn cv_aruco_CharucoBoard_create_int_int_float_float_const_Ptr_Dictionary_X(squares_x: i32, squares_y: i32, square_length: f32, marker_length: f32, dictionary: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_aruco_CharucoBoard_getChessboardSize_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_aruco_CharucoBoard_getSquareLength_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_aruco_CharucoBoard_getMarkerLength_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_aruco_DetectorParameters_adaptiveThreshWinSizeMin_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_aruco_DetectorParameters_setAdaptiveThreshWinSizeMin_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_aruco_DetectorParameters_adaptiveThreshWinSizeMax_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_aruco_DetectorParameters_setAdaptiveThreshWinSizeMax_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_aruco_DetectorParameters_adaptiveThreshWinSizeStep_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_aruco_DetectorParameters_setAdaptiveThreshWinSizeStep_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_aruco_DetectorParameters_adaptiveThreshConstant_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_aruco_DetectorParameters_setAdaptiveThreshConstant_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_aruco_DetectorParameters_minMarkerPerimeterRate_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_aruco_DetectorParameters_setMinMarkerPerimeterRate_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_aruco_DetectorParameters_maxMarkerPerimeterRate_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_aruco_DetectorParameters_setMaxMarkerPerimeterRate_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_aruco_DetectorParameters_polygonalApproxAccuracyRate_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_aruco_DetectorParameters_setPolygonalApproxAccuracyRate_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_aruco_DetectorParameters_minCornerDistanceRate_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_aruco_DetectorParameters_setMinCornerDistanceRate_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_aruco_DetectorParameters_minDistanceToBorder_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_aruco_DetectorParameters_setMinDistanceToBorder_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_aruco_DetectorParameters_minMarkerDistanceRate_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_aruco_DetectorParameters_setMinMarkerDistanceRate_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_aruco_DetectorParameters_cornerRefinementMethod_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_aruco_DetectorParameters_setCornerRefinementMethod_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_aruco_DetectorParameters_cornerRefinementWinSize_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_aruco_DetectorParameters_setCornerRefinementWinSize_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_aruco_DetectorParameters_cornerRefinementMaxIterations_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_aruco_DetectorParameters_setCornerRefinementMaxIterations_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_aruco_DetectorParameters_cornerRefinementMinAccuracy_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_aruco_DetectorParameters_setCornerRefinementMinAccuracy_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_aruco_DetectorParameters_markerBorderBits_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_aruco_DetectorParameters_setMarkerBorderBits_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_aruco_DetectorParameters_perspectiveRemovePixelPerCell_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_aruco_DetectorParameters_setPerspectiveRemovePixelPerCell_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_aruco_DetectorParameters_perspectiveRemoveIgnoredMarginPerCell_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_aruco_DetectorParameters_setPerspectiveRemoveIgnoredMarginPerCell_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_aruco_DetectorParameters_maxErroneousBitsInBorderRate_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_aruco_DetectorParameters_setMaxErroneousBitsInBorderRate_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_aruco_DetectorParameters_minOtsuStdDev_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_aruco_DetectorParameters_setMinOtsuStdDev_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_aruco_DetectorParameters_errorCorrectionRate_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_aruco_DetectorParameters_setErrorCorrectionRate_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_aruco_DetectorParameters_aprilTagQuadDecimate_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_aruco_DetectorParameters_setAprilTagQuadDecimate_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_aruco_DetectorParameters_aprilTagQuadSigma_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_aruco_DetectorParameters_setAprilTagQuadSigma_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_aruco_DetectorParameters_aprilTagMinClusterPixels_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_aruco_DetectorParameters_setAprilTagMinClusterPixels_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_aruco_DetectorParameters_aprilTagMaxNmaxima_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_aruco_DetectorParameters_setAprilTagMaxNmaxima_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_aruco_DetectorParameters_aprilTagCriticalRad_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_aruco_DetectorParameters_setAprilTagCriticalRad_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_aruco_DetectorParameters_aprilTagMaxLineFitMse_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_aruco_DetectorParameters_setAprilTagMaxLineFitMse_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_aruco_DetectorParameters_aprilTagMinWhiteBlackDiff_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_aruco_DetectorParameters_setAprilTagMinWhiteBlackDiff_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_aruco_DetectorParameters_aprilTagDeglitch_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_aruco_DetectorParameters_setAprilTagDeglitch_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_aruco_DetectorParameters_detectInvertedMarker_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_aruco_DetectorParameters_setDetectInvertedMarker_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_aruco_DetectorParameters_DetectorParameters() -> Result<*mut c_void>;
		pub fn cv_aruco_DetectorParameters_create() -> Result<*mut c_void>;
		pub fn cv_aruco_Dictionary_bytesList(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_aruco_Dictionary_setBytesList_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_aruco_Dictionary_markerSize_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_aruco_Dictionary_setMarkerSize_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_aruco_Dictionary_maxCorrectionBits_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_aruco_Dictionary_setMaxCorrectionBits_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_aruco_Dictionary_Dictionary_const_MatX_int_int(_bytes_list: *mut c_void, _marker_size: i32, _maxcorr: i32) -> Result<*mut c_void>;
		pub fn cv_aruco_Dictionary_Dictionary_const_Ptr_Dictionary_X(_dictionary: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_aruco_Dictionary_create_int_int_int(n_markers: i32, marker_size: i32, random_seed: i32) -> Result<*mut c_void>;
		pub fn cv_aruco_Dictionary_create_int_int_const_Ptr_Dictionary_X_int(n_markers: i32, marker_size: i32, base_dictionary: *mut c_void, random_seed: i32) -> Result<*mut c_void>;
		pub fn cv_aruco_Dictionary_get_int(dict: i32) -> Result<*mut c_void>;
		pub fn cv_aruco_Dictionary_identify_const_const_MatX_intX_intX_double(instance: *mut c_void, only_bits: *mut c_void, idx: *mut i32, rotation: *mut i32, max_correction_rate: f64) -> Result<bool>;
		pub fn cv_aruco_Dictionary_getDistanceToId_const_const__InputArrayX_int_bool(instance: *mut c_void, bits: *mut c_void, id: i32, all_rotations: bool) -> Result<i32>;
		pub fn cv_aruco_Dictionary_drawMarker_const_int_int_const__OutputArrayX_int(instance: *mut c_void, id: i32, side_pixels: i32, _img: *mut c_void, border_bits: i32) -> Result_void;
		pub fn cv_aruco_Dictionary_getByteListFromBits_const_MatX(bits: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_aruco_Dictionary_getBitsFromByteList_const_MatX_int(byte_list: *mut c_void, marker_size: i32) -> Result<*mut c_void>;
		pub fn cv_aruco_GridBoard_draw_Size_const__OutputArrayX_int_int(instance: *mut c_void, out_size: *const core::Size, img: *mut c_void, margin_size: i32, border_bits: i32) -> Result_void;
		pub fn cv_aruco_GridBoard_create_int_int_float_float_const_Ptr_Dictionary_X_int(markers_x: i32, markers_y: i32, marker_length: f32, marker_separation: f32, dictionary: *mut c_void, first_marker: i32) -> Result<*mut c_void>;
		pub fn cv_aruco_GridBoard_getGridSize_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_aruco_GridBoard_getMarkerLength_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_aruco_GridBoard_getMarkerSeparation_const(instance: *mut c_void) -> Result<f32>;
	}
}
#[cfg(feature = "contrib")]
pub use aruco_sys::*;

#[cfg(feature = "contrib")]
mod bgsegm_sys {
	use super::*;

	extern "C" {
		pub fn cv_bgsegm_createBackgroundSubtractorCNT_int_bool_int_bool(min_pixel_stability: i32, use_history: bool, max_pixel_stability: i32, is_parallel: bool) -> Result<*mut c_void>;
		pub fn cv_bgsegm_createBackgroundSubtractorGMG_int_double(initialization_frames: i32, decision_threshold: f64) -> Result<*mut c_void>;
		pub fn cv_bgsegm_createBackgroundSubtractorGSOC_int_int_float_float_int_float_float_float_float_float_float(mc: i32, n_samples: i32, replace_rate: f32, propagation_rate: f32, hits_threshold: i32, alpha: f32, beta: f32, blinking_supression_decay: f32, blinking_supression_multiplier: f32, noise_removal_threshold_fac_bg: f32, noise_removal_threshold_fac_fg: f32) -> Result<*mut c_void>;
		pub fn cv_bgsegm_createBackgroundSubtractorLSBP_int_int_int_float_float_float_float_float_float_float_float_int_int(mc: i32, n_samples: i32, lsbp_radius: i32, tlower: f32, tupper: f32, tinc: f32, tdec: f32, rscale: f32, rincdec: f32, noise_removal_threshold_fac_bg: f32, noise_removal_threshold_fac_fg: f32, lsb_pthreshold: i32, min_count: i32) -> Result<*mut c_void>;
		pub fn cv_bgsegm_createBackgroundSubtractorMOG_int_int_double_double(history: i32, nmixtures: i32, background_ratio: f64, noise_sigma: f64) -> Result<*mut c_void>;
		pub fn cv_bgsegm_createSyntheticSequenceGenerator_const__InputArrayX_const__InputArrayX_double_double_double_double(background: *mut c_void, object: *mut c_void, amplitude: f64, wavelength: f64, wavespeed: f64, objspeed: f64) -> Result<*mut c_void>;
		pub fn cv_bgsegm_BackgroundSubtractorCNT_apply_const__InputArrayX_const__OutputArrayX_double(instance: *mut c_void, image: *mut c_void, fgmask: *mut c_void, learning_rate: f64) -> Result_void;
		pub fn cv_bgsegm_BackgroundSubtractorCNT_getBackgroundImage_const_const__OutputArrayX(instance: *mut c_void, background_image: *mut c_void) -> Result_void;
		pub fn cv_bgsegm_BackgroundSubtractorCNT_getMinPixelStability_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_bgsegm_BackgroundSubtractorCNT_setMinPixelStability_int(instance: *mut c_void, value: i32) -> Result_void;
		pub fn cv_bgsegm_BackgroundSubtractorCNT_getMaxPixelStability_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_bgsegm_BackgroundSubtractorCNT_setMaxPixelStability_int(instance: *mut c_void, value: i32) -> Result_void;
		pub fn cv_bgsegm_BackgroundSubtractorCNT_getUseHistory_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_bgsegm_BackgroundSubtractorCNT_setUseHistory_bool(instance: *mut c_void, value: bool) -> Result_void;
		pub fn cv_bgsegm_BackgroundSubtractorCNT_getIsParallel_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_bgsegm_BackgroundSubtractorCNT_setIsParallel_bool(instance: *mut c_void, value: bool) -> Result_void;
		pub fn cv_bgsegm_BackgroundSubtractorGMG_getMaxFeatures_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_bgsegm_BackgroundSubtractorGMG_setMaxFeatures_int(instance: *mut c_void, max_features: i32) -> Result_void;
		pub fn cv_bgsegm_BackgroundSubtractorGMG_getDefaultLearningRate_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_bgsegm_BackgroundSubtractorGMG_setDefaultLearningRate_double(instance: *mut c_void, lr: f64) -> Result_void;
		pub fn cv_bgsegm_BackgroundSubtractorGMG_getNumFrames_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_bgsegm_BackgroundSubtractorGMG_setNumFrames_int(instance: *mut c_void, nframes: i32) -> Result_void;
		pub fn cv_bgsegm_BackgroundSubtractorGMG_getQuantizationLevels_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_bgsegm_BackgroundSubtractorGMG_setQuantizationLevels_int(instance: *mut c_void, nlevels: i32) -> Result_void;
		pub fn cv_bgsegm_BackgroundSubtractorGMG_getBackgroundPrior_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_bgsegm_BackgroundSubtractorGMG_setBackgroundPrior_double(instance: *mut c_void, bgprior: f64) -> Result_void;
		pub fn cv_bgsegm_BackgroundSubtractorGMG_getSmoothingRadius_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_bgsegm_BackgroundSubtractorGMG_setSmoothingRadius_int(instance: *mut c_void, radius: i32) -> Result_void;
		pub fn cv_bgsegm_BackgroundSubtractorGMG_getDecisionThreshold_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_bgsegm_BackgroundSubtractorGMG_setDecisionThreshold_double(instance: *mut c_void, thresh: f64) -> Result_void;
		pub fn cv_bgsegm_BackgroundSubtractorGMG_getUpdateBackgroundModel_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_bgsegm_BackgroundSubtractorGMG_setUpdateBackgroundModel_bool(instance: *mut c_void, update: bool) -> Result_void;
		pub fn cv_bgsegm_BackgroundSubtractorGMG_getMinVal_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_bgsegm_BackgroundSubtractorGMG_setMinVal_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_bgsegm_BackgroundSubtractorGMG_getMaxVal_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_bgsegm_BackgroundSubtractorGMG_setMaxVal_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_bgsegm_BackgroundSubtractorGSOC_apply_const__InputArrayX_const__OutputArrayX_double(instance: *mut c_void, image: *mut c_void, fgmask: *mut c_void, learning_rate: f64) -> Result_void;
		pub fn cv_bgsegm_BackgroundSubtractorGSOC_getBackgroundImage_const_const__OutputArrayX(instance: *mut c_void, background_image: *mut c_void) -> Result_void;
		pub fn cv_bgsegm_BackgroundSubtractorLSBP_apply_const__InputArrayX_const__OutputArrayX_double(instance: *mut c_void, image: *mut c_void, fgmask: *mut c_void, learning_rate: f64) -> Result_void;
		pub fn cv_bgsegm_BackgroundSubtractorLSBP_getBackgroundImage_const_const__OutputArrayX(instance: *mut c_void, background_image: *mut c_void) -> Result_void;
		pub fn cv_bgsegm_BackgroundSubtractorLSBPDesc_calcLocalSVDValues_const__OutputArrayX_const_MatX(local_svd_values: *mut c_void, frame: *mut c_void) -> Result_void;
		pub fn cv_bgsegm_BackgroundSubtractorLSBPDesc_computeFromLocalSVDValues_const__OutputArrayX_const_MatX_const_Point2iX(desc: *mut c_void, local_svd_values: *mut c_void, lsbp_sample_points: *const core::Point2i) -> Result_void;
		pub fn cv_bgsegm_BackgroundSubtractorLSBPDesc_compute_const__OutputArrayX_const_MatX_const_Point2iX(desc: *mut c_void, frame: *mut c_void, lsbp_sample_points: *const core::Point2i) -> Result_void;
		pub fn cv_bgsegm_BackgroundSubtractorMOG_getHistory_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_bgsegm_BackgroundSubtractorMOG_setHistory_int(instance: *mut c_void, nframes: i32) -> Result_void;
		pub fn cv_bgsegm_BackgroundSubtractorMOG_getNMixtures_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_bgsegm_BackgroundSubtractorMOG_setNMixtures_int(instance: *mut c_void, nmix: i32) -> Result_void;
		pub fn cv_bgsegm_BackgroundSubtractorMOG_getBackgroundRatio_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_bgsegm_BackgroundSubtractorMOG_setBackgroundRatio_double(instance: *mut c_void, background_ratio: f64) -> Result_void;
		pub fn cv_bgsegm_BackgroundSubtractorMOG_getNoiseSigma_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_bgsegm_BackgroundSubtractorMOG_setNoiseSigma_double(instance: *mut c_void, noise_sigma: f64) -> Result_void;
		pub fn cv_bgsegm_SyntheticSequenceGenerator_SyntheticSequenceGenerator_const__InputArrayX_const__InputArrayX_double_double_double_double(background: *mut c_void, object: *mut c_void, amplitude: f64, wavelength: f64, wavespeed: f64, objspeed: f64) -> Result<*mut c_void>;
		pub fn cv_bgsegm_SyntheticSequenceGenerator_getNextFrame_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, frame: *mut c_void, gt_mask: *mut c_void) -> Result_void;
	}
}
#[cfg(feature = "contrib")]
pub use bgsegm_sys::*;

#[cfg(feature = "contrib")]
mod bioinspired_sys {
	use super::*;

	extern "C" {
		pub fn cv_bioinspired_Retina_getInputSize(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_bioinspired_Retina_getOutputSize(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_bioinspired_Retina_setup_String_bool(instance: *mut c_void, retina_parameter_file: *mut c_char, apply_default_setup_on_failure: bool) -> Result_void;
		pub fn cv_bioinspired_Retina_setup_FileStorageX_bool(instance: *mut c_void, fs: *mut c_void, apply_default_setup_on_failure: bool) -> Result_void;
		pub fn cv_bioinspired_Retina_setup_RetinaParameters(instance: *mut c_void, new_parameters: *mut c_void) -> Result_void;
		pub fn cv_bioinspired_Retina_getParameters(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_bioinspired_Retina_printSetup(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_bioinspired_Retina_write_const_String(instance: *mut c_void, fs: *mut c_char) -> Result_void;
		pub fn cv_bioinspired_Retina_write_const_FileStorageX(instance: *mut c_void, fs: *mut c_void) -> Result_void;
		pub fn cv_bioinspired_Retina_setupOPLandIPLParvoChannel_bool_bool_float_float_float_float_float_float_float(instance: *mut c_void, color_mode: bool, normalise_output: bool, photoreceptors_local_adaptation_sensitivity: f32, photoreceptors_temporal_constant: f32, photoreceptors_spatial_constant: f32, horizontal_cells_gain: f32, hcells_temporal_constant: f32, hcells_spatial_constant: f32, ganglion_cells_sensitivity: f32) -> Result_void;
		pub fn cv_bioinspired_Retina_setupIPLMagnoChannel_bool_float_float_float_float_float_float_float(instance: *mut c_void, normalise_output: bool, parasol_cells_beta: f32, parasol_cells_tau: f32, parasol_cells_k: f32, amacrin_cells_temporal_cut_frequency: f32, v0_compression_parameter: f32, local_adaptintegration_tau: f32, local_adaptintegration_k: f32) -> Result_void;
		pub fn cv_bioinspired_Retina_run_const__InputArrayX(instance: *mut c_void, input_image: *mut c_void) -> Result_void;
		pub fn cv_bioinspired_Retina_applyFastToneMapping_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, input_image: *mut c_void, output_tone_mapped_image: *mut c_void) -> Result_void;
		pub fn cv_bioinspired_Retina_getParvo_const__OutputArrayX(instance: *mut c_void, retina_output_parvo: *mut c_void) -> Result_void;
		pub fn cv_bioinspired_Retina_getParvoRAW_const__OutputArrayX(instance: *mut c_void, retina_output_parvo: *mut c_void) -> Result_void;
		pub fn cv_bioinspired_Retina_getMagno_const__OutputArrayX(instance: *mut c_void, retina_output_magno: *mut c_void) -> Result_void;
		pub fn cv_bioinspired_Retina_getMagnoRAW_const__OutputArrayX(instance: *mut c_void, retina_output_magno: *mut c_void) -> Result_void;
		pub fn cv_bioinspired_Retina_getMagnoRAW_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_bioinspired_Retina_getParvoRAW_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_bioinspired_Retina_setColorSaturation_bool_float(instance: *mut c_void, saturate_colors: bool, color_saturation_value: f32) -> Result_void;
		pub fn cv_bioinspired_Retina_clearBuffers(instance: *mut c_void) -> Result_void;
		pub fn cv_bioinspired_Retina_activateMovingContoursProcessing_bool(instance: *mut c_void, activate: bool) -> Result_void;
		pub fn cv_bioinspired_Retina_activateContoursProcessing_bool(instance: *mut c_void, activate: bool) -> Result_void;
		pub fn cv_bioinspired_Retina_create_Size(input_size: *const core::Size) -> Result<*mut c_void>;
		pub fn cv_bioinspired_Retina_create_Size_bool_int_bool_float_float(input_size: *const core::Size, color_mode: bool, color_sampling_method: i32, use_retina_log_sampling: bool, reduction_factor: f32, sampling_strenght: f32) -> Result<*mut c_void>;
		pub fn cv_bioinspired_RetinaFastToneMapping_applyFastToneMapping_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, input_image: *mut c_void, output_tone_mapped_image: *mut c_void) -> Result_void;
		pub fn cv_bioinspired_RetinaFastToneMapping_setup_float_float_float(instance: *mut c_void, photoreceptors_neighborhood_radius: f32, ganglioncells_neighborhood_radius: f32, mean_luminance_modulator_k: f32) -> Result_void;
		pub fn cv_bioinspired_RetinaFastToneMapping_create_Size(input_size: *const core::Size) -> Result<*mut c_void>;
		pub fn cv_bioinspired_RetinaParameters_OPLandIplParvo_const(instance: *mut c_void) -> Result<crate::bioinspired::RetinaParameters_OPLandIplParvoParameters>;
		pub fn cv_bioinspired_RetinaParameters_setOPLandIplParvo_OPLandIplParvoParameters(instance: *mut c_void, val: *const crate::bioinspired::RetinaParameters_OPLandIplParvoParameters) -> Result_void;
		pub fn cv_bioinspired_RetinaParameters_IplMagno_const(instance: *mut c_void) -> Result<crate::bioinspired::RetinaParameters_IplMagnoParameters>;
		pub fn cv_bioinspired_RetinaParameters_setIplMagno_IplMagnoParameters(instance: *mut c_void, val: *const crate::bioinspired::RetinaParameters_IplMagnoParameters) -> Result_void;
		pub fn cv_bioinspired_RetinaParameters_IplMagnoParameters_IplMagnoParameters() -> Result<crate::bioinspired::RetinaParameters_IplMagnoParameters>;
		pub fn cv_bioinspired_RetinaParameters_OPLandIplParvoParameters_OPLandIplParvoParameters() -> Result<crate::bioinspired::RetinaParameters_OPLandIplParvoParameters>;
		pub fn cv_bioinspired_SegmentationParameters_SegmentationParameters() -> Result<crate::bioinspired::SegmentationParameters>;
		pub fn cv_bioinspired_TransientAreasSegmentationModule_getSize(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_bioinspired_TransientAreasSegmentationModule_setup_String_bool(instance: *mut c_void, segmentation_parameter_file: *mut c_char, apply_default_setup_on_failure: bool) -> Result_void;
		pub fn cv_bioinspired_TransientAreasSegmentationModule_setup_FileStorageX_bool(instance: *mut c_void, fs: *mut c_void, apply_default_setup_on_failure: bool) -> Result_void;
		pub fn cv_bioinspired_TransientAreasSegmentationModule_setup_SegmentationParameters(instance: *mut c_void, new_parameters: *const crate::bioinspired::SegmentationParameters) -> Result_void;
		pub fn cv_bioinspired_TransientAreasSegmentationModule_getParameters(instance: *mut c_void) -> Result<crate::bioinspired::SegmentationParameters>;
		pub fn cv_bioinspired_TransientAreasSegmentationModule_printSetup(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_bioinspired_TransientAreasSegmentationModule_write_const_String(instance: *mut c_void, fs: *mut c_char) -> Result_void;
		pub fn cv_bioinspired_TransientAreasSegmentationModule_write_const_FileStorageX(instance: *mut c_void, fs: *mut c_void) -> Result_void;
		pub fn cv_bioinspired_TransientAreasSegmentationModule_run_const__InputArrayX_int(instance: *mut c_void, input_to_segment: *mut c_void, channel_index: i32) -> Result_void;
		pub fn cv_bioinspired_TransientAreasSegmentationModule_getSegmentationPicture_const__OutputArrayX(instance: *mut c_void, transient_areas: *mut c_void) -> Result_void;
		pub fn cv_bioinspired_TransientAreasSegmentationModule_clearAllBuffers(instance: *mut c_void) -> Result_void;
		pub fn cv_bioinspired_TransientAreasSegmentationModule_create_Size(input_size: *const core::Size) -> Result<*mut c_void>;
	}
}
#[cfg(feature = "contrib")]
pub use bioinspired_sys::*;

mod calib3d_sys {
	use super::*;

	extern "C" {
		pub fn cv_RQDecomp3x3_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX(src: *mut c_void, mtx_r: *mut c_void, mtx_q: *mut c_void, qx: *mut c_void, qy: *mut c_void, qz: *mut c_void) -> Result<core::Vec3d>;
		pub fn cv_Rodrigues_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(src: *mut c_void, dst: *mut c_void, jacobian: *mut c_void) -> Result_void;
		pub fn cv_calibrateCameraRO_const__InputArrayX_const__InputArrayX_Size_int_const__InputOutputArrayX_const__InputOutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_int_TermCriteria(object_points: *mut c_void, image_points: *mut c_void, image_size: *const core::Size, i_fixed_point: i32, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvecs: *mut c_void, tvecs: *mut c_void, new_obj_points: *mut c_void, std_deviations_intrinsics: *mut c_void, std_deviations_extrinsics: *mut c_void, std_deviations_obj_points: *mut c_void, per_view_errors: *mut c_void, flags: i32, criteria: *mut c_void) -> Result<f64>;
		pub fn cv_calibrateCameraRO_const__InputArrayX_const__InputArrayX_Size_int_const__InputOutputArrayX_const__InputOutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_int_TermCriteria(object_points: *mut c_void, image_points: *mut c_void, image_size: *const core::Size, i_fixed_point: i32, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvecs: *mut c_void, tvecs: *mut c_void, new_obj_points: *mut c_void, flags: i32, criteria: *mut c_void) -> Result<f64>;
		pub fn cv_calibrateCamera_const__InputArrayX_const__InputArrayX_Size_const__InputOutputArrayX_const__InputOutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_int_TermCriteria(object_points: *mut c_void, image_points: *mut c_void, image_size: *const core::Size, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvecs: *mut c_void, tvecs: *mut c_void, std_deviations_intrinsics: *mut c_void, std_deviations_extrinsics: *mut c_void, per_view_errors: *mut c_void, flags: i32, criteria: *mut c_void) -> Result<f64>;
		pub fn cv_calibrateCamera_const__InputArrayX_const__InputArrayX_Size_const__InputOutputArrayX_const__InputOutputArrayX_const__OutputArrayX_const__OutputArrayX_int_TermCriteria(object_points: *mut c_void, image_points: *mut c_void, image_size: *const core::Size, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvecs: *mut c_void, tvecs: *mut c_void, flags: i32, criteria: *mut c_void) -> Result<f64>;
		pub fn cv_calibrateHandEye_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_HandEyeCalibrationMethod(r_gripper2base: *mut c_void, t_gripper2base: *mut c_void, r_target2cam: *mut c_void, t_target2cam: *mut c_void, r_cam2gripper: *mut c_void, t_cam2gripper: *mut c_void, method: crate::calib3d::HandEyeCalibrationMethod) -> Result_void;
		pub fn cv_calibrationMatrixValues_const__InputArrayX_Size_double_double_doubleX_doubleX_doubleX_Point2dX_doubleX(camera_matrix: *mut c_void, image_size: *const core::Size, aperture_width: f64, aperture_height: f64, fovx: *mut f64, fovy: *mut f64, focal_length: *mut f64, principal_point: *mut core::Point2d, aspect_ratio: *mut f64) -> Result_void;
		pub fn cv_checkChessboard_const__InputArrayX_Size(img: *mut c_void, size: *const core::Size) -> Result<bool>;
		pub fn cv_composeRT_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX(rvec1: *mut c_void, tvec1: *mut c_void, rvec2: *mut c_void, tvec2: *mut c_void, rvec3: *mut c_void, tvec3: *mut c_void, dr3dr1: *mut c_void, dr3dt1: *mut c_void, dr3dr2: *mut c_void, dr3dt2: *mut c_void, dt3dr1: *mut c_void, dt3dt1: *mut c_void, dt3dr2: *mut c_void, dt3dt2: *mut c_void) -> Result_void;
		pub fn cv_computeCorrespondEpilines_const__InputArrayX_int_const__InputArrayX_const__OutputArrayX(points: *mut c_void, which_image: i32, f: *mut c_void, lines: *mut c_void) -> Result_void;
		pub fn cv_convertPointsFromHomogeneous_const__InputArrayX_const__OutputArrayX(src: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_convertPointsHomogeneous_const__InputArrayX_const__OutputArrayX(src: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_convertPointsToHomogeneous_const__InputArrayX_const__OutputArrayX(src: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_correctMatches_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(f: *mut c_void, points1: *mut c_void, points2: *mut c_void, new_points1: *mut c_void, new_points2: *mut c_void) -> Result_void;
		pub fn cv_decomposeEssentialMat_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX(e: *mut c_void, r1: *mut c_void, r2: *mut c_void, t: *mut c_void) -> Result_void;
		pub fn cv_decomposeHomographyMat_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX(h: *mut c_void, k: *mut c_void, rotations: *mut c_void, translations: *mut c_void, normals: *mut c_void) -> Result<i32>;
		pub fn cv_decomposeProjectionMatrix_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX(proj_matrix: *mut c_void, camera_matrix: *mut c_void, rot_matrix: *mut c_void, trans_vect: *mut c_void, rot_matrix_x: *mut c_void, rot_matrix_y: *mut c_void, rot_matrix_z: *mut c_void, euler_angles: *mut c_void) -> Result_void;
		pub fn cv_drawChessboardCorners_const__InputOutputArrayX_Size_const__InputArrayX_bool(image: *mut c_void, pattern_size: *const core::Size, corners: *mut c_void, pattern_was_found: bool) -> Result_void;
		pub fn cv_drawFrameAxes_const__InputOutputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_float_int(image: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, length: f32, thickness: i32) -> Result_void;
		pub fn cv_estimateAffine2D_const__InputArrayX_const__InputArrayX_const__OutputArrayX_int_double_size_t_double_size_t(from: *mut c_void, to: *mut c_void, inliers: *mut c_void, method: i32, ransac_reproj_threshold: f64, max_iters: size_t, confidence: f64, refine_iters: size_t) -> Result<*mut c_void>;
		pub fn cv_estimateAffine3D_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_double_double(src: *mut c_void, dst: *mut c_void, out: *mut c_void, inliers: *mut c_void, ransac_threshold: f64, confidence: f64) -> Result<i32>;
		pub fn cv_estimateAffinePartial2D_const__InputArrayX_const__InputArrayX_const__OutputArrayX_int_double_size_t_double_size_t(from: *mut c_void, to: *mut c_void, inliers: *mut c_void, method: i32, ransac_reproj_threshold: f64, max_iters: size_t, confidence: f64, refine_iters: size_t) -> Result<*mut c_void>;
		pub fn cv_filterHomographyDecompByVisibleRefpoints_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__InputArrayX(rotations: *mut c_void, normals: *mut c_void, before_points: *mut c_void, after_points: *mut c_void, possible_solutions: *mut c_void, points_mask: *mut c_void) -> Result_void;
		pub fn cv_filterSpeckles_const__InputOutputArrayX_double_int_double_const__InputOutputArrayX(img: *mut c_void, new_val: f64, max_speckle_size: i32, max_diff: f64, buf: *mut c_void) -> Result_void;
		pub fn cv_find4QuadCornerSubpix_const__InputArrayX_const__InputOutputArrayX_Size(img: *mut c_void, corners: *mut c_void, region_size: *const core::Size) -> Result<bool>;
		pub fn cv_findChessboardCornersSB_const__InputArrayX_Size_const__OutputArrayX_int(image: *mut c_void, pattern_size: *const core::Size, corners: *mut c_void, flags: i32) -> Result<bool>;
		pub fn cv_findChessboardCorners_const__InputArrayX_Size_const__OutputArrayX_int(image: *mut c_void, pattern_size: *const core::Size, corners: *mut c_void, flags: i32) -> Result<bool>;
		pub fn cv_findCirclesGrid_const__InputArrayX_Size_const__OutputArrayX_int_const_Ptr_FeatureDetector_X(image: *mut c_void, pattern_size: *const core::Size, centers: *mut c_void, flags: i32, blob_detector: *mut c_void) -> Result<bool>;
		pub fn cv_findCirclesGrid_const__InputArrayX_Size_const__OutputArrayX_int_const_Ptr_FeatureDetector_X_const_CirclesGridFinderParametersX(image: *mut c_void, pattern_size: *const core::Size, centers: *mut c_void, flags: i32, blob_detector: *mut c_void, parameters: *const crate::calib3d::CirclesGridFinderParameters) -> Result<bool>;
		pub fn cv_findEssentialMat_const__InputArrayX_const__InputArrayX_const__InputArrayX_int_double_double_const__OutputArrayX(points1: *mut c_void, points2: *mut c_void, camera_matrix: *mut c_void, method: i32, prob: f64, threshold: f64, mask: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_findEssentialMat_const__InputArrayX_const__InputArrayX_double_Point2d_int_double_double_const__OutputArrayX(points1: *mut c_void, points2: *mut c_void, focal: f64, pp: *const core::Point2d, method: i32, prob: f64, threshold: f64, mask: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_findFundamentalMat_const__InputArrayX_const__InputArrayX_const__OutputArrayX_int_double_double(points1: *mut c_void, points2: *mut c_void, mask: *mut c_void, method: i32, ransac_reproj_threshold: f64, confidence: f64) -> Result<*mut c_void>;
		pub fn cv_findFundamentalMat_const__InputArrayX_const__InputArrayX_int_double_double_const__OutputArrayX(points1: *mut c_void, points2: *mut c_void, method: i32, ransac_reproj_threshold: f64, confidence: f64, mask: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_findHomography_const__InputArrayX_const__InputArrayX_const__OutputArrayX_int_double(src_points: *mut c_void, dst_points: *mut c_void, mask: *mut c_void, method: i32, ransac_reproj_threshold: f64) -> Result<*mut c_void>;
		pub fn cv_findHomography_const__InputArrayX_const__InputArrayX_int_double_const__OutputArrayX_int_double(src_points: *mut c_void, dst_points: *mut c_void, method: i32, ransac_reproj_threshold: f64, mask: *mut c_void, max_iters: i32, confidence: f64) -> Result<*mut c_void>;
		pub fn cv_fisheye_calibrate_const__InputArrayX_const__InputArrayX_const_SizeX_const__InputOutputArrayX_const__InputOutputArrayX_const__OutputArrayX_const__OutputArrayX_int_TermCriteria(object_points: *mut c_void, image_points: *mut c_void, image_size: *const core::Size, k: *mut c_void, d: *mut c_void, rvecs: *mut c_void, tvecs: *mut c_void, flags: i32, criteria: *mut c_void) -> Result<f64>;
		pub fn cv_fisheye_distortPoints_const__InputArrayX_const__OutputArrayX_const__InputArrayX_const__InputArrayX_double(undistorted: *mut c_void, distorted: *mut c_void, k: *mut c_void, d: *mut c_void, alpha: f64) -> Result_void;
		pub fn cv_fisheye_estimateNewCameraMatrixForUndistortRectify_const__InputArrayX_const__InputArrayX_const_SizeX_const__InputArrayX_const__OutputArrayX_double_const_SizeX_double(k: *mut c_void, d: *mut c_void, image_size: *const core::Size, r: *mut c_void, p: *mut c_void, balance: f64, new_size: *const core::Size, fov_scale: f64) -> Result_void;
		pub fn cv_fisheye_initUndistortRectifyMap_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const_SizeX_int_const__OutputArrayX_const__OutputArrayX(k: *mut c_void, d: *mut c_void, r: *mut c_void, p: *mut c_void, size: *const core::Size, m1type: i32, map1: *mut c_void, map2: *mut c_void) -> Result_void;
		pub fn cv_fisheye_projectPoints_const__InputArrayX_const__OutputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_double_const__OutputArrayX(object_points: *mut c_void, image_points: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, k: *mut c_void, d: *mut c_void, alpha: f64, jacobian: *mut c_void) -> Result_void;
		pub fn cv_fisheye_stereoCalibrate_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputOutputArrayX_const__InputOutputArrayX_const__InputOutputArrayX_const__InputOutputArrayX_Size_const__OutputArrayX_const__OutputArrayX_int_TermCriteria(object_points: *mut c_void, image_points1: *mut c_void, image_points2: *mut c_void, k1: *mut c_void, d1: *mut c_void, k2: *mut c_void, d2: *mut c_void, image_size: *const core::Size, r: *mut c_void, t: *mut c_void, flags: i32, criteria: *mut c_void) -> Result<f64>;
		pub fn cv_fisheye_stereoRectify_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const_SizeX_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_int_const_SizeX_double_double(k1: *mut c_void, d1: *mut c_void, k2: *mut c_void, d2: *mut c_void, image_size: *const core::Size, r: *mut c_void, tvec: *mut c_void, r1: *mut c_void, r2: *mut c_void, p1: *mut c_void, p2: *mut c_void, q: *mut c_void, flags: i32, new_image_size: *const core::Size, balance: f64, fov_scale: f64) -> Result_void;
		pub fn cv_fisheye_undistortImage_const__InputArrayX_const__OutputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const_SizeX(distorted: *mut c_void, undistorted: *mut c_void, k: *mut c_void, d: *mut c_void, knew: *mut c_void, new_size: *const core::Size) -> Result_void;
		pub fn cv_fisheye_undistortPoints_const__InputArrayX_const__OutputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX(distorted: *mut c_void, undistorted: *mut c_void, k: *mut c_void, d: *mut c_void, r: *mut c_void, p: *mut c_void) -> Result_void;
		pub fn cv_getDefaultNewCameraMatrix_const__InputArrayX_Size_bool(camera_matrix: *mut c_void, imgsize: *const core::Size, center_principal_point: bool) -> Result<*mut c_void>;
		pub fn cv_getOptimalNewCameraMatrix_const__InputArrayX_const__InputArrayX_Size_double_Size_RectX_bool(camera_matrix: *mut c_void, dist_coeffs: *mut c_void, image_size: *const core::Size, alpha: f64, new_img_size: *const core::Size, valid_pix_roi: *mut core::Rect, center_principal_point: bool) -> Result<*mut c_void>;
		pub fn cv_getValidDisparityROI_Rect_Rect_int_int_int(roi1: *const core::Rect, roi2: *const core::Rect, min_disparity: i32, number_of_disparities: i32, sad_window_size: i32) -> Result<core::Rect>;
		pub fn cv_initCameraMatrix2D_const__InputArrayX_const__InputArrayX_Size_double(object_points: *mut c_void, image_points: *mut c_void, image_size: *const core::Size, aspect_ratio: f64) -> Result<*mut c_void>;
		pub fn cv_initUndistortRectifyMap_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_Size_int_const__OutputArrayX_const__OutputArrayX(camera_matrix: *mut c_void, dist_coeffs: *mut c_void, r: *mut c_void, new_camera_matrix: *mut c_void, size: *const core::Size, m1type: i32, map1: *mut c_void, map2: *mut c_void) -> Result_void;
		pub fn cv_initWideAngleProjMap_const__InputArrayX_const__InputArrayX_Size_int_int_const__OutputArrayX_const__OutputArrayX_UndistortTypes_double(camera_matrix: *mut c_void, dist_coeffs: *mut c_void, image_size: *const core::Size, dest_image_width: i32, m1type: i32, map1: *mut c_void, map2: *mut c_void, proj_type: crate::calib3d::UndistortTypes, alpha: f64) -> Result<f32>;
		pub fn cv_matMulDeriv_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(a: *mut c_void, b: *mut c_void, d_a_bd_a: *mut c_void, d_a_bd_b: *mut c_void) -> Result_void;
		pub fn cv_projectPoints_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_double(object_points: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, image_points: *mut c_void, jacobian: *mut c_void, aspect_ratio: f64) -> Result_void;
		pub fn cv_recoverPose_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_const__InputOutputArrayX(e: *mut c_void, points1: *mut c_void, points2: *mut c_void, camera_matrix: *mut c_void, r: *mut c_void, t: *mut c_void, mask: *mut c_void) -> Result<i32>;
		pub fn cv_recoverPose_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_double_const__InputOutputArrayX_const__OutputArrayX(e: *mut c_void, points1: *mut c_void, points2: *mut c_void, camera_matrix: *mut c_void, r: *mut c_void, t: *mut c_void, distance_thresh: f64, mask: *mut c_void, triangulated_points: *mut c_void) -> Result<i32>;
		pub fn cv_recoverPose_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_double_Point2d_const__InputOutputArrayX(e: *mut c_void, points1: *mut c_void, points2: *mut c_void, r: *mut c_void, t: *mut c_void, focal: f64, pp: *const core::Point2d, mask: *mut c_void) -> Result<i32>;
		pub fn cv_rectify3Collinear_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_Size_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_double_Size_RectX_RectX_int(camera_matrix1: *mut c_void, dist_coeffs1: *mut c_void, camera_matrix2: *mut c_void, dist_coeffs2: *mut c_void, camera_matrix3: *mut c_void, dist_coeffs3: *mut c_void, imgpt1: *mut c_void, imgpt3: *mut c_void, image_size: *const core::Size, r12: *mut c_void, t12: *mut c_void, r13: *mut c_void, t13: *mut c_void, r1: *mut c_void, r2: *mut c_void, r3: *mut c_void, p1: *mut c_void, p2: *mut c_void, p3: *mut c_void, q: *mut c_void, alpha: f64, new_img_size: *const core::Size, roi1: *mut core::Rect, roi2: *mut core::Rect, flags: i32) -> Result<f32>;
		pub fn cv_reprojectImageTo3D_const__InputArrayX_const__OutputArrayX_const__InputArrayX_bool_int(disparity: *mut c_void, _3d_image: *mut c_void, q: *mut c_void, handle_missing_values: bool, ddepth: i32) -> Result_void;
		pub fn cv_sampsonDistance_const__InputArrayX_const__InputArrayX_const__InputArrayX(pt1: *mut c_void, pt2: *mut c_void, f: *mut c_void) -> Result<f64>;
		pub fn cv_solveP3P_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_int(object_points: *mut c_void, image_points: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvecs: *mut c_void, tvecs: *mut c_void, flags: i32) -> Result<i32>;
		pub fn cv_solvePnPGeneric_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_bool_SolvePnPMethod_const__InputArrayX_const__InputArrayX_const__OutputArrayX(object_points: *mut c_void, image_points: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvecs: *mut c_void, tvecs: *mut c_void, use_extrinsic_guess: bool, flags: crate::calib3d::SolvePnPMethod, rvec: *mut c_void, tvec: *mut c_void, reprojection_error: *mut c_void) -> Result<i32>;
		pub fn cv_solvePnPRansac_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_bool_int_float_double_const__OutputArrayX_int(object_points: *mut c_void, image_points: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, use_extrinsic_guess: bool, iterations_count: i32, reprojection_error: f32, confidence: f64, inliers: *mut c_void, flags: i32) -> Result<bool>;
		pub fn cv_solvePnPRefineLM_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputOutputArrayX_const__InputOutputArrayX_TermCriteria(object_points: *mut c_void, image_points: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, criteria: *mut c_void) -> Result_void;
		pub fn cv_solvePnPRefineVVS_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputOutputArrayX_const__InputOutputArrayX_TermCriteria_double(object_points: *mut c_void, image_points: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, criteria: *mut c_void, vv_slambda: f64) -> Result_void;
		pub fn cv_solvePnP_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_bool_int(object_points: *mut c_void, image_points: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, use_extrinsic_guess: bool, flags: i32) -> Result<bool>;
		pub fn cv_stereoCalibrate_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputOutputArrayX_const__InputOutputArrayX_const__InputOutputArrayX_const__InputOutputArrayX_Size_const__InputOutputArrayX_const__InputOutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_int_TermCriteria(object_points: *mut c_void, image_points1: *mut c_void, image_points2: *mut c_void, camera_matrix1: *mut c_void, dist_coeffs1: *mut c_void, camera_matrix2: *mut c_void, dist_coeffs2: *mut c_void, image_size: *const core::Size, r: *mut c_void, t: *mut c_void, e: *mut c_void, f: *mut c_void, per_view_errors: *mut c_void, flags: i32, criteria: *mut c_void) -> Result<f64>;
		pub fn cv_stereoCalibrate_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputOutputArrayX_const__InputOutputArrayX_const__InputOutputArrayX_const__InputOutputArrayX_Size_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_int_TermCriteria(object_points: *mut c_void, image_points1: *mut c_void, image_points2: *mut c_void, camera_matrix1: *mut c_void, dist_coeffs1: *mut c_void, camera_matrix2: *mut c_void, dist_coeffs2: *mut c_void, image_size: *const core::Size, r: *mut c_void, t: *mut c_void, e: *mut c_void, f: *mut c_void, flags: i32, criteria: *mut c_void) -> Result<f64>;
		pub fn cv_stereoRectifyUncalibrated_const__InputArrayX_const__InputArrayX_const__InputArrayX_Size_const__OutputArrayX_const__OutputArrayX_double(points1: *mut c_void, points2: *mut c_void, f: *mut c_void, img_size: *const core::Size, h1: *mut c_void, h2: *mut c_void, threshold: f64) -> Result<bool>;
		pub fn cv_stereoRectify_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_Size_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_int_double_Size_RectX_RectX(camera_matrix1: *mut c_void, dist_coeffs1: *mut c_void, camera_matrix2: *mut c_void, dist_coeffs2: *mut c_void, image_size: *const core::Size, r: *mut c_void, t: *mut c_void, r1: *mut c_void, r2: *mut c_void, p1: *mut c_void, p2: *mut c_void, q: *mut c_void, flags: i32, alpha: f64, new_image_size: *const core::Size, valid_pix_roi1: *mut core::Rect, valid_pix_roi2: *mut core::Rect) -> Result_void;
		pub fn cv_triangulatePoints_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX(proj_matr1: *mut c_void, proj_matr2: *mut c_void, proj_points1: *mut c_void, proj_points2: *mut c_void, points4_d: *mut c_void) -> Result_void;
		pub fn cv_undistortPoints_const__InputArrayX_const__OutputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX(src: *mut c_void, dst: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, r: *mut c_void, p: *mut c_void) -> Result_void;
		pub fn cv_undistortPoints_const__InputArrayX_const__OutputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_TermCriteria(src: *mut c_void, dst: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, r: *mut c_void, p: *mut c_void, criteria: *mut c_void) -> Result_void;
		pub fn cv_undistort_const__InputArrayX_const__OutputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX(src: *mut c_void, dst: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, new_camera_matrix: *mut c_void) -> Result_void;
		pub fn cv_validateDisparity_const__InputOutputArrayX_const__InputArrayX_int_int_int(disparity: *mut c_void, cost: *mut c_void, min_disparity: i32, number_of_disparities: i32, disp12_max_disp: i32) -> Result_void;
		pub fn cv_CirclesGridFinderParameters_CirclesGridFinderParameters() -> Result<crate::calib3d::CirclesGridFinderParameters>;
		pub fn cv_LMSolver_run_const_const__InputOutputArrayX(instance: *mut c_void, param: *mut c_void) -> Result<i32>;
		pub fn cv_LMSolver_setMaxIters_int(instance: *mut c_void, max_iters: i32) -> Result_void;
		pub fn cv_LMSolver_getMaxIters_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_LMSolver_create_const_Ptr_Callback_X_int(cb: *mut c_void, max_iters: i32) -> Result<*mut c_void>;
		pub fn cv_LMSolver_create_const_Ptr_Callback_X_int_double(cb: *mut c_void, max_iters: i32, eps: f64) -> Result<*mut c_void>;
		pub fn cv_LMSolver_Callback_compute_const_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, param: *mut c_void, err: *mut c_void, j: *mut c_void) -> Result<bool>;
		pub fn cv_StereoBM_getPreFilterType_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_StereoBM_setPreFilterType_int(instance: *mut c_void, pre_filter_type: i32) -> Result_void;
		pub fn cv_StereoBM_getPreFilterSize_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_StereoBM_setPreFilterSize_int(instance: *mut c_void, pre_filter_size: i32) -> Result_void;
		pub fn cv_StereoBM_getPreFilterCap_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_StereoBM_setPreFilterCap_int(instance: *mut c_void, pre_filter_cap: i32) -> Result_void;
		pub fn cv_StereoBM_getTextureThreshold_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_StereoBM_setTextureThreshold_int(instance: *mut c_void, texture_threshold: i32) -> Result_void;
		pub fn cv_StereoBM_getUniquenessRatio_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_StereoBM_setUniquenessRatio_int(instance: *mut c_void, uniqueness_ratio: i32) -> Result_void;
		pub fn cv_StereoBM_getSmallerBlockSize_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_StereoBM_setSmallerBlockSize_int(instance: *mut c_void, block_size: i32) -> Result_void;
		pub fn cv_StereoBM_getROI1_const(instance: *mut c_void) -> Result<core::Rect>;
		pub fn cv_StereoBM_setROI1_Rect(instance: *mut c_void, roi1: *const core::Rect) -> Result_void;
		pub fn cv_StereoBM_getROI2_const(instance: *mut c_void) -> Result<core::Rect>;
		pub fn cv_StereoBM_setROI2_Rect(instance: *mut c_void, roi2: *const core::Rect) -> Result_void;
		pub fn cv_StereoBM_create_int_int(num_disparities: i32, block_size: i32) -> Result<*mut c_void>;
		pub fn cv_StereoMatcher_compute_const__InputArrayX_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, left: *mut c_void, right: *mut c_void, disparity: *mut c_void) -> Result_void;
		pub fn cv_StereoMatcher_getMinDisparity_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_StereoMatcher_setMinDisparity_int(instance: *mut c_void, min_disparity: i32) -> Result_void;
		pub fn cv_StereoMatcher_getNumDisparities_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_StereoMatcher_setNumDisparities_int(instance: *mut c_void, num_disparities: i32) -> Result_void;
		pub fn cv_StereoMatcher_getBlockSize_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_StereoMatcher_setBlockSize_int(instance: *mut c_void, block_size: i32) -> Result_void;
		pub fn cv_StereoMatcher_getSpeckleWindowSize_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_StereoMatcher_setSpeckleWindowSize_int(instance: *mut c_void, speckle_window_size: i32) -> Result_void;
		pub fn cv_StereoMatcher_getSpeckleRange_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_StereoMatcher_setSpeckleRange_int(instance: *mut c_void, speckle_range: i32) -> Result_void;
		pub fn cv_StereoMatcher_getDisp12MaxDiff_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_StereoMatcher_setDisp12MaxDiff_int(instance: *mut c_void, disp12_max_diff: i32) -> Result_void;
		pub fn cv_StereoSGBM_getPreFilterCap_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_StereoSGBM_setPreFilterCap_int(instance: *mut c_void, pre_filter_cap: i32) -> Result_void;
		pub fn cv_StereoSGBM_getUniquenessRatio_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_StereoSGBM_setUniquenessRatio_int(instance: *mut c_void, uniqueness_ratio: i32) -> Result_void;
		pub fn cv_StereoSGBM_getP1_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_StereoSGBM_setP1_int(instance: *mut c_void, p1: i32) -> Result_void;
		pub fn cv_StereoSGBM_getP2_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_StereoSGBM_setP2_int(instance: *mut c_void, p2: i32) -> Result_void;
		pub fn cv_StereoSGBM_getMode_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_StereoSGBM_setMode_int(instance: *mut c_void, mode: i32) -> Result_void;
		pub fn cv_StereoSGBM_create_int_int_int_int_int_int_int_int_int_int_int(min_disparity: i32, num_disparities: i32, block_size: i32, p1: i32, p2: i32, disp12_max_diff: i32, pre_filter_cap: i32, uniqueness_ratio: i32, speckle_window_size: i32, speckle_range: i32, mode: i32) -> Result<*mut c_void>;
	}
}
pub use calib3d_sys::*;

#[cfg(feature = "contrib")]
mod ccalib_sys {
	use super::*;

	extern "C" {
		pub fn cv_omnidir_calibrate_const__InputArrayX_const__InputArrayX_Size_const__InputOutputArrayX_const__InputOutputArrayX_const__InputOutputArrayX_const__OutputArrayX_const__OutputArrayX_int_TermCriteria_const__OutputArrayX(object_points: *mut c_void, image_points: *mut c_void, size: *const core::Size, k: *mut c_void, xi: *mut c_void, d: *mut c_void, rvecs: *mut c_void, tvecs: *mut c_void, flags: i32, criteria: *mut c_void, idx: *mut c_void) -> Result<f64>;
		pub fn cv_omnidir_initUndistortRectifyMap_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const_SizeX_int_const__OutputArrayX_const__OutputArrayX_int(k: *mut c_void, d: *mut c_void, xi: *mut c_void, r: *mut c_void, p: *mut c_void, size: *const core::Size, mltype: i32, map1: *mut c_void, map2: *mut c_void, flags: i32) -> Result_void;
		pub fn cv_omnidir_projectPoints_const__InputArrayX_const__OutputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_double_const__InputArrayX_const__OutputArrayX(object_points: *mut c_void, image_points: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, k: *mut c_void, xi: f64, d: *mut c_void, jacobian: *mut c_void) -> Result_void;
		pub fn cv_omnidir_stereoCalibrate_const__InputOutputArrayX_const__InputOutputArrayX_const__InputOutputArrayX_const_SizeX_const_SizeX_const__InputOutputArrayX_const__InputOutputArrayX_const__InputOutputArrayX_const__InputOutputArrayX_const__InputOutputArrayX_const__InputOutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_int_TermCriteria_const__OutputArrayX(object_points: *mut c_void, image_points1: *mut c_void, image_points2: *mut c_void, image_size1: *const core::Size, image_size2: *const core::Size, k1: *mut c_void, xi1: *mut c_void, d1: *mut c_void, k2: *mut c_void, xi2: *mut c_void, d2: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, rvecs_l: *mut c_void, tvecs_l: *mut c_void, flags: i32, criteria: *mut c_void, idx: *mut c_void) -> Result<f64>;
		pub fn cv_omnidir_stereoReconstruct_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_int_int_int_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const_SizeX_const__InputArrayX_const__OutputArrayX_int(image1: *mut c_void, image2: *mut c_void, k1: *mut c_void, d1: *mut c_void, xi1: *mut c_void, k2: *mut c_void, d2: *mut c_void, xi2: *mut c_void, r: *mut c_void, t: *mut c_void, flag: i32, num_disparities: i32, sad_window_size: i32, disparity: *mut c_void, image1_rec: *mut c_void, image2_rec: *mut c_void, new_size: *const core::Size, knew: *mut c_void, point_cloud: *mut c_void, point_type: i32) -> Result_void;
		pub fn cv_omnidir_stereoRectify_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(r: *mut c_void, t: *mut c_void, r1: *mut c_void, r2: *mut c_void) -> Result_void;
		pub fn cv_omnidir_undistortImage_const__InputArrayX_const__OutputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_int_const__InputArrayX_const_SizeX_const__InputArrayX(distorted: *mut c_void, undistorted: *mut c_void, k: *mut c_void, d: *mut c_void, xi: *mut c_void, flags: i32, knew: *mut c_void, new_size: *const core::Size, r: *mut c_void) -> Result_void;
		pub fn cv_omnidir_undistortPoints_const__InputArrayX_const__OutputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX(distorted: *mut c_void, undistorted: *mut c_void, k: *mut c_void, d: *mut c_void, xi: *mut c_void, r: *mut c_void) -> Result_void;
		pub fn cv_ccalib_CustomPattern_CustomPattern() -> Result<*mut c_void>;
		pub fn cv_ccalib_CustomPattern_create_const__InputArrayX_Size2f_const__OutputArrayX(instance: *mut c_void, pattern: *mut c_void, board_size: *const core::Size2f, output: *mut c_void) -> Result<bool>;
		pub fn cv_ccalib_CustomPattern_findPattern_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_double_double_bool_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, image: *mut c_void, matched_features: *mut c_void, pattern_points: *mut c_void, ratio: f64, proj_error: f64, refine_position: bool, out: *mut c_void, h: *mut c_void, pattern_corners: *mut c_void) -> Result<bool>;
		pub fn cv_ccalib_CustomPattern_isInitialized(instance: *mut c_void) -> Result<bool>;
		pub fn cv_ccalib_CustomPattern_getPatternPoints_vector_KeyPoint_X(instance: *mut c_void, original_points: *mut c_void) -> Result_void;
		pub fn cv_ccalib_CustomPattern_getPixelSize(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ccalib_CustomPattern_setFeatureDetector_Ptr_FeatureDetector_(instance: *mut c_void, feature_detector: *mut c_void) -> Result<bool>;
		pub fn cv_ccalib_CustomPattern_setDescriptorExtractor_Ptr_DescriptorExtractor_(instance: *mut c_void, extractor: *mut c_void) -> Result<bool>;
		pub fn cv_ccalib_CustomPattern_setDescriptorMatcher_Ptr_DescriptorMatcher_(instance: *mut c_void, matcher: *mut c_void) -> Result<bool>;
		pub fn cv_ccalib_CustomPattern_getFeatureDetector(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ccalib_CustomPattern_getDescriptorExtractor(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ccalib_CustomPattern_getDescriptorMatcher(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ccalib_CustomPattern_calibrate_const__InputArrayX_const__InputArrayX_Size_const__InputOutputArrayX_const__InputOutputArrayX_const__OutputArrayX_const__OutputArrayX_int_TermCriteria(instance: *mut c_void, object_points: *mut c_void, image_points: *mut c_void, image_size: *const core::Size, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvecs: *mut c_void, tvecs: *mut c_void, flags: i32, criteria: *mut c_void) -> Result<f64>;
		pub fn cv_ccalib_CustomPattern_findRt_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputOutputArrayX_const__InputOutputArrayX_bool_int(instance: *mut c_void, object_points: *mut c_void, image_points: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, use_extrinsic_guess: bool, flags: i32) -> Result<bool>;
		pub fn cv_ccalib_CustomPattern_findRt_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputOutputArrayX_const__InputOutputArrayX_bool_int(instance: *mut c_void, image: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, use_extrinsic_guess: bool, flags: i32) -> Result<bool>;
		pub fn cv_ccalib_CustomPattern_findRtRANSAC_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputOutputArrayX_const__InputOutputArrayX_bool_int_float_int_const__OutputArrayX_int(instance: *mut c_void, object_points: *mut c_void, image_points: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, use_extrinsic_guess: bool, iterations_count: i32, reprojection_error: f32, min_inliers_count: i32, inliers: *mut c_void, flags: i32) -> Result<bool>;
		pub fn cv_ccalib_CustomPattern_findRtRANSAC_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputOutputArrayX_const__InputOutputArrayX_bool_int_float_int_const__OutputArrayX_int(instance: *mut c_void, image: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, rvec: *mut c_void, tvec: *mut c_void, use_extrinsic_guess: bool, iterations_count: i32, reprojection_error: f32, min_inliers_count: i32, inliers: *mut c_void, flags: i32) -> Result<bool>;
		pub fn cv_ccalib_CustomPattern_drawOrientation_const__InputOutputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_double_int(instance: *mut c_void, image: *mut c_void, tvec: *mut c_void, rvec: *mut c_void, camera_matrix: *mut c_void, dist_coeffs: *mut c_void, axis_length: f64, axis_width: i32) -> Result_void;
		pub fn cv_multicalib_MultiCameraCalibration_MultiCameraCalibration_int_int_const_stringX_float_float_int_int_int_int_TermCriteria_Ptr_FeatureDetector__Ptr_DescriptorExtractor__Ptr_DescriptorMatcher_(camera_type: i32, n_cameras: i32, file_name: *const c_char, pattern_width: f32, pattern_height: f32, verbose: i32, show_extration: i32, n_mini_matches: i32, flags: i32, criteria: *mut c_void, detector: *mut c_void, descriptor: *mut c_void, matcher: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_multicalib_MultiCameraCalibration_loadImages(instance: *mut c_void) -> Result_void;
		pub fn cv_multicalib_MultiCameraCalibration_initialize(instance: *mut c_void) -> Result_void;
		pub fn cv_multicalib_MultiCameraCalibration_optimizeExtrinsics(instance: *mut c_void) -> Result<f64>;
		pub fn cv_multicalib_MultiCameraCalibration_run(instance: *mut c_void) -> Result<f64>;
		pub fn cv_multicalib_MultiCameraCalibration_writeParameters_const_stringX(instance: *mut c_void, filename: *const c_char) -> Result_void;
		pub fn cv_multicalib_MultiCameraCalibration_edge_cameraVertex_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_multicalib_MultiCameraCalibration_edge_setCameraVertex_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_multicalib_MultiCameraCalibration_edge_photoVertex_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_multicalib_MultiCameraCalibration_edge_setPhotoVertex_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_multicalib_MultiCameraCalibration_edge_photoIndex_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_multicalib_MultiCameraCalibration_edge_setPhotoIndex_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_multicalib_MultiCameraCalibration_edge_transform(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_multicalib_MultiCameraCalibration_edge_setTransform_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_multicalib_MultiCameraCalibration_edge_edge_int_int_int_Mat(cv: i32, pv: i32, pi: i32, trans: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_multicalib_MultiCameraCalibration_vertex_pose(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_multicalib_MultiCameraCalibration_vertex_setPose_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_multicalib_MultiCameraCalibration_vertex_timestamp_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_multicalib_MultiCameraCalibration_vertex_setTimestamp_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_multicalib_MultiCameraCalibration_vertex_vertex_Mat_int(po: *mut c_void, ts: i32) -> Result<*mut c_void>;
		pub fn cv_multicalib_MultiCameraCalibration_vertex_vertex() -> Result<*mut c_void>;
		pub fn cv_randpattern_RandomPatternCornerFinder_RandomPatternCornerFinder_float_float_int_int_int_int_Ptr_FeatureDetector__Ptr_DescriptorExtractor__Ptr_DescriptorMatcher_(pattern_width: f32, pattern_height: f32, nmini_match: i32, depth: i32, verbose: i32, show_extraction: i32, detector: *mut c_void, descriptor: *mut c_void, matcher: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_randpattern_RandomPatternCornerFinder_loadPattern_const_MatX(instance: *mut c_void, pattern_image: *mut c_void) -> Result_void;
		pub fn cv_randpattern_RandomPatternCornerFinder_loadPattern_const_MatX_const_vector_KeyPoint_X_const_MatX(instance: *mut c_void, pattern_image: *mut c_void, pattern_key_points: *mut c_void, pattern_descriptors: *mut c_void) -> Result_void;
		pub fn cv_randpattern_RandomPatternCornerFinder_computeObjectImagePoints_vector_Mat_(instance: *mut c_void, input_images: *mut c_void) -> Result_void;
		pub fn cv_randpattern_RandomPatternCornerFinder_computeObjectImagePointsForSingle_Mat(instance: *mut c_void, input_image: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_randpattern_RandomPatternCornerFinder_getObjectPoints(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_randpattern_RandomPatternCornerFinder_getImagePoints(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_randpattern_RandomPatternGenerator_RandomPatternGenerator_int_int(image_width: i32, image_height: i32) -> Result<*mut c_void>;
		pub fn cv_randpattern_RandomPatternGenerator_generatePattern(instance: *mut c_void) -> Result_void;
		pub fn cv_randpattern_RandomPatternGenerator_getPattern(instance: *mut c_void) -> Result<*mut c_void>;
	}
}
#[cfg(feature = "contrib")]
pub use ccalib_sys::*;

mod core_sys {
	use super::*;

	extern "C" {
		pub fn cv_Cholesky_doubleX_size_t_int_doubleX_size_t_int(a: *mut f64, astep: size_t, m: i32, b: *mut f64, bstep: size_t, n: i32) -> Result<bool>;
		pub fn cv_Cholesky_floatX_size_t_int_floatX_size_t_int(a: *mut f32, astep: size_t, m: i32, b: *mut f32, bstep: size_t, n: i32) -> Result<bool>;
		pub fn cv_LUT_const__InputArrayX_const__InputArrayX_const__OutputArrayX(src: *mut c_void, lut: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_LU_doubleX_size_t_int_doubleX_size_t_int(a: *mut f64, astep: size_t, m: i32, b: *mut f64, bstep: size_t, n: i32) -> Result<i32>;
		pub fn cv_LU_floatX_size_t_int_floatX_size_t_int(a: *mut f32, astep: size_t, m: i32, b: *mut f32, bstep: size_t, n: i32) -> Result<i32>;
		pub fn cv_Mahalanobis_const__InputArrayX_const__InputArrayX_const__InputArrayX(v1: *mut c_void, v2: *mut c_void, icovar: *mut c_void) -> Result<f64>;
		pub fn cv_PCABackProject_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX(data: *mut c_void, mean: *mut c_void, eigenvectors: *mut c_void, result: *mut c_void) -> Result_void;
		pub fn cv_PCACompute_const__InputArrayX_const__InputOutputArrayX_const__OutputArrayX_const__OutputArrayX_double(data: *mut c_void, mean: *mut c_void, eigenvectors: *mut c_void, eigenvalues: *mut c_void, retained_variance: f64) -> Result_void;
		pub fn cv_PCACompute_const__InputArrayX_const__InputOutputArrayX_const__OutputArrayX_const__OutputArrayX_int(data: *mut c_void, mean: *mut c_void, eigenvectors: *mut c_void, eigenvalues: *mut c_void, max_components: i32) -> Result_void;
		pub fn cv_PCACompute_const__InputArrayX_const__InputOutputArrayX_const__OutputArrayX_double(data: *mut c_void, mean: *mut c_void, eigenvectors: *mut c_void, retained_variance: f64) -> Result_void;
		pub fn cv_PCACompute_const__InputArrayX_const__InputOutputArrayX_const__OutputArrayX_int(data: *mut c_void, mean: *mut c_void, eigenvectors: *mut c_void, max_components: i32) -> Result_void;
		pub fn cv_PCAProject_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX(data: *mut c_void, mean: *mut c_void, eigenvectors: *mut c_void, result: *mut c_void) -> Result_void;
		pub fn cv_PSNR_const__InputArrayX_const__InputArrayX_double(src1: *mut c_void, src2: *mut c_void, r: f64) -> Result<f64>;
		pub fn cv_SVBackSubst_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX(w: *mut c_void, u: *mut c_void, vt: *mut c_void, rhs: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_SVDecomp_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_int(src: *mut c_void, w: *mut c_void, u: *mut c_void, vt: *mut c_void, flags: i32) -> Result_void;
		pub fn cv_abs_const_MatExprX(e: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_abs_const_MatX(m: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_absdiff_const__InputArrayX_const__InputArrayX_const__OutputArrayX(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_addWeighted_const__InputArrayX_double_const__InputArrayX_double_double_const__OutputArrayX_int(src1: *mut c_void, alpha: f64, src2: *mut c_void, beta: f64, gamma: f64, dst: *mut c_void, dtype: i32) -> Result_void;
		pub fn cv_add_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__InputArrayX_int(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void, mask: *mut c_void, dtype: i32) -> Result_void;
		pub fn cv_batchDistance_const__InputArrayX_const__InputArrayX_const__OutputArrayX_int_const__OutputArrayX_int_int_const__InputArrayX_int_bool(src1: *mut c_void, src2: *mut c_void, dist: *mut c_void, dtype: i32, nidx: *mut c_void, norm_type: i32, k: i32, mask: *mut c_void, update: i32, crosscheck: bool) -> Result_void;
		pub fn cv_bitwise_and_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__InputArrayX(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_bitwise_not_const__InputArrayX_const__OutputArrayX_const__InputArrayX(src: *mut c_void, dst: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_bitwise_or_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__InputArrayX(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_bitwise_xor_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__InputArrayX(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_borderInterpolate_int_int_int(p: i32, len: i32, border_type: i32) -> Result<i32>;
		pub fn cv_calcCovarMatrix_const__InputArrayX_const__OutputArrayX_const__InputOutputArrayX_int_int(samples: *mut c_void, covar: *mut c_void, mean: *mut c_void, flags: i32, ctype: i32) -> Result_void;
		pub fn cv_cartToPolar_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_bool(x: *mut c_void, y: *mut c_void, magnitude: *mut c_void, angle: *mut c_void, angle_in_degrees: bool) -> Result_void;
		pub fn cv_checkHardwareSupport_int(feature: i32) -> Result<bool>;
		pub fn cv_checkRange_const__InputArrayX_bool_PointX_double_double(a: *mut c_void, quiet: bool, pos: *mut core::Point, min_val: f64, max_val: f64) -> Result<bool>;
		pub fn cv_compare_const__InputArrayX_const__InputArrayX_const__OutputArrayX_int(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void, cmpop: i32) -> Result_void;
		pub fn cv_completeSymm_const__InputOutputArrayX_bool(m: *mut c_void, lower_to_upper: bool) -> Result_void;
		pub fn cv_convertFp16_const__InputArrayX_const__OutputArrayX(src: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_convertScaleAbs_const__InputArrayX_const__OutputArrayX_double_double(src: *mut c_void, dst: *mut c_void, alpha: f64, beta: f64) -> Result_void;
		pub fn cv_copyMakeBorder_const__InputArrayX_const__OutputArrayX_int_int_int_int_int_const_ScalarX(src: *mut c_void, dst: *mut c_void, top: i32, bottom: i32, left: i32, right: i32, border_type: i32, value: *const core::Scalar) -> Result_void;
		pub fn cv_copyTo_const__InputArrayX_const__OutputArrayX_const__InputArrayX(src: *mut c_void, dst: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_countNonZero_const__InputArrayX(src: *mut c_void) -> Result<i32>;
		pub fn cv_cubeRoot_float(val: f32) -> Result<f32>;
		pub fn cv_dct_const__InputArrayX_const__OutputArrayX_int(src: *mut c_void, dst: *mut c_void, flags: i32) -> Result_void;
		pub fn cv_depthToString_int(depth: i32) -> Result<*mut c_void>;
		pub fn cv_detail_check_failed_MatChannels_int_const_CheckContextX(v: i32, ctx: *mut c_void) -> Result_void;
		pub fn cv_detail_check_failed_MatChannels_int_int_const_CheckContextX(v1: i32, v2: i32, ctx: *mut c_void) -> Result_void;
		pub fn cv_detail_check_failed_MatDepth_int_const_CheckContextX(v: i32, ctx: *mut c_void) -> Result_void;
		pub fn cv_detail_check_failed_MatDepth_int_int_const_CheckContextX(v1: i32, v2: i32, ctx: *mut c_void) -> Result_void;
		pub fn cv_detail_check_failed_MatType_int_const_CheckContextX(v: i32, ctx: *mut c_void) -> Result_void;
		pub fn cv_detail_check_failed_MatType_int_int_const_CheckContextX(v1: i32, v2: i32, ctx: *mut c_void) -> Result_void;
		pub fn cv_detail_check_failed_auto_Size__int__Size__int__const_CheckContextX(v1: *const core::Size_<i32>, v2: *const core::Size_<i32>, ctx: *mut c_void) -> Result_void;
		pub fn cv_detail_check_failed_auto_Size__int__const_CheckContextX(v: *const core::Size_<i32>, ctx: *mut c_void) -> Result_void;
		pub fn cv_detail_check_failed_auto_double_const_CheckContextX(v: f64, ctx: *mut c_void) -> Result_void;
		pub fn cv_detail_check_failed_auto_double_double_const_CheckContextX(v1: f64, v2: f64, ctx: *mut c_void) -> Result_void;
		pub fn cv_detail_check_failed_auto_float_const_CheckContextX(v: f32, ctx: *mut c_void) -> Result_void;
		pub fn cv_detail_check_failed_auto_float_float_const_CheckContextX(v1: f32, v2: f32, ctx: *mut c_void) -> Result_void;
		pub fn cv_detail_check_failed_auto_int_const_CheckContextX(v: i32, ctx: *mut c_void) -> Result_void;
		pub fn cv_detail_check_failed_auto_int_int_const_CheckContextX(v1: i32, v2: i32, ctx: *mut c_void) -> Result_void;
		pub fn cv_detail_check_failed_auto_size_t_const_CheckContextX(v: size_t, ctx: *mut c_void) -> Result_void;
		pub fn cv_detail_check_failed_auto_size_t_size_t_const_CheckContextX(v1: size_t, v2: size_t, ctx: *mut c_void) -> Result_void;
		pub fn cv_determinant_const__InputArrayX(mtx: *mut c_void) -> Result<f64>;
		pub fn cv_dft_const__InputArrayX_const__OutputArrayX_int_int(src: *mut c_void, dst: *mut c_void, flags: i32, nonzero_rows: i32) -> Result_void;
		pub fn cv_directx_getTypeFromD3DFORMAT_int(i_d3_dformat: i32) -> Result<i32>;
		pub fn cv_directx_getTypeFromDXGI_FORMAT_int(i_dxgi_format: i32) -> Result<i32>;
		pub fn cv_divide_const__InputArrayX_const__InputArrayX_const__OutputArrayX_double_int(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void, scale: f64, dtype: i32) -> Result_void;
		pub fn cv_divide_double_const__InputArrayX_const__OutputArrayX_int(scale: f64, src2: *mut c_void, dst: *mut c_void, dtype: i32) -> Result_void;
		pub fn cv_eigenNonSymmetric_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(src: *mut c_void, eigenvalues: *mut c_void, eigenvectors: *mut c_void) -> Result_void;
		pub fn cv_eigen_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(src: *mut c_void, eigenvalues: *mut c_void, eigenvectors: *mut c_void) -> Result<bool>;
		pub fn cv_error_const_ExceptionX(exc: *mut c_void) -> Result_void;
		pub fn cv_error_int_const_StringX_const_charX_const_charX_int(_code: i32, _err: *const c_char, _func: *const c_char, _file: *const c_char, _line: i32) -> Result_void;
		pub fn cv_exp_const__InputArrayX_const__OutputArrayX(src: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_extractChannel_const__InputArrayX_const__OutputArrayX_int(src: *mut c_void, dst: *mut c_void, coi: i32) -> Result_void;
		pub fn cv_fastAtan2_float_float(y: f32, x: f32) -> Result<f32>;
		pub fn cv_findNonZero_const__InputArrayX_const__OutputArrayX(src: *mut c_void, idx: *mut c_void) -> Result_void;
		pub fn cv_flip_const__InputArrayX_const__OutputArrayX_int(src: *mut c_void, dst: *mut c_void, flip_code: i32) -> Result_void;
		pub fn cv_gemm_const__InputArrayX_const__InputArrayX_double_const__InputArrayX_double_const__OutputArrayX_int(src1: *mut c_void, src2: *mut c_void, alpha: f64, src3: *mut c_void, beta: f64, dst: *mut c_void, flags: i32) -> Result_void;
		pub fn cv_getBuildInformation() -> Result<*mut c_void>;
		pub fn cv_getCPUFeaturesLine() -> Result<*mut c_void>;
		pub fn cv_getCPUTickCount() -> Result<i64>;
		pub fn cv_getElemSize_int(typ: i32) -> Result<size_t>;
		pub fn cv_getHardwareFeatureName_int(feature: i32) -> Result<*mut c_void>;
		pub fn cv_getImpl_vector_int_X_vector_String_X(impl_: *mut c_void, fun_name: *mut c_void) -> Result<i32>;
		pub fn cv_getNumThreads() -> Result<i32>;
		pub fn cv_getNumberOfCPUs() -> Result<i32>;
		pub fn cv_getOptimalDFTSize_int(vecsize: i32) -> Result<i32>;
		pub fn cv_getThreadNum() -> Result<i32>;
		pub fn cv_getTickCount() -> Result<i64>;
		pub fn cv_getTickFrequency() -> Result<f64>;
		pub fn cv_getVersionMajor() -> Result<i32>;
		pub fn cv_getVersionMinor() -> Result<i32>;
		pub fn cv_getVersionRevision() -> Result<i32>;
		pub fn cv_getVersionString() -> Result<*mut c_void>;
		pub fn cv_glob_String_vector_String_X_bool(pattern: *mut c_char, result: *mut c_void, recursive: bool) -> Result_void;
		pub fn cv_haveOpenVX() -> Result<bool>;
		pub fn cv_hconcat_const__InputArrayX_const__InputArrayX_const__OutputArrayX(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_hconcat_const__InputArrayX_const__OutputArrayX(src: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_idct_const__InputArrayX_const__OutputArrayX_int(src: *mut c_void, dst: *mut c_void, flags: i32) -> Result_void;
		pub fn cv_idft_const__InputArrayX_const__OutputArrayX_int_int(src: *mut c_void, dst: *mut c_void, flags: i32, nonzero_rows: i32) -> Result_void;
		pub fn cv_inRange_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX(src: *mut c_void, lowerb: *mut c_void, upperb: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_insertChannel_const__InputArrayX_const__InputOutputArrayX_int(src: *mut c_void, dst: *mut c_void, coi: i32) -> Result_void;
		pub fn cv_instr_getFlags() -> Result<core::FLAGS>;
		pub fn cv_instr_resetTrace() -> Result_void;
		pub fn cv_instr_setFlags_FLAGS(mode_flags: core::FLAGS) -> Result_void;
		pub fn cv_instr_setUseInstrumentation_bool(flag: bool) -> Result_void;
		pub fn cv_instr_useInstrumentation() -> Result<bool>;
		pub fn cv_invert_const__InputArrayX_const__OutputArrayX_int(src: *mut c_void, dst: *mut c_void, flags: i32) -> Result<f64>;
		pub fn cv_ipp_getIppErrorLocation() -> Result<*mut c_void>;
		pub fn cv_ipp_getIppFeatures() -> Result<u64>;
		pub fn cv_ipp_getIppStatus() -> Result<i32>;
		pub fn cv_ipp_getIppVersion() -> Result<*mut c_void>;
		pub fn cv_ipp_setIppStatus_int_const_charX_const_charX_int(status: i32, funcname: *const c_char, filename: *const c_char, line: i32) -> Result_void;
		pub fn cv_ipp_setUseIPP_NotExact_bool(flag: bool) -> Result_void;
		pub fn cv_ipp_setUseIPP_bool(flag: bool) -> Result_void;
		pub fn cv_ipp_useIPP() -> Result<bool>;
		pub fn cv_ipp_useIPP_NotExact() -> Result<bool>;
		pub fn cv_kmeans_const__InputArrayX_int_const__InputOutputArrayX_TermCriteria_int_int_const__OutputArrayX(data: *mut c_void, k: i32, best_labels: *mut c_void, criteria: *mut c_void, attempts: i32, flags: i32, centers: *mut c_void) -> Result<f64>;
		pub fn cv_log_const__InputArrayX_const__OutputArrayX(src: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_magnitude_const__InputArrayX_const__InputArrayX_const__OutputArrayX(x: *mut c_void, y: *mut c_void, magnitude: *mut c_void) -> Result_void;
		pub fn cv_max_const_MatX_const_MatX(a: *mut c_void, b: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_max_const_MatX_const_MatX_MatX(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_max_const_MatX_double(a: *mut c_void, s: f64) -> Result<*mut c_void>;
		pub fn cv_max_const_UMatX_const_UMatX_UMatX(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_max_const__InputArrayX_const__InputArrayX_const__OutputArrayX(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_max_double_const_MatX(s: f64, a: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_meanStdDev_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_const__InputArrayX(src: *mut c_void, mean: *mut c_void, stddev: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_mean_const__InputArrayX_const__InputArrayX(src: *mut c_void, mask: *mut c_void) -> Result<core::Scalar>;
		pub fn cv_merge_const_MatX_size_t_const__OutputArrayX(mv: *mut c_void, count: size_t, dst: *mut c_void) -> Result_void;
		pub fn cv_merge_const__InputArrayX_const__OutputArrayX(mv: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_minMaxIdx_const__InputArrayX_doubleX_doubleX_intX_intX_const__InputArrayX(src: *mut c_void, min_val: *mut f64, max_val: *mut f64, min_idx: *mut i32, max_idx: *mut i32, mask: *mut c_void) -> Result_void;
		pub fn cv_minMaxLoc_const_SparseMatX_doubleX_doubleX_intX_intX(a: *mut c_void, min_val: *mut f64, max_val: *mut f64, min_idx: *mut i32, max_idx: *mut i32) -> Result_void;
		pub fn cv_minMaxLoc_const__InputArrayX_doubleX_doubleX_PointX_PointX_const__InputArrayX(src: *mut c_void, min_val: *mut f64, max_val: *mut f64, min_loc: *mut core::Point, max_loc: *mut core::Point, mask: *mut c_void) -> Result_void;
		pub fn cv_min_const_MatX_const_MatX(a: *mut c_void, b: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_min_const_MatX_const_MatX_MatX(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_min_const_MatX_double(a: *mut c_void, s: f64) -> Result<*mut c_void>;
		pub fn cv_min_const_UMatX_const_UMatX_UMatX(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_min_const__InputArrayX_const__InputArrayX_const__OutputArrayX(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_min_double_const_MatX(s: f64, a: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_mixChannels_const__InputArrayX_const__InputOutputArrayX_const_intX_size_t(src: *mut c_void, dst: *mut c_void, from_to: *const i32, npairs: size_t) -> Result_void;
		pub fn cv_mixChannels_const__InputArrayX_const__InputOutputArrayX_const_vector_int_X(src: *mut c_void, dst: *mut c_void, from_to: *mut c_void) -> Result_void;
		pub fn cv_mulSpectrums_const__InputArrayX_const__InputArrayX_const__OutputArrayX_int_bool(a: *mut c_void, b: *mut c_void, c: *mut c_void, flags: i32, conj_b: bool) -> Result_void;
		pub fn cv_mulTransposed_const__InputArrayX_const__OutputArrayX_bool_const__InputArrayX_double_int(src: *mut c_void, dst: *mut c_void, a_ta: bool, delta: *mut c_void, scale: f64, dtype: i32) -> Result_void;
		pub fn cv_multiply_const__InputArrayX_const__InputArrayX_const__OutputArrayX_double_int(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void, scale: f64, dtype: i32) -> Result_void;
		pub fn cv_noArray() -> Result<*mut c_void>;
		pub fn cv_norm_const_SparseMatX_int(src: *mut c_void, norm_type: i32) -> Result<f64>;
		pub fn cv_norm_const__InputArrayX_const__InputArrayX_int_const__InputArrayX(src1: *mut c_void, src2: *mut c_void, norm_type: i32, mask: *mut c_void) -> Result<f64>;
		pub fn cv_norm_const__InputArrayX_int_const__InputArrayX(src1: *mut c_void, norm_type: i32, mask: *mut c_void) -> Result<f64>;
		pub fn cv_normalize_const_SparseMatX_SparseMatX_double_int(src: *mut c_void, dst: *mut c_void, alpha: f64, norm_type: i32) -> Result_void;
		pub fn cv_normalize_const__InputArrayX_const__InputOutputArrayX_double_double_int_int_const__InputArrayX(src: *mut c_void, dst: *mut c_void, alpha: f64, beta: f64, norm_type: i32, dtype: i32, mask: *mut c_void) -> Result_void;
		pub fn cv_ocl_attachContext_const_StringX_voidX_voidX_voidX(platform_name: *const c_char, platform_id: *mut c_void, context: *mut c_void, device_id: *mut c_void) -> Result_void;
		pub fn cv_ocl_buildOptionsAddMatrixDescription_StringX_const_StringX_const__InputArrayX(build_options: *mut *mut c_void, name: *const c_char, _m: *mut c_void) -> Result_void;
		pub fn cv_ocl_checkOptimalVectorWidth_const_intX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_OclVectorStrategy(vector_widths: *const i32, src1: *mut c_void, src2: *mut c_void, src3: *mut c_void, src4: *mut c_void, src5: *mut c_void, src6: *mut c_void, src7: *mut c_void, src8: *mut c_void, src9: *mut c_void, strat: core::OclVectorStrategy) -> Result<i32>;
		pub fn cv_ocl_convertFromBuffer_voidX_size_t_int_int_int_UMatX(cl_mem_buffer: *mut c_void, step: size_t, rows: i32, cols: i32, typ: i32, dst: *mut c_void) -> Result_void;
		pub fn cv_ocl_convertFromImage_voidX_UMatX(cl_mem_image: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_ocl_convertTypeStr_int_int_int_charX(sdepth: i32, ddepth: i32, cn: i32, buf: *mut c_char) -> Result<*mut c_void>;
		pub fn cv_ocl_finish() -> Result_void;
		pub fn cv_ocl_getOpenCLErrorString_int(error_code: i32) -> Result<*mut c_void>;
		pub fn cv_ocl_getPlatfomsInfo_vector_PlatformInfo_X(platform_info: *mut c_void) -> Result_void;
		pub fn cv_ocl_haveAmdBlas() -> Result<bool>;
		pub fn cv_ocl_haveAmdFft() -> Result<bool>;
		pub fn cv_ocl_haveOpenCL() -> Result<bool>;
		pub fn cv_ocl_haveSVM() -> Result<bool>;
		pub fn cv_ocl_kernelToStr_const__InputArrayX_int_const_charX(_kernel: *mut c_void, ddepth: i32, name: *const c_char) -> Result<*mut c_void>;
		pub fn cv_ocl_memopTypeToStr_int(t: i32) -> Result<*mut c_void>;
		pub fn cv_ocl_predictOptimalVectorWidthMax_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX(src1: *mut c_void, src2: *mut c_void, src3: *mut c_void, src4: *mut c_void, src5: *mut c_void, src6: *mut c_void, src7: *mut c_void, src8: *mut c_void, src9: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_predictOptimalVectorWidth_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_OclVectorStrategy(src1: *mut c_void, src2: *mut c_void, src3: *mut c_void, src4: *mut c_void, src5: *mut c_void, src6: *mut c_void, src7: *mut c_void, src8: *mut c_void, src9: *mut c_void, strat: core::OclVectorStrategy) -> Result<i32>;
		pub fn cv_ocl_setUseOpenCL_bool(flag: bool) -> Result_void;
		pub fn cv_ocl_typeToStr_int(t: i32) -> Result<*mut c_void>;
		pub fn cv_ocl_useOpenCL() -> Result<bool>;
		pub fn cv_ocl_vecopTypeToStr_int(t: i32) -> Result<*mut c_void>;
		pub fn cv_parallel_for__const_RangeX_const_ParallelLoopBodyX_double(range: *mut c_void, body: *mut c_void, nstripes: f64) -> Result_void;
		pub fn cv_patchNaNs_const__InputOutputArrayX_double(a: *mut c_void, val: f64) -> Result_void;
		pub fn cv_perspectiveTransform_const__InputArrayX_const__OutputArrayX_const__InputArrayX(src: *mut c_void, dst: *mut c_void, m: *mut c_void) -> Result_void;
		pub fn cv_phase_const__InputArrayX_const__InputArrayX_const__OutputArrayX_bool(x: *mut c_void, y: *mut c_void, angle: *mut c_void, angle_in_degrees: bool) -> Result_void;
		pub fn cv_polarToCart_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_bool(magnitude: *mut c_void, angle: *mut c_void, x: *mut c_void, y: *mut c_void, angle_in_degrees: bool) -> Result_void;
		pub fn cv_pow_const__InputArrayX_double_const__OutputArrayX(src: *mut c_void, power: f64, dst: *mut c_void) -> Result_void;
		pub fn cv_randShuffle_const__InputOutputArrayX_double_RNGX(dst: *mut c_void, iter_factor: f64, rng: *mut c_void) -> Result_void;
		pub fn cv_randn_const__InputOutputArrayX_const__InputArrayX_const__InputArrayX(dst: *mut c_void, mean: *mut c_void, stddev: *mut c_void) -> Result_void;
		pub fn cv_randu_const__InputOutputArrayX_const__InputArrayX_const__InputArrayX(dst: *mut c_void, low: *mut c_void, high: *mut c_void) -> Result_void;
		pub fn cv_read_const_FileNodeX_DMatchX_const_DMatchX(node: *mut c_void, value: *mut core::DMatch, default_value: *const core::DMatch) -> Result_void;
		pub fn cv_read_const_FileNodeX_KeyPointX_const_KeyPointX(node: *mut c_void, value: *mut core::KeyPoint, default_value: *const core::KeyPoint) -> Result_void;
		pub fn cv_read_const_FileNodeX_MatX_const_MatX(node: *mut c_void, mat: *mut c_void, default_mat: *mut c_void) -> Result_void;
		pub fn cv_read_const_FileNodeX_SparseMatX_const_SparseMatX(node: *mut c_void, mat: *mut c_void, default_mat: *mut c_void) -> Result_void;
		pub fn cv_read_const_FileNodeX_doubleX_double(node: *mut c_void, value: *mut f64, default_value: f64) -> Result_void;
		pub fn cv_read_const_FileNodeX_floatX_float(node: *mut c_void, value: *mut f32, default_value: f32) -> Result_void;
		pub fn cv_read_const_FileNodeX_intX_int(node: *mut c_void, value: *mut i32, default_value: i32) -> Result_void;
		pub fn cv_read_const_FileNodeX_stringX_const_stringX(node: *mut c_void, value: *mut *mut c_void, default_value: *const c_char) -> Result_void;
		pub fn cv_read_const_FileNodeX_vector_DMatch_X(node: *mut c_void, matches: *mut c_void) -> Result_void;
		pub fn cv_read_const_FileNodeX_vector_KeyPoint_X(node: *mut c_void, keypoints: *mut c_void) -> Result_void;
		pub fn cv_reduce_const__InputArrayX_const__OutputArrayX_int_int_int(src: *mut c_void, dst: *mut c_void, dim: i32, rtype: i32, dtype: i32) -> Result_void;
		pub fn cv_repeat_const_MatX_int_int(src: *mut c_void, ny: i32, nx: i32) -> Result<*mut c_void>;
		pub fn cv_repeat_const__InputArrayX_int_int_const__OutputArrayX(src: *mut c_void, ny: i32, nx: i32, dst: *mut c_void) -> Result_void;
		pub fn cv_rotate_const__InputArrayX_const__OutputArrayX_int(src: *mut c_void, dst: *mut c_void, rotate_code: i32) -> Result_void;
		pub fn cv_samples_addSamplesDataSearchPath_const_StringX(path: *const c_char) -> Result_void;
		pub fn cv_samples_addSamplesDataSearchSubDirectory_const_StringX(subdir: *const c_char) -> Result_void;
		pub fn cv_samples_findFileOrKeep_const_StringX_bool(relative_path: *const c_char, silent_mode: bool) -> Result<*mut c_void>;
		pub fn cv_samples_findFile_const_StringX_bool_bool(relative_path: *const c_char, required: bool, silent_mode: bool) -> Result<*mut c_void>;
		pub fn cv_scaleAdd_const__InputArrayX_double_const__InputArrayX_const__OutputArrayX(src1: *mut c_void, alpha: f64, src2: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_setBreakOnError_bool(flag: bool) -> Result<bool>;
		pub fn cv_setIdentity_const__InputOutputArrayX_const_ScalarX(mtx: *mut c_void, s: *const core::Scalar) -> Result_void;
		pub fn cv_setNumThreads_int(nthreads: i32) -> Result_void;
		pub fn cv_setRNGSeed_int(seed: i32) -> Result_void;
		pub fn cv_setUseOpenVX_bool(flag: bool) -> Result_void;
		pub fn cv_setUseOptimized_bool(onoff: bool) -> Result_void;
		pub fn cv_solveCubic_const__InputArrayX_const__OutputArrayX(coeffs: *mut c_void, roots: *mut c_void) -> Result<i32>;
		pub fn cv_solveLP_const__InputArrayX_const__InputArrayX_const__OutputArrayX(func: *mut c_void, constr: *mut c_void, z: *mut c_void) -> Result<i32>;
		pub fn cv_solvePoly_const__InputArrayX_const__OutputArrayX_int(coeffs: *mut c_void, roots: *mut c_void, max_iters: i32) -> Result<f64>;
		pub fn cv_solve_const__InputArrayX_const__InputArrayX_const__OutputArrayX_int(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void, flags: i32) -> Result<bool>;
		pub fn cv_sortIdx_const__InputArrayX_const__OutputArrayX_int(src: *mut c_void, dst: *mut c_void, flags: i32) -> Result_void;
		pub fn cv_sort_const__InputArrayX_const__OutputArrayX_int(src: *mut c_void, dst: *mut c_void, flags: i32) -> Result_void;
		pub fn cv_split_const_MatX_MatX(src: *mut c_void, mvbegin: *mut c_void) -> Result_void;
		pub fn cv_split_const__InputArrayX_const__OutputArrayX(m: *mut c_void, mv: *mut c_void) -> Result_void;
		pub fn cv_sqrt_const__InputArrayX_const__OutputArrayX(src: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_subtract_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__InputArrayX_int(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void, mask: *mut c_void, dtype: i32) -> Result_void;
		pub fn cv_sum_const__InputArrayX(src: *mut c_void) -> Result<core::Scalar>;
		pub fn cv_swap_MatX_MatX(a: *mut c_void, b: *mut c_void) -> Result_void;
		pub fn cv_swap_UMatX_UMatX(a: *mut c_void, b: *mut c_void) -> Result_void;
		pub fn cv_tempfile_const_charX(suffix: *const c_char) -> Result<*mut c_void>;
		pub fn cv_theRNG() -> Result<*mut c_void>;
		pub fn cv_trace_const__InputArrayX(mtx: *mut c_void) -> Result<core::Scalar>;
		pub fn cv_transform_const__InputArrayX_const__OutputArrayX_const__InputArrayX(src: *mut c_void, dst: *mut c_void, m: *mut c_void) -> Result_void;
		pub fn cv_transpose_const__InputArrayX_const__OutputArrayX(src: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_typeToString_int(typ: i32) -> Result<*mut c_void>;
		pub fn cv_useOpenVX() -> Result<bool>;
		pub fn cv_useOptimized() -> Result<bool>;
		pub fn cv_utils_dumpBool_bool(argument: bool) -> Result<*mut c_void>;
		pub fn cv_utils_dumpCString_const_charX(argument: *const c_char) -> Result<*mut c_void>;
		pub fn cv_utils_dumpDouble_double(argument: f64) -> Result<*mut c_void>;
		pub fn cv_utils_dumpFloat_float(argument: f32) -> Result<*mut c_void>;
		pub fn cv_utils_dumpInputArrayOfArrays_const__InputArrayX(argument: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_utils_dumpInputArray_const__InputArrayX(argument: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_utils_dumpInputOutputArrayOfArrays_const__InputOutputArrayX(argument: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_utils_dumpInputOutputArray_const__InputOutputArrayX(argument: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_utils_dumpInt_int(argument: i32) -> Result<*mut c_void>;
		pub fn cv_utils_dumpSizeT_size_t(argument: size_t) -> Result<*mut c_void>;
		pub fn cv_utils_getThreadID() -> Result<i32>;
		pub fn cv_utils_logging_getLogLevel() -> Result<core::LogLevel>;
		pub fn cv_utils_logging_getLogTagLevel_const_charX(tag: *const c_char) -> Result<core::LogLevel>;
		pub fn cv_utils_logging_internal_getGlobalLogTag() -> Result<*mut c_void>;
		pub fn cv_utils_logging_internal_writeLogMessageEx_LogLevel_const_charX_const_charX_int_const_charX_const_charX(log_level: core::LogLevel, tag: *const c_char, file: *const c_char, line: i32, func: *const c_char, message: *const c_char) -> Result_void;
		pub fn cv_utils_logging_internal_writeLogMessage_LogLevel_const_charX(log_level: core::LogLevel, message: *const c_char) -> Result_void;
		pub fn cv_utils_logging_registerLogTag_LogTagX(plogtag: *mut c_void) -> Result_void;
		pub fn cv_utils_logging_setLogLevel_LogLevel(log_level: core::LogLevel) -> Result<core::LogLevel>;
		pub fn cv_utils_logging_setLogTagLevel_const_charX_LogLevel(tag: *const c_char, level: core::LogLevel) -> Result_void;
		pub fn cv_utils_testAsyncArray_const__InputArrayX(argument: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_utils_testAsyncException() -> Result<*mut c_void>;
		pub fn cv_va_intel_convertFromVASurface_VADisplay_VASurfaceID_Size_const__OutputArrayX(display: *mut c_void, surface: core::va_surface_id, size: *const core::Size, dst: *mut c_void) -> Result_void;
		pub fn cv_va_intel_convertToVASurface_VADisplay_const__InputArrayX_VASurfaceID_Size(display: *mut c_void, src: *mut c_void, surface: core::va_surface_id, size: *const core::Size) -> Result_void;
		pub fn cv_va_intel_ocl_initializeContextFromVA_VADisplay_bool(display: *mut c_void, try_interop: bool) -> Result<*mut c_void>;
		pub fn cv_vconcat_const__InputArrayX_const__InputArrayX_const__OutputArrayX(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_vconcat_const__InputArrayX_const__OutputArrayX(src: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_writeScalar_FileStorageX_const_StringX(fs: *mut c_void, value: *const c_char) -> Result_void;
		pub fn cv_writeScalar_FileStorageX_double(fs: *mut c_void, value: f64) -> Result_void;
		pub fn cv_writeScalar_FileStorageX_float(fs: *mut c_void, value: f32) -> Result_void;
		pub fn cv_writeScalar_FileStorageX_int(fs: *mut c_void, value: i32) -> Result_void;
		pub fn cv_write_FileStorageX_const_StringX_const_MatX(fs: *mut c_void, name: *const c_char, value: *mut c_void) -> Result_void;
		pub fn cv_write_FileStorageX_const_StringX_const_SparseMatX(fs: *mut c_void, name: *const c_char, value: *mut c_void) -> Result_void;
		pub fn cv_write_FileStorageX_const_StringX_const_StringX(fs: *mut c_void, name: *const c_char, value: *const c_char) -> Result_void;
		pub fn cv_write_FileStorageX_const_StringX_const_vector_DMatch_X(fs: *mut c_void, name: *const c_char, value: *mut c_void) -> Result_void;
		pub fn cv_write_FileStorageX_const_StringX_const_vector_KeyPoint_X(fs: *mut c_void, name: *const c_char, value: *mut c_void) -> Result_void;
		pub fn cv_write_FileStorageX_const_StringX_double(fs: *mut c_void, name: *const c_char, value: f64) -> Result_void;
		pub fn cv_write_FileStorageX_const_StringX_float(fs: *mut c_void, name: *const c_char, value: f32) -> Result_void;
		pub fn cv_write_FileStorageX_const_StringX_int(fs: *mut c_void, name: *const c_char, value: i32) -> Result_void;
		pub fn cv_Algorithm_Algorithm() -> Result<*mut c_void>;
		pub fn cv_Algorithm_clear(instance: *mut c_void) -> Result_void;
		pub fn cv_Algorithm_write_const_FileStorageX(instance: *mut c_void, fs: *mut c_void) -> Result_void;
		pub fn cv_Algorithm_write_const_const_Ptr_FileStorage_X_const_StringX(instance: *mut c_void, fs: *mut c_void, name: *const c_char) -> Result_void;
		pub fn cv_Algorithm_read_const_FileNodeX(instance: *mut c_void, fn_: *mut c_void) -> Result_void;
		pub fn cv_Algorithm_empty_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_Algorithm_save_const_const_StringX(instance: *mut c_void, filename: *const c_char) -> Result_void;
		pub fn cv_Algorithm_getDefaultName_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_AsyncArray_AsyncArray() -> Result<*mut c_void>;
		pub fn cv_AsyncArray_AsyncArray_const_AsyncArrayX(o: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_AsyncArray_release(instance: *mut c_void) -> Result_void;
		pub fn cv_AsyncArray_get_const_const__OutputArrayX(instance: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_AsyncArray_get_const_const__OutputArrayX_int64_t(instance: *mut c_void, dst: *mut c_void, timeout_ns: i64) -> Result<bool>;
		pub fn cv_AsyncArray_get_const_const__OutputArrayX_double(instance: *mut c_void, dst: *mut c_void, timeout_ns: f64) -> Result<bool>;
		pub fn cv_AsyncArray_wait_for_const_int64_t(instance: *mut c_void, timeout_ns: i64) -> Result<bool>;
		pub fn cv_AsyncArray_wait_for_const_double(instance: *mut c_void, timeout_ns: f64) -> Result<bool>;
		pub fn cv_AsyncArray_valid_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_AsyncArray_AsyncArray_AsyncArrayX(o: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_AsyncPromise_AsyncPromise() -> Result<*mut c_void>;
		pub fn cv_AsyncPromise_AsyncPromise_const_AsyncPromiseX(o: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_AsyncPromise_release(instance: *mut c_void) -> Result_void;
		pub fn cv_AsyncPromise_getArrayResult(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_AsyncPromise_setValue_const__InputArrayX(instance: *mut c_void, value: *mut c_void) -> Result_void;
		pub fn cv_AsyncPromise_setException_const_ExceptionX(instance: *mut c_void, exception: *mut c_void) -> Result_void;
		pub fn cv_AsyncPromise_AsyncPromise_AsyncPromiseX(o: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_AsyncPromise__getImpl_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_CommandLineParser_CommandLineParser_int_const_charXX_const_StringX(argc: i32, argv: *const *const c_char, keys: *const c_char) -> Result<*mut c_void>;
		pub fn cv_CommandLineParser_CommandLineParser_const_CommandLineParserX(parser: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_CommandLineParser_getPathToApplication_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_CommandLineParser_has_const_const_StringX(instance: *mut c_void, name: *const c_char) -> Result<bool>;
		pub fn cv_CommandLineParser_check_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_CommandLineParser_about_const_StringX(instance: *mut c_void, message: *const c_char) -> Result_void;
		pub fn cv_CommandLineParser_printMessage_const(instance: *mut c_void) -> Result_void;
		pub fn cv_CommandLineParser_printErrors_const(instance: *mut c_void) -> Result_void;
		pub fn cv_ConjGradSolver_create_const_Ptr_Function_X_TermCriteria(f: *mut c_void, termcrit: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_DMatch_DMatch() -> Result<core::DMatch>;
		pub fn cv_DMatch_DMatch_int_int_float(_query_idx: i32, _train_idx: i32, _distance: f32) -> Result<core::DMatch>;
		pub fn cv_DMatch_DMatch_int_int_int_float(_query_idx: i32, _train_idx: i32, _img_idx: i32, _distance: f32) -> Result<core::DMatch>;
		pub fn cv_DownhillSolver_getInitStep_const_const__OutputArrayX(instance: *mut c_void, step: *mut c_void) -> Result_void;
		pub fn cv_DownhillSolver_setInitStep_const__InputArrayX(instance: *mut c_void, step: *mut c_void) -> Result_void;
		pub fn cv_DownhillSolver_create_const_Ptr_Function_X_const__InputArrayX_TermCriteria(f: *mut c_void, init_step: *mut c_void, termcrit: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Exception_msg_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Exception_setMsg_String(instance: *mut c_void, val: *mut c_char) -> Result_void;
		pub fn cv_Exception_code_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_Exception_setCode_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_Exception_err_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Exception_setErr_String(instance: *mut c_void, val: *mut c_char) -> Result_void;
		pub fn cv_Exception_func_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Exception_setFunc_String(instance: *mut c_void, val: *mut c_char) -> Result_void;
		pub fn cv_Exception_file_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Exception_setFile_String(instance: *mut c_void, val: *mut c_char) -> Result_void;
		pub fn cv_Exception_line_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_Exception_setLine_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_Exception_Exception() -> Result<*mut c_void>;
		pub fn cv_Exception_Exception_int_const_StringX_const_StringX_const_StringX_int(_code: i32, _err: *const c_char, _func: *const c_char, _file: *const c_char, _line: i32) -> Result<*mut c_void>;
		pub fn cv_Exception_what_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Exception_formatMessage(instance: *mut c_void) -> Result_void;
		pub fn cv_FileNode_fs_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_FileNode_blockIdx_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_FileNode_setBlockIdx_size_t(instance: *mut c_void, val: size_t) -> Result_void;
		pub fn cv_FileNode_ofs_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_FileNode_setOfs_size_t(instance: *mut c_void, val: size_t) -> Result_void;
		pub fn cv_FileNode_FileNode() -> Result<*mut c_void>;
		pub fn cv_FileNode_FileNode_const_FileStorageX_size_t_size_t(fs: *mut c_void, block_idx: size_t, ofs: size_t) -> Result<*mut c_void>;
		pub fn cv_FileNode_FileNode_const_FileNodeX(node: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_FileNode_operator___const_const_StringX(instance: *mut c_void, nodename: *const c_char) -> Result<*mut c_void>;
		pub fn cv_FileNode_operator___const_const_charX(instance: *mut c_void, nodename: *const c_char) -> Result<*mut c_void>;
		pub fn cv_FileNode_operator___const_int(instance: *mut c_void, i: i32) -> Result<*mut c_void>;
		pub fn cv_FileNode_keys_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_FileNode_type_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_FileNode_empty_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_FileNode_isNone_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_FileNode_isSeq_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_FileNode_isMap_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_FileNode_isInt_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_FileNode_isReal_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_FileNode_isString_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_FileNode_isNamed_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_FileNode_name_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_FileNode_size_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_FileNode_rawSize_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_FileNode_operator_int_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_FileNode_operator_float_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_FileNode_operator_double_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_FileNode_operator_std_string_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_FileNode_isMap_int(flags: i32) -> Result<bool>;
		pub fn cv_FileNode_isSeq_int(flags: i32) -> Result<bool>;
		pub fn cv_FileNode_isCollection_int(flags: i32) -> Result<bool>;
		pub fn cv_FileNode_isEmptyCollection_int(flags: i32) -> Result<bool>;
		pub fn cv_FileNode_isFlow_int(flags: i32) -> Result<bool>;
		pub fn cv_FileNode_ptr(instance: *mut c_void) -> Result<*mut u8>;
		pub fn cv_FileNode_ptr_const(instance: *mut c_void) -> Result<*const u8>;
		pub fn cv_FileNode_begin_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_FileNode_end_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_FileNode_readRaw_const_const_StringX_voidX_size_t(instance: *mut c_void, fmt: *const c_char, vec: *mut c_void, len: size_t) -> Result_void;
		pub fn cv_FileNode_setValue_int_const_voidX_int(instance: *mut c_void, typ: i32, value: *const c_void, len: i32) -> Result_void;
		pub fn cv_FileNode_real_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_FileNode_string_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_FileNode_mat_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_FileNodeIterator_FileNodeIterator() -> Result<*mut c_void>;
		pub fn cv_FileNodeIterator_FileNodeIterator_const_FileNodeX_bool(node: *mut c_void, seek_end: bool) -> Result<*mut c_void>;
		pub fn cv_FileNodeIterator_FileNodeIterator_const_FileNodeIteratorX(it: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_FileNodeIterator_readRaw_const_StringX_voidX_size_t(instance: *mut c_void, fmt: *const c_char, vec: *mut c_void, len: size_t) -> Result<*mut c_void>;
		pub fn cv_FileNodeIterator_remaining_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_FileNodeIterator_equalTo_const_const_FileNodeIteratorX(instance: *mut c_void, it: *mut c_void) -> Result<bool>;
		pub fn cv_FileStorage_state_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_FileStorage_setState_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_FileStorage_elname_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_FileStorage_setElname_string(instance: *mut c_void, val: *mut c_char) -> Result_void;
		pub fn cv_FileStorage_FileStorage() -> Result<*mut c_void>;
		pub fn cv_FileStorage_FileStorage_const_StringX_int_const_StringX(filename: *const c_char, flags: i32, encoding: *const c_char) -> Result<*mut c_void>;
		pub fn cv_FileStorage_open_const_StringX_int_const_StringX(instance: *mut c_void, filename: *const c_char, flags: i32, encoding: *const c_char) -> Result<bool>;
		pub fn cv_FileStorage_isOpened_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_FileStorage_release(instance: *mut c_void) -> Result_void;
		pub fn cv_FileStorage_releaseAndGetString(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_FileStorage_getFirstTopLevelNode_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_FileStorage_root_const_int(instance: *mut c_void, streamidx: i32) -> Result<*mut c_void>;
		pub fn cv_FileStorage_operator___const_const_StringX(instance: *mut c_void, nodename: *const c_char) -> Result<*mut c_void>;
		pub fn cv_FileStorage_operator___const_const_charX(instance: *mut c_void, nodename: *const c_char) -> Result<*mut c_void>;
		pub fn cv_FileStorage_write_const_StringX_int(instance: *mut c_void, name: *const c_char, val: i32) -> Result_void;
		pub fn cv_FileStorage_write_const_StringX_double(instance: *mut c_void, name: *const c_char, val: f64) -> Result_void;
		pub fn cv_FileStorage_write_const_StringX_const_StringX(instance: *mut c_void, name: *const c_char, val: *const c_char) -> Result_void;
		pub fn cv_FileStorage_write_const_StringX_const_MatX(instance: *mut c_void, name: *const c_char, val: *mut c_void) -> Result_void;
		pub fn cv_FileStorage_write_const_StringX_const_vector_String_X(instance: *mut c_void, name: *const c_char, val: *mut c_void) -> Result_void;
		pub fn cv_FileStorage_writeRaw_const_StringX_const_voidX_size_t(instance: *mut c_void, fmt: *const c_char, vec: *const c_void, len: size_t) -> Result_void;
		pub fn cv_FileStorage_writeComment_const_StringX_bool(instance: *mut c_void, comment: *const c_char, append: bool) -> Result_void;
		pub fn cv_FileStorage_startWriteStruct_const_StringX_int_const_StringX(instance: *mut c_void, name: *const c_char, flags: i32, type_name: *const c_char) -> Result_void;
		pub fn cv_FileStorage_endWriteStruct(instance: *mut c_void) -> Result_void;
		pub fn cv_FileStorage_getDefaultObjectName_const_StringX(filename: *const c_char) -> Result<*mut c_void>;
		pub fn cv_FileStorage_getFormat_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_Formatted_next(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Formatted_reset(instance: *mut c_void) -> Result_void;
		pub fn cv_Formatter_format_const_const_MatX(instance: *mut c_void, mtx: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Formatter_set16fPrecision_int(instance: *mut c_void, p: i32) -> Result_void;
		pub fn cv_Formatter_set32fPrecision_int(instance: *mut c_void, p: i32) -> Result_void;
		pub fn cv_Formatter_set64fPrecision_int(instance: *mut c_void, p: i32) -> Result_void;
		pub fn cv_Formatter_setMultiline_bool(instance: *mut c_void, ml: bool) -> Result_void;
		pub fn cv_Formatter_get_FormatType(fmt: core::Formatter_FormatType) -> Result<*mut c_void>;
		pub fn cv_Hamming_normType_const(instance: *mut c_void) -> Result<core::NormTypes>;
		pub fn cv_KeyPoint_KeyPoint() -> Result<core::KeyPoint>;
		pub fn cv_KeyPoint_KeyPoint_Point2f_float_float_float_int_int(_pt: *const core::Point2f, _size: f32, _angle: f32, _response: f32, _octave: i32, _class_id: i32) -> Result<core::KeyPoint>;
		pub fn cv_KeyPoint_KeyPoint_float_float_float_float_float_int_int(x: f32, y: f32, _size: f32, _angle: f32, _response: f32, _octave: i32, _class_id: i32) -> Result<core::KeyPoint>;
		pub fn cv_KeyPoint_hash_const(instance: *const core::KeyPoint) -> Result<size_t>;
		pub fn cv_KeyPoint_convert_const_vector_KeyPoint_X_vector_Point2f_X_const_vector_int_X(keypoints: *mut c_void, points2f: *mut c_void, keypoint_indexes: *mut c_void) -> Result_void;
		pub fn cv_KeyPoint_convert_const_vector_Point2f_X_vector_KeyPoint_X_float_float_int_int(points2f: *mut c_void, keypoints: *mut c_void, size: f32, response: f32, octave: i32, class_id: i32) -> Result_void;
		pub fn cv_KeyPoint_overlap_const_KeyPointX_const_KeyPointX(kp1: *const core::KeyPoint, kp2: *const core::KeyPoint) -> Result<f32>;
		pub fn cv_LDA_LDA_int(num_components: i32) -> Result<*mut c_void>;
		pub fn cv_LDA_LDA_const__InputArrayX_const__InputArrayX_int(src: *mut c_void, labels: *mut c_void, num_components: i32) -> Result<*mut c_void>;
		pub fn cv_LDA_save_const_const_StringX(instance: *mut c_void, filename: *const c_char) -> Result_void;
		pub fn cv_LDA_load_const_StringX(instance: *mut c_void, filename: *const c_char) -> Result_void;
		pub fn cv_LDA_save_const_FileStorageX(instance: *mut c_void, fs: *mut c_void) -> Result_void;
		pub fn cv_LDA_load_const_FileStorageX(instance: *mut c_void, node: *mut c_void) -> Result_void;
		pub fn cv_LDA_compute_const__InputArrayX_const__InputArrayX(instance: *mut c_void, src: *mut c_void, labels: *mut c_void) -> Result_void;
		pub fn cv_LDA_project_const__InputArrayX(instance: *mut c_void, src: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_LDA_reconstruct_const__InputArrayX(instance: *mut c_void, src: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_LDA_eigenvectors_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_LDA_eigenvalues_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_LDA_subspaceProject_const__InputArrayX_const__InputArrayX_const__InputArrayX(w: *mut c_void, mean: *mut c_void, src: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_LDA_subspaceReconstruct_const__InputArrayX_const__InputArrayX_const__InputArrayX(w: *mut c_void, mean: *mut c_void, src: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Mat_flags_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_Mat_setFlags_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_Mat_dims_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_Mat_setDims_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_Mat_rows_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_Mat_setRows_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_Mat_cols_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_Mat_setCols_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_Mat_data(instance: *mut c_void) -> Result<*mut u8>;
		pub fn cv_Mat_setData_unsigned_charX(instance: *mut c_void, val: *mut u8) -> Result_void;
		pub fn cv_Mat_datastart_const(instance: *mut c_void) -> Result<*const u8>;
		pub fn cv_Mat_dataend_const(instance: *mut c_void) -> Result<*const u8>;
		pub fn cv_Mat_datalimit_const(instance: *mut c_void) -> Result<*const u8>;
		pub fn cv_Mat_u(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Mat_setU_UMatDataX(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_Mat_size_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Mat_step_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Mat_Mat() -> Result<*mut c_void>;
		pub fn cv_Mat_Mat_int_int_int(rows: i32, cols: i32, typ: i32) -> Result<*mut c_void>;
		pub fn cv_Mat_Mat_Size_int(size: *const core::Size, typ: i32) -> Result<*mut c_void>;
		pub fn cv_Mat_Mat_int_int_int_const_ScalarX(rows: i32, cols: i32, typ: i32, s: *const core::Scalar) -> Result<*mut c_void>;
		pub fn cv_Mat_Mat_Size_int_const_ScalarX(size: *const core::Size, typ: i32, s: *const core::Scalar) -> Result<*mut c_void>;
		pub fn cv_Mat_Mat_int_const_intX_int(ndims: i32, sizes: *const i32, typ: i32) -> Result<*mut c_void>;
		pub fn cv_Mat_Mat_const_vector_int_X_int(sizes: *mut c_void, typ: i32) -> Result<*mut c_void>;
		pub fn cv_Mat_Mat_int_const_intX_int_const_ScalarX(ndims: i32, sizes: *const i32, typ: i32, s: *const core::Scalar) -> Result<*mut c_void>;
		pub fn cv_Mat_Mat_const_vector_int_X_int_const_ScalarX(sizes: *mut c_void, typ: i32, s: *const core::Scalar) -> Result<*mut c_void>;
		pub fn cv_Mat_Mat_const_MatX(m: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Mat_Mat_int_int_int_voidX_size_t(rows: i32, cols: i32, typ: i32, data: *mut c_void, step: size_t) -> Result<*mut c_void>;
		pub fn cv_Mat_Mat_Size_int_voidX_size_t(size: *const core::Size, typ: i32, data: *mut c_void, step: size_t) -> Result<*mut c_void>;
		pub fn cv_Mat_Mat_int_const_intX_int_voidX_const_size_tX(ndims: i32, sizes: *const i32, typ: i32, data: *mut c_void, steps: *const size_t) -> Result<*mut c_void>;
		pub fn cv_Mat_Mat_const_vector_int_X_int_voidX_const_size_tX(sizes: *mut c_void, typ: i32, data: *mut c_void, steps: *const size_t) -> Result<*mut c_void>;
		pub fn cv_Mat_Mat_const_MatX_const_RangeX_const_RangeX(m: *mut c_void, row_range: *mut c_void, col_range: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Mat_Mat_const_MatX_const_RectX(m: *mut c_void, roi: *const core::Rect) -> Result<*mut c_void>;
		pub fn cv_Mat_Mat_const_MatX_const_vector_Range_X(m: *mut c_void, ranges: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Mat_getUMat_const_AccessFlag_UMatUsageFlags(instance: *mut c_void, access_flags: core::AccessFlag, usage_flags: core::UMatUsageFlags) -> Result<*mut c_void>;
		pub fn cv_Mat_row_const_int(instance: *mut c_void, y: i32) -> Result<*mut c_void>;
		pub fn cv_Mat_col_const_int(instance: *mut c_void, x: i32) -> Result<*mut c_void>;
		pub fn cv_Mat_rowRange_const_int_int(instance: *mut c_void, startrow: i32, endrow: i32) -> Result<*mut c_void>;
		pub fn cv_Mat_rowRange_const_const_RangeX(instance: *mut c_void, r: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Mat_colRange_const_int_int(instance: *mut c_void, startcol: i32, endcol: i32) -> Result<*mut c_void>;
		pub fn cv_Mat_colRange_const_const_RangeX(instance: *mut c_void, r: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Mat_diag_const_int(instance: *mut c_void, d: i32) -> Result<*mut c_void>;
		pub fn cv_Mat_diag_const_MatX(d: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Mat_clone_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Mat_copyTo_const_const__OutputArrayX(instance: *mut c_void, m: *mut c_void) -> Result_void;
		pub fn cv_Mat_copyTo_const_const__OutputArrayX_const__InputArrayX(instance: *mut c_void, m: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_Mat_convertTo_const_const__OutputArrayX_int_double_double(instance: *mut c_void, m: *mut c_void, rtype: i32, alpha: f64, beta: f64) -> Result_void;
		pub fn cv_Mat_assignTo_const_MatX_int(instance: *mut c_void, m: *mut c_void, typ: i32) -> Result_void;
		pub fn cv_Mat_setTo_const__InputArrayX_const__InputArrayX(instance: *mut c_void, value: *mut c_void, mask: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Mat_reshape_const_int_int(instance: *mut c_void, cn: i32, rows: i32) -> Result<*mut c_void>;
		pub fn cv_Mat_reshape_const_int_int_const_intX(instance: *mut c_void, cn: i32, newndims: i32, newsz: *const i32) -> Result<*mut c_void>;
		pub fn cv_Mat_reshape_const_int_const_vector_int_X(instance: *mut c_void, cn: i32, newshape: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Mat_t_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Mat_inv_const_int(instance: *mut c_void, method: i32) -> Result<*mut c_void>;
		pub fn cv_Mat_mul_const_const__InputArrayX_double(instance: *mut c_void, m: *mut c_void, scale: f64) -> Result<*mut c_void>;
		pub fn cv_Mat_cross_const_const__InputArrayX(instance: *mut c_void, m: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Mat_dot_const_const__InputArrayX(instance: *mut c_void, m: *mut c_void) -> Result<f64>;
		pub fn cv_Mat_zeros_int_int_int(rows: i32, cols: i32, typ: i32) -> Result<*mut c_void>;
		pub fn cv_Mat_zeros_Size_int(size: *const core::Size, typ: i32) -> Result<*mut c_void>;
		pub fn cv_Mat_zeros_int_const_intX_int(ndims: i32, sz: *const i32, typ: i32) -> Result<*mut c_void>;
		pub fn cv_Mat_ones_int_int_int(rows: i32, cols: i32, typ: i32) -> Result<*mut c_void>;
		pub fn cv_Mat_ones_Size_int(size: *const core::Size, typ: i32) -> Result<*mut c_void>;
		pub fn cv_Mat_ones_int_const_intX_int(ndims: i32, sz: *const i32, typ: i32) -> Result<*mut c_void>;
		pub fn cv_Mat_eye_int_int_int(rows: i32, cols: i32, typ: i32) -> Result<*mut c_void>;
		pub fn cv_Mat_eye_Size_int(size: *const core::Size, typ: i32) -> Result<*mut c_void>;
		pub fn cv_Mat_create_int_int_int(instance: *mut c_void, rows: i32, cols: i32, typ: i32) -> Result_void;
		pub fn cv_Mat_create_Size_int(instance: *mut c_void, size: *const core::Size, typ: i32) -> Result_void;
		pub fn cv_Mat_create_int_const_intX_int(instance: *mut c_void, ndims: i32, sizes: *const i32, typ: i32) -> Result_void;
		pub fn cv_Mat_create_const_vector_int_X_int(instance: *mut c_void, sizes: *mut c_void, typ: i32) -> Result_void;
		pub fn cv_Mat_addref(instance: *mut c_void) -> Result_void;
		pub fn cv_Mat_release(instance: *mut c_void) -> Result_void;
		pub fn cv_Mat_deallocate(instance: *mut c_void) -> Result_void;
		pub fn cv_Mat_reserve_size_t(instance: *mut c_void, sz: size_t) -> Result_void;
		pub fn cv_Mat_reserveBuffer_size_t(instance: *mut c_void, sz: size_t) -> Result_void;
		pub fn cv_Mat_resize_size_t(instance: *mut c_void, sz: size_t) -> Result_void;
		pub fn cv_Mat_resize_size_t_const_ScalarX(instance: *mut c_void, sz: size_t, s: *const core::Scalar) -> Result_void;
		pub fn cv_Mat_push_back_const_MatX(instance: *mut c_void, m: *mut c_void) -> Result_void;
		pub fn cv_Mat_pop_back_size_t(instance: *mut c_void, nelems: size_t) -> Result_void;
		pub fn cv_Mat_locateROI_const_SizeX_PointX(instance: *mut c_void, whole_size: *mut core::Size, ofs: *mut core::Point) -> Result_void;
		pub fn cv_Mat_adjustROI_int_int_int_int(instance: *mut c_void, dtop: i32, dbottom: i32, dleft: i32, dright: i32) -> Result<*mut c_void>;
		pub fn cv_Mat_isContinuous_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_Mat_isSubmatrix_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_Mat_elemSize_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_Mat_elemSize1_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_Mat_type_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_Mat_depth_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_Mat_channels_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_Mat_step1_const_int(instance: *mut c_void, i: i32) -> Result<size_t>;
		pub fn cv_Mat_empty_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_Mat_total_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_Mat_total_const_int_int(instance: *mut c_void, start_dim: i32, end_dim: i32) -> Result<size_t>;
		pub fn cv_Mat_checkVector_const_int_int_bool(instance: *mut c_void, elem_channels: i32, depth: i32, require_continuous: bool) -> Result<i32>;
		pub fn cv_Mat_ptr_int(instance: *mut c_void, i0: i32) -> Result<*mut u8>;
		pub fn cv_Mat_ptr_const_int(instance: *mut c_void, i0: i32) -> Result<*const u8>;
		pub fn cv_Mat_ptr_int_int(instance: *mut c_void, row: i32, col: i32) -> Result<*mut u8>;
		pub fn cv_Mat_ptr_const_int_int(instance: *mut c_void, row: i32, col: i32) -> Result<*const u8>;
		pub fn cv_Mat_ptr_int_int_int(instance: *mut c_void, i0: i32, i1: i32, i2: i32) -> Result<*mut u8>;
		pub fn cv_Mat_ptr_const_int_int_int(instance: *mut c_void, i0: i32, i1: i32, i2: i32) -> Result<*const u8>;
		pub fn cv_Mat_ptr_const_intX(instance: *mut c_void, idx: *const i32) -> Result<*mut u8>;
		pub fn cv_Mat_ptr_const_const_intX(instance: *mut c_void, idx: *const i32) -> Result<*const u8>;
		pub fn cv_Mat_Mat_MatX(m: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Mat_updateContinuityFlag(instance: *mut c_void) -> Result_void;
		pub fn cv_MatConstIterator_m_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_MatConstIterator_elemSize_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_MatConstIterator_setElemSize_size_t(instance: *mut c_void, val: size_t) -> Result_void;
		pub fn cv_MatConstIterator_ptr_const(instance: *mut c_void) -> Result<*const u8>;
		pub fn cv_MatConstIterator_sliceStart_const(instance: *mut c_void) -> Result<*const u8>;
		pub fn cv_MatConstIterator_sliceEnd_const(instance: *mut c_void) -> Result<*const u8>;
		pub fn cv_MatConstIterator_MatConstIterator() -> Result<*mut c_void>;
		pub fn cv_MatConstIterator_MatConstIterator_const_MatX(_m: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_MatConstIterator_MatConstIterator_const_MatX_int_int(_m: *mut c_void, _row: i32, _col: i32) -> Result<*mut c_void>;
		pub fn cv_MatConstIterator_MatConstIterator_const_MatX_Point(_m: *mut c_void, _pt: *const core::Point) -> Result<*mut c_void>;
		pub fn cv_MatConstIterator_MatConstIterator_const_MatX_const_intX(_m: *mut c_void, _idx: *const i32) -> Result<*mut c_void>;
		pub fn cv_MatConstIterator_MatConstIterator_const_MatConstIteratorX(it: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_MatConstIterator_operator___const_ptrdiff_t(instance: *mut c_void, i: ptrdiff_t) -> Result<*const u8>;
		pub fn cv_MatConstIterator_pos_const(instance: *mut c_void) -> Result<core::Point>;
		pub fn cv_MatConstIterator_pos_const_intX(instance: *mut c_void, _idx: *mut i32) -> Result_void;
		pub fn cv_MatConstIterator_lpos_const(instance: *mut c_void) -> Result<ptrdiff_t>;
		pub fn cv_MatConstIterator_seek_ptrdiff_t_bool(instance: *mut c_void, ofs: ptrdiff_t, relative: bool) -> Result_void;
		pub fn cv_MatConstIterator_seek_const_intX_bool(instance: *mut c_void, _idx: *const i32, relative: bool) -> Result_void;
		pub fn cv_MatExpr_flags_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_MatExpr_setFlags_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_MatExpr_a(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_MatExpr_setA_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_MatExpr_b(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_MatExpr_setB_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_MatExpr_c(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_MatExpr_setC_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_MatExpr_alpha_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_MatExpr_setAlpha_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_MatExpr_beta_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_MatExpr_setBeta_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_MatExpr_s_const(instance: *mut c_void) -> Result<core::Scalar>;
		pub fn cv_MatExpr_setS_Scalar(instance: *mut c_void, val: *const core::Scalar) -> Result_void;
		pub fn cv_MatExpr_MatExpr() -> Result<*mut c_void>;
		pub fn cv_MatExpr_MatExpr_const_MatX(m: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_MatExpr_MatExpr_const_MatOpX_int_const_MatX_const_MatX_const_MatX_double_double_const_ScalarX(_op: *mut c_void, _flags: i32, _a: *mut c_void, _b: *mut c_void, _c: *mut c_void, _alpha: f64, _beta: f64, _s: *const core::Scalar) -> Result<*mut c_void>;
		pub fn cv_MatExpr_operator_cv_Mat_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_MatExpr_size_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_MatExpr_type_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_MatExpr_row_const_int(instance: *mut c_void, y: i32) -> Result<*mut c_void>;
		pub fn cv_MatExpr_col_const_int(instance: *mut c_void, x: i32) -> Result<*mut c_void>;
		pub fn cv_MatExpr_diag_const_int(instance: *mut c_void, d: i32) -> Result<*mut c_void>;
		pub fn cv_MatExpr_t_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_MatExpr_inv_const_int(instance: *mut c_void, method: i32) -> Result<*mut c_void>;
		pub fn cv_MatExpr_mul_const_const_MatExprX_double(instance: *mut c_void, e: *mut c_void, scale: f64) -> Result<*mut c_void>;
		pub fn cv_MatExpr_mul_const_const_MatX_double(instance: *mut c_void, m: *mut c_void, scale: f64) -> Result<*mut c_void>;
		pub fn cv_MatExpr_cross_const_const_MatX(instance: *mut c_void, m: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_MatExpr_dot_const_const_MatX(instance: *mut c_void, m: *mut c_void) -> Result<f64>;
		pub fn cv_MatOp_elementWise_const_const_MatExprX(instance: *mut c_void, expr: *mut c_void) -> Result<bool>;
		pub fn cv_MatOp_assign_const_const_MatExprX_MatX_int(instance: *mut c_void, expr: *mut c_void, m: *mut c_void, typ: i32) -> Result_void;
		pub fn cv_MatOp_roi_const_const_MatExprX_const_RangeX_const_RangeX_MatExprX(instance: *mut c_void, expr: *mut c_void, row_range: *mut c_void, col_range: *mut c_void, res: *mut c_void) -> Result_void;
		pub fn cv_MatOp_diag_const_const_MatExprX_int_MatExprX(instance: *mut c_void, expr: *mut c_void, d: i32, res: *mut c_void) -> Result_void;
		pub fn cv_MatOp_augAssignAdd_const_const_MatExprX_MatX(instance: *mut c_void, expr: *mut c_void, m: *mut c_void) -> Result_void;
		pub fn cv_MatOp_augAssignSubtract_const_const_MatExprX_MatX(instance: *mut c_void, expr: *mut c_void, m: *mut c_void) -> Result_void;
		pub fn cv_MatOp_augAssignMultiply_const_const_MatExprX_MatX(instance: *mut c_void, expr: *mut c_void, m: *mut c_void) -> Result_void;
		pub fn cv_MatOp_augAssignDivide_const_const_MatExprX_MatX(instance: *mut c_void, expr: *mut c_void, m: *mut c_void) -> Result_void;
		pub fn cv_MatOp_augAssignAnd_const_const_MatExprX_MatX(instance: *mut c_void, expr: *mut c_void, m: *mut c_void) -> Result_void;
		pub fn cv_MatOp_augAssignOr_const_const_MatExprX_MatX(instance: *mut c_void, expr: *mut c_void, m: *mut c_void) -> Result_void;
		pub fn cv_MatOp_augAssignXor_const_const_MatExprX_MatX(instance: *mut c_void, expr: *mut c_void, m: *mut c_void) -> Result_void;
		pub fn cv_MatOp_add_const_const_MatExprX_const_MatExprX_MatExprX(instance: *mut c_void, expr1: *mut c_void, expr2: *mut c_void, res: *mut c_void) -> Result_void;
		pub fn cv_MatOp_add_const_const_MatExprX_const_ScalarX_MatExprX(instance: *mut c_void, expr1: *mut c_void, s: *const core::Scalar, res: *mut c_void) -> Result_void;
		pub fn cv_MatOp_subtract_const_const_MatExprX_const_MatExprX_MatExprX(instance: *mut c_void, expr1: *mut c_void, expr2: *mut c_void, res: *mut c_void) -> Result_void;
		pub fn cv_MatOp_subtract_const_const_ScalarX_const_MatExprX_MatExprX(instance: *mut c_void, s: *const core::Scalar, expr: *mut c_void, res: *mut c_void) -> Result_void;
		pub fn cv_MatOp_multiply_const_const_MatExprX_const_MatExprX_MatExprX_double(instance: *mut c_void, expr1: *mut c_void, expr2: *mut c_void, res: *mut c_void, scale: f64) -> Result_void;
		pub fn cv_MatOp_multiply_const_const_MatExprX_double_MatExprX(instance: *mut c_void, expr1: *mut c_void, s: f64, res: *mut c_void) -> Result_void;
		pub fn cv_MatOp_divide_const_const_MatExprX_const_MatExprX_MatExprX_double(instance: *mut c_void, expr1: *mut c_void, expr2: *mut c_void, res: *mut c_void, scale: f64) -> Result_void;
		pub fn cv_MatOp_divide_const_double_const_MatExprX_MatExprX(instance: *mut c_void, s: f64, expr: *mut c_void, res: *mut c_void) -> Result_void;
		pub fn cv_MatOp_abs_const_const_MatExprX_MatExprX(instance: *mut c_void, expr: *mut c_void, res: *mut c_void) -> Result_void;
		pub fn cv_MatOp_transpose_const_const_MatExprX_MatExprX(instance: *mut c_void, expr: *mut c_void, res: *mut c_void) -> Result_void;
		pub fn cv_MatOp_matmul_const_const_MatExprX_const_MatExprX_MatExprX(instance: *mut c_void, expr1: *mut c_void, expr2: *mut c_void, res: *mut c_void) -> Result_void;
		pub fn cv_MatOp_invert_const_const_MatExprX_int_MatExprX(instance: *mut c_void, expr: *mut c_void, method: i32, res: *mut c_void) -> Result_void;
		pub fn cv_MatOp_size_const_const_MatExprX(instance: *mut c_void, expr: *mut c_void) -> Result<core::Size>;
		pub fn cv_MatOp_type_const_const_MatExprX(instance: *mut c_void, expr: *mut c_void) -> Result<i32>;
		pub fn cv_MatSize_p(instance: *mut c_void) -> Result<*mut i32>;
		pub fn cv_MatSize_setP_intX(instance: *mut c_void, val: *mut i32) -> Result_void;
		pub fn cv_MatSize_MatSize_intX(_p: *mut i32) -> Result<*mut c_void>;
		pub fn cv_MatSize_dims_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_MatSize_operator___const_int(instance: *mut c_void, i: i32) -> Result<i32>;
		pub fn cv_MatSize_operator___int(instance: *mut c_void, i: i32) -> Result<i32>;
		pub fn cv_MatSize_operator_const_intX_const(instance: *mut c_void) -> Result<*const i32>;
		pub fn cv_MatStep_p(instance: *mut c_void) -> Result<*mut size_t>;
		pub fn cv_MatStep_setP_size_tX(instance: *mut c_void, val: *mut size_t) -> Result_void;
		pub fn cv_MatStep_buf(instance: *mut c_void) -> Result<*mut [size_t; 2]>;
		pub fn cv_MatStep_MatStep() -> Result<*mut c_void>;
		pub fn cv_MatStep_MatStep_size_t(s: size_t) -> Result<*mut c_void>;
		pub fn cv_MatStep_operator___const_int(instance: *mut c_void, i: i32) -> Result<size_t>;
		pub fn cv_MatStep_operator___int(instance: *mut c_void, i: i32) -> Result<size_t>;
		pub fn cv_MatStep_operator_size_t_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_Matx_AddOp_Matx_AddOp() -> Result<*mut c_void>;
		pub fn cv_Matx_AddOp_Matx_AddOp_const_Matx_AddOpX(unnamed: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Matx_DivOp_Matx_DivOp() -> Result<*mut c_void>;
		pub fn cv_Matx_DivOp_Matx_DivOp_const_Matx_DivOpX(unnamed: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Matx_MatMulOp_Matx_MatMulOp() -> Result<*mut c_void>;
		pub fn cv_Matx_MatMulOp_Matx_MatMulOp_const_Matx_MatMulOpX(unnamed: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Matx_MulOp_Matx_MulOp() -> Result<*mut c_void>;
		pub fn cv_Matx_MulOp_Matx_MulOp_const_Matx_MulOpX(unnamed: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Matx_ScaleOp_Matx_ScaleOp() -> Result<*mut c_void>;
		pub fn cv_Matx_ScaleOp_Matx_ScaleOp_const_Matx_ScaleOpX(unnamed: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Matx_SubOp_Matx_SubOp() -> Result<*mut c_void>;
		pub fn cv_Matx_SubOp_Matx_SubOp_const_Matx_SubOpX(unnamed: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Matx_TOp_Matx_TOp() -> Result<*mut c_void>;
		pub fn cv_Matx_TOp_Matx_TOp_const_Matx_TOpX(unnamed: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_MinProblemSolver_getFunction_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_MinProblemSolver_setFunction_const_Ptr_Function_X(instance: *mut c_void, f: *mut c_void) -> Result_void;
		pub fn cv_MinProblemSolver_getTermCriteria_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_MinProblemSolver_setTermCriteria_const_TermCriteriaX(instance: *mut c_void, termcrit: *mut c_void) -> Result_void;
		pub fn cv_MinProblemSolver_minimize_const__InputOutputArrayX(instance: *mut c_void, x: *mut c_void) -> Result<f64>;
		pub fn cv_MinProblemSolver_Function_getDims_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_MinProblemSolver_Function_getGradientEps_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_MinProblemSolver_Function_calc_const_const_doubleX(instance: *mut c_void, x: *const f64) -> Result<f64>;
		pub fn cv_MinProblemSolver_Function_getGradient_const_doubleX_doubleX(instance: *mut c_void, x: *const f64, grad: *mut f64) -> Result_void;
		pub fn cv_Moments_Moments() -> Result<core::Moments>;
		pub fn cv_Moments_Moments_double_double_double_double_double_double_double_double_double_double(m00: f64, m10: f64, m01: f64, m20: f64, m11: f64, m02: f64, m30: f64, m21: f64, m12: f64, m03: f64) -> Result<core::Moments>;
		pub fn cv_PCA_eigenvectors(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_PCA_setEigenvectors_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_PCA_eigenvalues(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_PCA_setEigenvalues_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_PCA_mean(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_PCA_setMean_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_PCA_PCA() -> Result<*mut c_void>;
		pub fn cv_PCA_PCA_const__InputArrayX_const__InputArrayX_int_int(data: *mut c_void, mean: *mut c_void, flags: i32, max_components: i32) -> Result<*mut c_void>;
		pub fn cv_PCA_PCA_const__InputArrayX_const__InputArrayX_int_double(data: *mut c_void, mean: *mut c_void, flags: i32, retained_variance: f64) -> Result<*mut c_void>;
		pub fn cv_PCA_project_const_const__InputArrayX(instance: *mut c_void, vec: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_PCA_project_const_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, vec: *mut c_void, result: *mut c_void) -> Result_void;
		pub fn cv_PCA_backProject_const_const__InputArrayX(instance: *mut c_void, vec: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_PCA_backProject_const_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, vec: *mut c_void, result: *mut c_void) -> Result_void;
		pub fn cv_PCA_write_const_FileStorageX(instance: *mut c_void, fs: *mut c_void) -> Result_void;
		pub fn cv_PCA_read_const_FileNodeX(instance: *mut c_void, fn_: *mut c_void) -> Result_void;
		pub fn cv_RNG_state_const(instance: *mut c_void) -> Result<u64>;
		pub fn cv_RNG_setState_uint64_t(instance: *mut c_void, val: u64) -> Result_void;
		pub fn cv_RNG_RNG() -> Result<*mut c_void>;
		pub fn cv_RNG_RNG_uint64_t(state: u64) -> Result<*mut c_void>;
		pub fn cv_RNG_next(instance: *mut c_void) -> Result<u32>;
		pub fn cv_RNG_operator_unsigned_char(instance: *mut c_void) -> Result<u8>;
		pub fn cv_RNG_operator_signed_char(instance: *mut c_void) -> Result<i8>;
		pub fn cv_RNG_operator_unsigned_short(instance: *mut c_void) -> Result<u16>;
		pub fn cv_RNG_operator_short(instance: *mut c_void) -> Result<i16>;
		pub fn cv_RNG_operator_unsigned_int(instance: *mut c_void) -> Result<u32>;
		pub fn cv_RNG_operator_int(instance: *mut c_void) -> Result<i32>;
		pub fn cv_RNG_operator_float(instance: *mut c_void) -> Result<f32>;
		pub fn cv_RNG_operator_double(instance: *mut c_void) -> Result<f64>;
		pub fn cv_RNG_uniform_int_int(instance: *mut c_void, a: i32, b: i32) -> Result<i32>;
		pub fn cv_RNG_uniform_float_float(instance: *mut c_void, a: f32, b: f32) -> Result<f32>;
		pub fn cv_RNG_uniform_double_double(instance: *mut c_void, a: f64, b: f64) -> Result<f64>;
		pub fn cv_RNG_fill_const__InputOutputArrayX_int_const__InputArrayX_const__InputArrayX_bool(instance: *mut c_void, mat: *mut c_void, dist_type: i32, a: *mut c_void, b: *mut c_void, saturate_range: bool) -> Result_void;
		pub fn cv_RNG_gaussian_double(instance: *mut c_void, sigma: f64) -> Result<f64>;
		pub fn cv_RNG_MT19937_RNG_MT19937() -> Result<*mut c_void>;
		pub fn cv_RNG_MT19937_RNG_MT19937_unsigned_int(s: u32) -> Result<*mut c_void>;
		pub fn cv_RNG_MT19937_seed_unsigned_int(instance: *mut c_void, s: u32) -> Result_void;
		pub fn cv_RNG_MT19937_next(instance: *mut c_void) -> Result<u32>;
		pub fn cv_RNG_MT19937_operator_int(instance: *mut c_void) -> Result<i32>;
		pub fn cv_RNG_MT19937_operator_unsigned_int(instance: *mut c_void) -> Result<u32>;
		pub fn cv_RNG_MT19937_operator_float(instance: *mut c_void) -> Result<f32>;
		pub fn cv_RNG_MT19937_operator_double(instance: *mut c_void) -> Result<f64>;
		pub fn cv_RNG_MT19937_uniform_int_int(instance: *mut c_void, a: i32, b: i32) -> Result<i32>;
		pub fn cv_RNG_MT19937_uniform_float_float(instance: *mut c_void, a: f32, b: f32) -> Result<f32>;
		pub fn cv_RNG_MT19937_uniform_double_double(instance: *mut c_void, a: f64, b: f64) -> Result<f64>;
		pub fn cv_Range_start_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_Range_setStart_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_Range_end_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_Range_setEnd_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_Range_Range() -> Result<*mut c_void>;
		pub fn cv_Range_Range_int_int(_start: i32, _end: i32) -> Result<*mut c_void>;
		pub fn cv_Range_size_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_Range_empty_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_Range_all() -> Result<*mut c_void>;
		pub fn cv_RotatedRect_center_const(instance: *mut c_void) -> Result<core::Point2f>;
		pub fn cv_RotatedRect_setCenter_Point2f(instance: *mut c_void, val: *const core::Point2f) -> Result_void;
		pub fn cv_RotatedRect_size_const(instance: *mut c_void) -> Result<core::Size2f>;
		pub fn cv_RotatedRect_setSize_Size2f(instance: *mut c_void, val: *const core::Size2f) -> Result_void;
		pub fn cv_RotatedRect_angle_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_RotatedRect_setAngle_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_RotatedRect_RotatedRect() -> Result<*mut c_void>;
		pub fn cv_RotatedRect_RotatedRect_const_Point2fX_const_Size2fX_float(center: *const core::Point2f, size: *const core::Size2f, angle: f32) -> Result<*mut c_void>;
		pub fn cv_RotatedRect_RotatedRect_const_Point2fX_const_Point2fX_const_Point2fX(point1: *const core::Point2f, point2: *const core::Point2f, point3: *const core::Point2f) -> Result<*mut c_void>;
		pub fn cv_RotatedRect_points_const_Point2fX(instance: *mut c_void, pts: *mut core::Point2f) -> Result_void;
		pub fn cv_RotatedRect_boundingRect_const(instance: *mut c_void) -> Result<core::Rect>;
		pub fn cv_RotatedRect_boundingRect2f_const(instance: *mut c_void) -> Result<core::Rect_<f32>>;
		pub fn cv_SVD_u(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_SVD_setU_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_SVD_w(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_SVD_setW_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_SVD_vt(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_SVD_setVt_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_SVD_SVD() -> Result<*mut c_void>;
		pub fn cv_SVD_SVD_const__InputArrayX_int(src: *mut c_void, flags: i32) -> Result<*mut c_void>;
		pub fn cv_SVD_compute_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_int(src: *mut c_void, w: *mut c_void, u: *mut c_void, vt: *mut c_void, flags: i32) -> Result_void;
		pub fn cv_SVD_compute_const__InputArrayX_const__OutputArrayX_int(src: *mut c_void, w: *mut c_void, flags: i32) -> Result_void;
		pub fn cv_SVD_backSubst_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX(w: *mut c_void, u: *mut c_void, vt: *mut c_void, rhs: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_SVD_solveZ_const__InputArrayX_const__OutputArrayX(src: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_SVD_backSubst_const_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, rhs: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_SparseMat_flags_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_SparseMat_setFlags_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_SparseMat_hdr(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_SparseMat_setHdr_HdrX(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_SparseMat_SparseMat() -> Result<*mut c_void>;
		pub fn cv_SparseMat_SparseMat_int_const_intX_int(dims: i32, _sizes: *const i32, _type: i32) -> Result<*mut c_void>;
		pub fn cv_SparseMat_SparseMat_const_SparseMatX(m: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_SparseMat_SparseMat_const_MatX(m: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_SparseMat_clone_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_SparseMat_copyTo_const_SparseMatX(instance: *mut c_void, m: *mut c_void) -> Result_void;
		pub fn cv_SparseMat_copyTo_const_MatX(instance: *mut c_void, m: *mut c_void) -> Result_void;
		pub fn cv_SparseMat_convertTo_const_SparseMatX_int_double(instance: *mut c_void, m: *mut c_void, rtype: i32, alpha: f64) -> Result_void;
		pub fn cv_SparseMat_convertTo_const_MatX_int_double_double(instance: *mut c_void, m: *mut c_void, rtype: i32, alpha: f64, beta: f64) -> Result_void;
		pub fn cv_SparseMat_assignTo_const_SparseMatX_int(instance: *mut c_void, m: *mut c_void, typ: i32) -> Result_void;
		pub fn cv_SparseMat_create_int_const_intX_int(instance: *mut c_void, dims: i32, _sizes: *const i32, _type: i32) -> Result_void;
		pub fn cv_SparseMat_clear(instance: *mut c_void) -> Result_void;
		pub fn cv_SparseMat_addref(instance: *mut c_void) -> Result_void;
		pub fn cv_SparseMat_release(instance: *mut c_void) -> Result_void;
		pub fn cv_SparseMat_elemSize_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_SparseMat_elemSize1_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_SparseMat_type_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_SparseMat_depth_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_SparseMat_channels_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_SparseMat_size_const(instance: *mut c_void) -> Result<*const i32>;
		pub fn cv_SparseMat_size_const_int(instance: *mut c_void, i: i32) -> Result<i32>;
		pub fn cv_SparseMat_dims_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_SparseMat_nzcount_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_SparseMat_hash_const_int(instance: *mut c_void, i0: i32) -> Result<size_t>;
		pub fn cv_SparseMat_hash_const_int_int(instance: *mut c_void, i0: i32, i1: i32) -> Result<size_t>;
		pub fn cv_SparseMat_hash_const_int_int_int(instance: *mut c_void, i0: i32, i1: i32, i2: i32) -> Result<size_t>;
		pub fn cv_SparseMat_hash_const_const_intX(instance: *mut c_void, idx: *const i32) -> Result<size_t>;
		pub fn cv_SparseMat_ptr_int_bool_size_tX(instance: *mut c_void, i0: i32, create_missing: bool, hashval: *mut size_t) -> Result<*mut u8>;
		pub fn cv_SparseMat_ptr_int_int_bool_size_tX(instance: *mut c_void, i0: i32, i1: i32, create_missing: bool, hashval: *mut size_t) -> Result<*mut u8>;
		pub fn cv_SparseMat_ptr_int_int_int_bool_size_tX(instance: *mut c_void, i0: i32, i1: i32, i2: i32, create_missing: bool, hashval: *mut size_t) -> Result<*mut u8>;
		pub fn cv_SparseMat_ptr_const_intX_bool_size_tX(instance: *mut c_void, idx: *const i32, create_missing: bool, hashval: *mut size_t) -> Result<*mut u8>;
		pub fn cv_SparseMat_erase_int_int_size_tX(instance: *mut c_void, i0: i32, i1: i32, hashval: *mut size_t) -> Result_void;
		pub fn cv_SparseMat_erase_int_int_int_size_tX(instance: *mut c_void, i0: i32, i1: i32, i2: i32, hashval: *mut size_t) -> Result_void;
		pub fn cv_SparseMat_erase_const_intX_size_tX(instance: *mut c_void, idx: *const i32, hashval: *mut size_t) -> Result_void;
		pub fn cv_SparseMat_begin(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_SparseMat_begin_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_SparseMat_end(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_SparseMat_end_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_SparseMat_node_size_t(instance: *mut c_void, nidx: size_t) -> Result<*mut c_void>;
		pub fn cv_SparseMat_node_const_size_t(instance: *mut c_void, nidx: size_t) -> Result<*mut c_void>;
		pub fn cv_SparseMat_newNode_const_intX_size_t(instance: *mut c_void, idx: *const i32, hashval: size_t) -> Result<*mut u8>;
		pub fn cv_SparseMat_removeNode_size_t_size_t_size_t(instance: *mut c_void, hidx: size_t, nidx: size_t, previdx: size_t) -> Result_void;
		pub fn cv_SparseMat_resizeHashTab_size_t(instance: *mut c_void, newsize: size_t) -> Result_void;
		pub fn cv_SparseMat_Hdr_refcount_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_SparseMat_Hdr_setRefcount_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_SparseMat_Hdr_dims_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_SparseMat_Hdr_setDims_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_SparseMat_Hdr_valueOffset_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_SparseMat_Hdr_setValueOffset_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_SparseMat_Hdr_nodeSize_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_SparseMat_Hdr_setNodeSize_size_t(instance: *mut c_void, val: size_t) -> Result_void;
		pub fn cv_SparseMat_Hdr_nodeCount_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_SparseMat_Hdr_setNodeCount_size_t(instance: *mut c_void, val: size_t) -> Result_void;
		pub fn cv_SparseMat_Hdr_freeList_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_SparseMat_Hdr_setFreeList_size_t(instance: *mut c_void, val: size_t) -> Result_void;
		pub fn cv_SparseMat_Hdr_pool(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_SparseMat_Hdr_setPool_vector_unsigned_char_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_SparseMat_Hdr_hashtab(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_SparseMat_Hdr_setHashtab_vector_size_t_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_SparseMat_Hdr_size(instance: *mut c_void) -> Result<*mut [i32; 32]>;
		pub fn cv_SparseMat_Hdr_Hdr_int_const_intX_int(_dims: i32, _sizes: *const i32, _type: i32) -> Result<*mut c_void>;
		pub fn cv_SparseMat_Hdr_clear(instance: *mut c_void) -> Result_void;
		pub fn cv_SparseMat_Node_hashval_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_SparseMat_Node_setHashval_size_t(instance: *mut c_void, val: size_t) -> Result_void;
		pub fn cv_SparseMat_Node_next_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_SparseMat_Node_setNext_size_t(instance: *mut c_void, val: size_t) -> Result_void;
		pub fn cv_SparseMat_Node_idx(instance: *mut c_void) -> Result<*mut [i32; 32]>;
		pub fn cv_SparseMatConstIterator_m_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_SparseMatConstIterator_hashidx_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_SparseMatConstIterator_setHashidx_size_t(instance: *mut c_void, val: size_t) -> Result_void;
		pub fn cv_SparseMatConstIterator_ptr(instance: *mut c_void) -> Result<*mut u8>;
		pub fn cv_SparseMatConstIterator_setPtr_unsigned_charX(instance: *mut c_void, val: *mut u8) -> Result_void;
		pub fn cv_SparseMatConstIterator_SparseMatConstIterator() -> Result<*mut c_void>;
		pub fn cv_SparseMatConstIterator_SparseMatConstIterator_const_SparseMatX(_m: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_SparseMatConstIterator_SparseMatConstIterator_const_SparseMatConstIteratorX(it: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_SparseMatConstIterator_node_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_SparseMatConstIterator_seekEnd(instance: *mut c_void) -> Result_void;
		pub fn cv_SparseMatIterator_SparseMatIterator() -> Result<*mut c_void>;
		pub fn cv_SparseMatIterator_SparseMatIterator_SparseMatX(_m: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_SparseMatIterator_SparseMatIterator_SparseMatX_const_intX(_m: *mut c_void, idx: *const i32) -> Result<*mut c_void>;
		pub fn cv_SparseMatIterator_SparseMatIterator_const_SparseMatIteratorX(it: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_SparseMatIterator_node_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_TLSDataContainer_cleanup(instance: *mut c_void) -> Result_void;
		pub fn cv_TermCriteria_type_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_TermCriteria_setType_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_TermCriteria_maxCount_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_TermCriteria_setMaxCount_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_TermCriteria_epsilon_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_TermCriteria_setEpsilon_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_TermCriteria_TermCriteria() -> Result<*mut c_void>;
		pub fn cv_TermCriteria_TermCriteria_int_int_double(typ: i32, max_count: i32, epsilon: f64) -> Result<*mut c_void>;
		pub fn cv_TermCriteria_isValid_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_TickMeter_TickMeter() -> Result<*mut c_void>;
		pub fn cv_TickMeter_start(instance: *mut c_void) -> Result_void;
		pub fn cv_TickMeter_stop(instance: *mut c_void) -> Result_void;
		pub fn cv_TickMeter_getTimeTicks_const(instance: *mut c_void) -> Result<i64>;
		pub fn cv_TickMeter_getTimeMicro_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_TickMeter_getTimeMilli_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_TickMeter_getTimeSec_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_TickMeter_getCounter_const(instance: *mut c_void) -> Result<i64>;
		pub fn cv_TickMeter_reset(instance: *mut c_void) -> Result_void;
		pub fn cv_UMat_flags_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_UMat_setFlags_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_UMat_dims_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_UMat_setDims_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_UMat_rows_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_UMat_setRows_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_UMat_cols_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_UMat_setCols_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_UMat_usageFlags_const(instance: *mut c_void) -> Result<core::UMatUsageFlags>;
		pub fn cv_UMat_setUsageFlags_UMatUsageFlags(instance: *mut c_void, val: core::UMatUsageFlags) -> Result_void;
		pub fn cv_UMat_u(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_UMat_setU_UMatDataX(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_UMat_offset_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_UMat_setOffset_size_t(instance: *mut c_void, val: size_t) -> Result_void;
		pub fn cv_UMat_size_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_UMat_step_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_UMat_UMat_UMatUsageFlags(usage_flags: core::UMatUsageFlags) -> Result<*mut c_void>;
		pub fn cv_UMat_UMat_int_int_int_UMatUsageFlags(rows: i32, cols: i32, typ: i32, usage_flags: core::UMatUsageFlags) -> Result<*mut c_void>;
		pub fn cv_UMat_UMat_Size_int_UMatUsageFlags(size: *const core::Size, typ: i32, usage_flags: core::UMatUsageFlags) -> Result<*mut c_void>;
		pub fn cv_UMat_UMat_int_int_int_const_ScalarX_UMatUsageFlags(rows: i32, cols: i32, typ: i32, s: *const core::Scalar, usage_flags: core::UMatUsageFlags) -> Result<*mut c_void>;
		pub fn cv_UMat_UMat_Size_int_const_ScalarX_UMatUsageFlags(size: *const core::Size, typ: i32, s: *const core::Scalar, usage_flags: core::UMatUsageFlags) -> Result<*mut c_void>;
		pub fn cv_UMat_UMat_int_const_intX_int_UMatUsageFlags(ndims: i32, sizes: *const i32, typ: i32, usage_flags: core::UMatUsageFlags) -> Result<*mut c_void>;
		pub fn cv_UMat_UMat_int_const_intX_int_const_ScalarX_UMatUsageFlags(ndims: i32, sizes: *const i32, typ: i32, s: *const core::Scalar, usage_flags: core::UMatUsageFlags) -> Result<*mut c_void>;
		pub fn cv_UMat_UMat_const_UMatX(m: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_UMat_UMat_const_UMatX_const_RangeX_const_RangeX(m: *mut c_void, row_range: *mut c_void, col_range: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_UMat_UMat_const_UMatX_const_RectX(m: *mut c_void, roi: *const core::Rect) -> Result<*mut c_void>;
		pub fn cv_UMat_UMat_const_UMatX_const_vector_Range_X(m: *mut c_void, ranges: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_UMat_getMat_const_AccessFlag(instance: *mut c_void, flags: core::AccessFlag) -> Result<*mut c_void>;
		pub fn cv_UMat_row_const_int(instance: *mut c_void, y: i32) -> Result<*mut c_void>;
		pub fn cv_UMat_col_const_int(instance: *mut c_void, x: i32) -> Result<*mut c_void>;
		pub fn cv_UMat_rowRange_const_int_int(instance: *mut c_void, startrow: i32, endrow: i32) -> Result<*mut c_void>;
		pub fn cv_UMat_rowRange_const_const_RangeX(instance: *mut c_void, r: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_UMat_colRange_const_int_int(instance: *mut c_void, startcol: i32, endcol: i32) -> Result<*mut c_void>;
		pub fn cv_UMat_colRange_const_const_RangeX(instance: *mut c_void, r: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_UMat_diag_const_int(instance: *mut c_void, d: i32) -> Result<*mut c_void>;
		pub fn cv_UMat_diag_const_UMatX(d: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_UMat_clone_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_UMat_copyTo_const_const__OutputArrayX(instance: *mut c_void, m: *mut c_void) -> Result_void;
		pub fn cv_UMat_copyTo_const_const__OutputArrayX_const__InputArrayX(instance: *mut c_void, m: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_UMat_convertTo_const_const__OutputArrayX_int_double_double(instance: *mut c_void, m: *mut c_void, rtype: i32, alpha: f64, beta: f64) -> Result_void;
		pub fn cv_UMat_assignTo_const_UMatX_int(instance: *mut c_void, m: *mut c_void, typ: i32) -> Result_void;
		pub fn cv_UMat_setTo_const__InputArrayX_const__InputArrayX(instance: *mut c_void, value: *mut c_void, mask: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_UMat_reshape_const_int_int(instance: *mut c_void, cn: i32, rows: i32) -> Result<*mut c_void>;
		pub fn cv_UMat_reshape_const_int_int_const_intX(instance: *mut c_void, cn: i32, newndims: i32, newsz: *const i32) -> Result<*mut c_void>;
		pub fn cv_UMat_t_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_UMat_inv_const_int(instance: *mut c_void, method: i32) -> Result<*mut c_void>;
		pub fn cv_UMat_mul_const_const__InputArrayX_double(instance: *mut c_void, m: *mut c_void, scale: f64) -> Result<*mut c_void>;
		pub fn cv_UMat_dot_const_const__InputArrayX(instance: *mut c_void, m: *mut c_void) -> Result<f64>;
		pub fn cv_UMat_zeros_int_int_int(rows: i32, cols: i32, typ: i32) -> Result<*mut c_void>;
		pub fn cv_UMat_zeros_Size_int(size: *const core::Size, typ: i32) -> Result<*mut c_void>;
		pub fn cv_UMat_zeros_int_const_intX_int(ndims: i32, sz: *const i32, typ: i32) -> Result<*mut c_void>;
		pub fn cv_UMat_ones_int_int_int(rows: i32, cols: i32, typ: i32) -> Result<*mut c_void>;
		pub fn cv_UMat_ones_Size_int(size: *const core::Size, typ: i32) -> Result<*mut c_void>;
		pub fn cv_UMat_ones_int_const_intX_int(ndims: i32, sz: *const i32, typ: i32) -> Result<*mut c_void>;
		pub fn cv_UMat_eye_int_int_int(rows: i32, cols: i32, typ: i32) -> Result<*mut c_void>;
		pub fn cv_UMat_eye_Size_int(size: *const core::Size, typ: i32) -> Result<*mut c_void>;
		pub fn cv_UMat_create_int_int_int_UMatUsageFlags(instance: *mut c_void, rows: i32, cols: i32, typ: i32, usage_flags: core::UMatUsageFlags) -> Result_void;
		pub fn cv_UMat_create_Size_int_UMatUsageFlags(instance: *mut c_void, size: *const core::Size, typ: i32, usage_flags: core::UMatUsageFlags) -> Result_void;
		pub fn cv_UMat_create_int_const_intX_int_UMatUsageFlags(instance: *mut c_void, ndims: i32, sizes: *const i32, typ: i32, usage_flags: core::UMatUsageFlags) -> Result_void;
		pub fn cv_UMat_create_const_vector_int_X_int_UMatUsageFlags(instance: *mut c_void, sizes: *mut c_void, typ: i32, usage_flags: core::UMatUsageFlags) -> Result_void;
		pub fn cv_UMat_addref(instance: *mut c_void) -> Result_void;
		pub fn cv_UMat_release(instance: *mut c_void) -> Result_void;
		pub fn cv_UMat_deallocate(instance: *mut c_void) -> Result_void;
		pub fn cv_UMat_locateROI_const_SizeX_PointX(instance: *mut c_void, whole_size: *mut core::Size, ofs: *mut core::Point) -> Result_void;
		pub fn cv_UMat_adjustROI_int_int_int_int(instance: *mut c_void, dtop: i32, dbottom: i32, dleft: i32, dright: i32) -> Result<*mut c_void>;
		pub fn cv_UMat_isContinuous_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_UMat_isSubmatrix_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_UMat_elemSize_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_UMat_elemSize1_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_UMat_type_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_UMat_depth_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_UMat_channels_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_UMat_step1_const_int(instance: *mut c_void, i: i32) -> Result<size_t>;
		pub fn cv_UMat_empty_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_UMat_total_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_UMat_checkVector_const_int_int_bool(instance: *mut c_void, elem_channels: i32, depth: i32, require_continuous: bool) -> Result<i32>;
		pub fn cv_UMat_UMat_UMatX(m: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_UMat_handle_const_AccessFlag(instance: *mut c_void, access_flags: core::AccessFlag) -> Result<*mut c_void>;
		pub fn cv_UMat_ndoffset_const_size_tX(instance: *mut c_void, ofs: *mut size_t) -> Result_void;
		pub fn cv_UMat_updateContinuityFlag(instance: *mut c_void) -> Result_void;
		pub fn cv_UMatData_urefcount_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_UMatData_setUrefcount_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_UMatData_refcount_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_UMatData_setRefcount_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_UMatData_data(instance: *mut c_void) -> Result<*mut u8>;
		pub fn cv_UMatData_setData_unsigned_charX(instance: *mut c_void, val: *mut u8) -> Result_void;
		pub fn cv_UMatData_origdata(instance: *mut c_void) -> Result<*mut u8>;
		pub fn cv_UMatData_setOrigdata_unsigned_charX(instance: *mut c_void, val: *mut u8) -> Result_void;
		pub fn cv_UMatData_size_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_UMatData_setSize_size_t(instance: *mut c_void, val: size_t) -> Result_void;
		pub fn cv_UMatData_flags_const(instance: *mut c_void) -> Result<core::UMatData_MemoryFlag>;
		pub fn cv_UMatData_setFlags_MemoryFlag(instance: *mut c_void, val: core::UMatData_MemoryFlag) -> Result_void;
		pub fn cv_UMatData_handle(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_UMatData_setHandle_voidX(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_UMatData_userdata(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_UMatData_setUserdata_voidX(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_UMatData_allocatorFlags__const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_UMatData_setAllocatorFlags__int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_UMatData_mapcount_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_UMatData_setMapcount_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_UMatData_originalUMatData(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_UMatData_setOriginalUMatData_UMatDataX(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_UMatData_lock(instance: *mut c_void) -> Result_void;
		pub fn cv_UMatData_unlock(instance: *mut c_void) -> Result_void;
		pub fn cv_UMatData_hostCopyObsolete_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_UMatData_deviceCopyObsolete_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_UMatData_deviceMemMapped_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_UMatData_copyOnMap_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_UMatData_tempUMat_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_UMatData_tempCopiedUMat_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_UMatData_markHostCopyObsolete_bool(instance: *mut c_void, flag: bool) -> Result_void;
		pub fn cv_UMatData_markDeviceCopyObsolete_bool(instance: *mut c_void, flag: bool) -> Result_void;
		pub fn cv_UMatData_markDeviceMemMapped_bool(instance: *mut c_void, flag: bool) -> Result_void;
		pub fn cv__InputArray__InputArray() -> Result<*mut c_void>;
		pub fn cv__InputArray__InputArray_int_voidX(_flags: i32, _obj: *mut c_void) -> Result<*mut c_void>;
		pub fn cv__InputArray__InputArray_const_MatX(m: *mut c_void) -> Result<*mut c_void>;
		pub fn cv__InputArray__InputArray_const_MatExprX(expr: *mut c_void) -> Result<*mut c_void>;
		pub fn cv__InputArray__InputArray_const_vector_Mat_X(vec: *mut c_void) -> Result<*mut c_void>;
		pub fn cv__InputArray__InputArray_const_vector_bool_X(vec: *mut c_void) -> Result<*mut c_void>;
		pub fn cv__InputArray__InputArray_const_doubleX(val: *const f64) -> Result<*mut c_void>;
		pub fn cv__InputArray__InputArray_const_UMatX(um: *mut c_void) -> Result<*mut c_void>;
		pub fn cv__InputArray__InputArray_const_vector_UMat_X(umv: *mut c_void) -> Result<*mut c_void>;
		pub fn cv__InputArray_getMat_const_int(instance: *mut c_void, idx: i32) -> Result<*mut c_void>;
		pub fn cv__InputArray_getMat__const_int(instance: *mut c_void, idx: i32) -> Result<*mut c_void>;
		pub fn cv__InputArray_getUMat_const_int(instance: *mut c_void, idx: i32) -> Result<*mut c_void>;
		pub fn cv__InputArray_getMatVector_const_vector_Mat_X(instance: *mut c_void, mv: *mut c_void) -> Result_void;
		pub fn cv__InputArray_getUMatVector_const_vector_UMat_X(instance: *mut c_void, umv: *mut c_void) -> Result_void;
		pub fn cv__InputArray_getFlags_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv__InputArray_getObj_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv__InputArray_getSz_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv__InputArray_kind_const(instance: *mut c_void) -> Result<core::_InputArray_KindFlag>;
		pub fn cv__InputArray_dims_const_int(instance: *mut c_void, i: i32) -> Result<i32>;
		pub fn cv__InputArray_cols_const_int(instance: *mut c_void, i: i32) -> Result<i32>;
		pub fn cv__InputArray_rows_const_int(instance: *mut c_void, i: i32) -> Result<i32>;
		pub fn cv__InputArray_size_const_int(instance: *mut c_void, i: i32) -> Result<core::Size>;
		pub fn cv__InputArray_sizend_const_intX_int(instance: *mut c_void, sz: *mut i32, i: i32) -> Result<i32>;
		pub fn cv__InputArray_sameSize_const_const__InputArrayX(instance: *mut c_void, arr: *mut c_void) -> Result<bool>;
		pub fn cv__InputArray_total_const_int(instance: *mut c_void, i: i32) -> Result<size_t>;
		pub fn cv__InputArray_type_const_int(instance: *mut c_void, i: i32) -> Result<i32>;
		pub fn cv__InputArray_depth_const_int(instance: *mut c_void, i: i32) -> Result<i32>;
		pub fn cv__InputArray_channels_const_int(instance: *mut c_void, i: i32) -> Result<i32>;
		pub fn cv__InputArray_isContinuous_const_int(instance: *mut c_void, i: i32) -> Result<bool>;
		pub fn cv__InputArray_isSubmatrix_const_int(instance: *mut c_void, i: i32) -> Result<bool>;
		pub fn cv__InputArray_empty_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv__InputArray_copyTo_const_const__OutputArrayX(instance: *mut c_void, arr: *mut c_void) -> Result_void;
		pub fn cv__InputArray_copyTo_const_const__OutputArrayX_const__InputArrayX(instance: *mut c_void, arr: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv__InputArray_offset_const_int(instance: *mut c_void, i: i32) -> Result<size_t>;
		pub fn cv__InputArray_step_const_int(instance: *mut c_void, i: i32) -> Result<size_t>;
		pub fn cv__InputArray_isMat_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv__InputArray_isUMat_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv__InputArray_isMatVector_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv__InputArray_isUMatVector_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv__InputArray_isMatx_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv__InputArray_isVector_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv__InputArray_isGpuMat_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv__InputArray_isGpuMatVector_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv__InputOutputArray__InputOutputArray() -> Result<*mut c_void>;
		pub fn cv__InputOutputArray__InputOutputArray_int_voidX(_flags: i32, _obj: *mut c_void) -> Result<*mut c_void>;
		pub fn cv__InputOutputArray__InputOutputArray_MatX(m: *mut c_void) -> Result<*mut c_void>;
		pub fn cv__InputOutputArray__InputOutputArray_vector_Mat_X(vec: *mut c_void) -> Result<*mut c_void>;
		pub fn cv__InputOutputArray__InputOutputArray_UMatX(m: *mut c_void) -> Result<*mut c_void>;
		pub fn cv__InputOutputArray__InputOutputArray_vector_UMat_X(vec: *mut c_void) -> Result<*mut c_void>;
		pub fn cv__InputOutputArray__InputOutputArray_const_MatX(m: *mut c_void) -> Result<*mut c_void>;
		pub fn cv__InputOutputArray__InputOutputArray_const_vector_Mat_X(vec: *mut c_void) -> Result<*mut c_void>;
		pub fn cv__InputOutputArray__InputOutputArray_const_UMatX(m: *mut c_void) -> Result<*mut c_void>;
		pub fn cv__InputOutputArray__InputOutputArray_const_vector_UMat_X(vec: *mut c_void) -> Result<*mut c_void>;
		pub fn cv__OutputArray__OutputArray() -> Result<*mut c_void>;
		pub fn cv__OutputArray__OutputArray_int_voidX(_flags: i32, _obj: *mut c_void) -> Result<*mut c_void>;
		pub fn cv__OutputArray__OutputArray_MatX(m: *mut c_void) -> Result<*mut c_void>;
		pub fn cv__OutputArray__OutputArray_vector_Mat_X(vec: *mut c_void) -> Result<*mut c_void>;
		pub fn cv__OutputArray__OutputArray_UMatX(m: *mut c_void) -> Result<*mut c_void>;
		pub fn cv__OutputArray__OutputArray_vector_UMat_X(vec: *mut c_void) -> Result<*mut c_void>;
		pub fn cv__OutputArray__OutputArray_const_MatX(m: *mut c_void) -> Result<*mut c_void>;
		pub fn cv__OutputArray__OutputArray_const_vector_Mat_X(vec: *mut c_void) -> Result<*mut c_void>;
		pub fn cv__OutputArray__OutputArray_const_UMatX(m: *mut c_void) -> Result<*mut c_void>;
		pub fn cv__OutputArray__OutputArray_const_vector_UMat_X(vec: *mut c_void) -> Result<*mut c_void>;
		pub fn cv__OutputArray_fixedSize_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv__OutputArray_fixedType_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv__OutputArray_needed_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv__OutputArray_getMatRef_const_int(instance: *mut c_void, i: i32) -> Result<*mut c_void>;
		pub fn cv__OutputArray_getUMatRef_const_int(instance: *mut c_void, i: i32) -> Result<*mut c_void>;
		pub fn cv__OutputArray_create_const_Size_int_int_bool_DepthMask(instance: *mut c_void, sz: *const core::Size, typ: i32, i: i32, allow_transposed: bool, fixed_depth_mask: core::_OutputArray_DepthMask) -> Result_void;
		pub fn cv__OutputArray_create_const_int_int_int_int_bool_DepthMask(instance: *mut c_void, rows: i32, cols: i32, typ: i32, i: i32, allow_transposed: bool, fixed_depth_mask: core::_OutputArray_DepthMask) -> Result_void;
		pub fn cv__OutputArray_create_const_int_const_intX_int_int_bool_DepthMask(instance: *mut c_void, dims: i32, size: *const i32, typ: i32, i: i32, allow_transposed: bool, fixed_depth_mask: core::_OutputArray_DepthMask) -> Result_void;
		pub fn cv__OutputArray_createSameSize_const_const__InputArrayX_int(instance: *mut c_void, arr: *mut c_void, mtype: i32) -> Result_void;
		pub fn cv__OutputArray_release_const(instance: *mut c_void) -> Result_void;
		pub fn cv__OutputArray_clear_const(instance: *mut c_void) -> Result_void;
		pub fn cv__OutputArray_setTo_const_const__InputArrayX_const__InputArrayX(instance: *mut c_void, value: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv__OutputArray_assign_const_const_UMatX(instance: *mut c_void, u: *mut c_void) -> Result_void;
		pub fn cv__OutputArray_assign_const_const_MatX(instance: *mut c_void, m: *mut c_void) -> Result_void;
		pub fn cv__OutputArray_assign_const_const_vector_UMat_X(instance: *mut c_void, v: *mut c_void) -> Result_void;
		pub fn cv__OutputArray_assign_const_const_vector_Mat_X(instance: *mut c_void, v: *mut c_void) -> Result_void;
		pub fn cv__OutputArray_move_const_UMatX(instance: *mut c_void, u: *mut c_void) -> Result_void;
		pub fn cv__OutputArray_move_const_MatX(instance: *mut c_void, m: *mut c_void) -> Result_void;
		pub fn cv_detail_CheckContext_func_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_detail_CheckContext_file_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_detail_CheckContext_line_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_detail_CheckContext_setLine_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_detail_CheckContext_testOp_const(instance: *mut c_void) -> Result<core::Detail_TestOp>;
		pub fn cv_detail_CheckContext_setTestOp_TestOp(instance: *mut c_void, val: core::Detail_TestOp) -> Result_void;
		pub fn cv_detail_CheckContext_message_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_detail_CheckContext_p1_str_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_detail_CheckContext_p2_str_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_instr_NodeData_m_funName_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_instr_NodeData_setM_funName_String(instance: *mut c_void, val: *mut c_char) -> Result_void;
		pub fn cv_instr_NodeData_m_instrType_const(instance: *mut c_void) -> Result<core::TYPE>;
		pub fn cv_instr_NodeData_setM_instrType_TYPE(instance: *mut c_void, val: core::TYPE) -> Result_void;
		pub fn cv_instr_NodeData_m_implType_const(instance: *mut c_void) -> Result<core::IMPL>;
		pub fn cv_instr_NodeData_setM_implType_IMPL(instance: *mut c_void, val: core::IMPL) -> Result_void;
		pub fn cv_instr_NodeData_m_fileName_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_instr_NodeData_m_lineNum_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_instr_NodeData_setM_lineNum_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_instr_NodeData_m_retAddress(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_instr_NodeData_setM_retAddress_voidX(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_instr_NodeData_m_alwaysExpand_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_instr_NodeData_setM_alwaysExpand_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_instr_NodeData_m_funError_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_instr_NodeData_setM_funError_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_instr_NodeData_m_counter_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_instr_NodeData_setM_counter_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_instr_NodeData_m_ticksTotal_const(instance: *mut c_void) -> Result<u64>;
		pub fn cv_instr_NodeData_setM_ticksTotal_uint64_t(instance: *mut c_void, val: u64) -> Result_void;
		pub fn cv_instr_NodeData_m_threads_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_instr_NodeData_setM_threads_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_instr_NodeData_NodeData_const_charX_const_charX_int_voidX_bool_TYPE_IMPL(fun_name: *const c_char, file_name: *const c_char, line_num: i32, ret_address: *mut c_void, always_expand: bool, instr_type: core::TYPE, impl_type: core::IMPL) -> Result<*mut c_void>;
		pub fn cv_instr_NodeData_NodeData_NodeDataX(ref_: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_instr_NodeData_getTotalMs_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_instr_NodeData_getMeanMs_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_internal_WriteStructContext_WriteStructContext_FileStorageX_const_StringX_int_const_StringX(_fs: *mut c_void, name: *const c_char, flags: i32, type_name: *const c_char) -> Result<*mut c_void>;
		pub fn cv_ocl_Context_Context() -> Result<*mut c_void>;
		pub fn cv_ocl_Context_Context_int(dtype: i32) -> Result<*mut c_void>;
		pub fn cv_ocl_Context_Context_const_ContextX(c: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Context_create(instance: *mut c_void) -> Result<bool>;
		pub fn cv_ocl_Context_create_int(instance: *mut c_void, dtype: i32) -> Result<bool>;
		pub fn cv_ocl_Context_ndevices_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_ocl_Context_device_const_size_t(instance: *mut c_void, idx: size_t) -> Result<*mut c_void>;
		pub fn cv_ocl_Context_getProg_const_ProgramSourceX_const_StringX_StringX(instance: *mut c_void, prog: *mut c_void, buildopt: *const c_char, errmsg: *mut *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Context_unloadProg_ProgramX(instance: *mut c_void, prog: *mut c_void) -> Result_void;
		pub fn cv_ocl_Context_getDefault_bool(initialize: bool) -> Result<*mut c_void>;
		pub fn cv_ocl_Context_ptr_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Context_useSVM_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_ocl_Context_setUseSVM_bool(instance: *mut c_void, enabled: bool) -> Result_void;
		pub fn cv_ocl_Device_Device() -> Result<*mut c_void>;
		pub fn cv_ocl_Device_Device_voidX(d: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Device_Device_const_DeviceX(d: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Device_set_voidX(instance: *mut c_void, d: *mut c_void) -> Result_void;
		pub fn cv_ocl_Device_name_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Device_extensions_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Device_isExtensionSupported_const_const_StringX(instance: *mut c_void, extension_name: *const c_char) -> Result<bool>;
		pub fn cv_ocl_Device_version_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Device_vendorName_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Device_OpenCL_C_Version_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Device_OpenCLVersion_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Device_deviceVersionMajor_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_deviceVersionMinor_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_driverVersion_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Device_ptr_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Device_type_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_addressBits_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_available_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_ocl_Device_compilerAvailable_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_ocl_Device_linkerAvailable_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_ocl_Device_doubleFPConfig_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_singleFPConfig_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_halfFPConfig_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_endianLittle_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_ocl_Device_errorCorrectionSupport_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_ocl_Device_executionCapabilities_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_globalMemCacheSize_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_ocl_Device_globalMemCacheType_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_globalMemCacheLineSize_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_globalMemSize_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_ocl_Device_localMemSize_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_ocl_Device_localMemType_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_hostUnifiedMemory_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_ocl_Device_imageSupport_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_ocl_Device_imageFromBufferSupport_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_ocl_Device_imagePitchAlignment_const(instance: *mut c_void) -> Result<u32>;
		pub fn cv_ocl_Device_imageBaseAddressAlignment_const(instance: *mut c_void) -> Result<u32>;
		pub fn cv_ocl_Device_intelSubgroupsSupport_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_ocl_Device_image2DMaxWidth_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_ocl_Device_image2DMaxHeight_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_ocl_Device_image3DMaxWidth_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_ocl_Device_image3DMaxHeight_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_ocl_Device_image3DMaxDepth_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_ocl_Device_imageMaxBufferSize_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_ocl_Device_imageMaxArraySize_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_ocl_Device_vendorID_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_isAMD_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_ocl_Device_isIntel_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_ocl_Device_isNVidia_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_ocl_Device_maxClockFrequency_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_maxComputeUnits_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_maxConstantArgs_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_maxConstantBufferSize_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_ocl_Device_maxMemAllocSize_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_ocl_Device_maxParameterSize_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_ocl_Device_maxReadImageArgs_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_maxWriteImageArgs_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_maxSamplers_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_maxWorkGroupSize_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_ocl_Device_maxWorkItemDims_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_maxWorkItemSizes_const_size_tX(instance: *mut c_void, unnamed: *mut size_t) -> Result_void;
		pub fn cv_ocl_Device_memBaseAddrAlign_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_nativeVectorWidthChar_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_nativeVectorWidthShort_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_nativeVectorWidthInt_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_nativeVectorWidthLong_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_nativeVectorWidthFloat_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_nativeVectorWidthDouble_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_nativeVectorWidthHalf_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_preferredVectorWidthChar_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_preferredVectorWidthShort_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_preferredVectorWidthInt_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_preferredVectorWidthLong_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_preferredVectorWidthFloat_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_preferredVectorWidthDouble_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_preferredVectorWidthHalf_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Device_printfBufferSize_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_ocl_Device_profilingTimerResolution_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_ocl_Device_getDefault() -> Result<*mut c_void>;
		pub fn cv_ocl_Image2D_Image2D() -> Result<*mut c_void>;
		pub fn cv_ocl_Image2D_Image2D_const_UMatX_bool_bool(src: *mut c_void, norm: bool, alias: bool) -> Result<*mut c_void>;
		pub fn cv_ocl_Image2D_Image2D_const_Image2DX(i: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Image2D_canCreateAlias_const_UMatX(u: *mut c_void) -> Result<bool>;
		pub fn cv_ocl_Image2D_isFormatSupported_int_int_bool(depth: i32, cn: i32, norm: bool) -> Result<bool>;
		pub fn cv_ocl_Image2D_ptr_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Kernel_Kernel() -> Result<*mut c_void>;
		pub fn cv_ocl_Kernel_Kernel_const_charX_const_ProgramX(kname: *const c_char, prog: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Kernel_Kernel_const_charX_const_ProgramSourceX_const_StringX_StringX(kname: *const c_char, prog: *mut c_void, buildopts: *const c_char, errmsg: *mut *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Kernel_Kernel_const_KernelX(k: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Kernel_empty_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_ocl_Kernel_create_const_charX_const_ProgramX(instance: *mut c_void, kname: *const c_char, prog: *mut c_void) -> Result<bool>;
		pub fn cv_ocl_Kernel_create_const_charX_const_ProgramSourceX_const_StringX_StringX(instance: *mut c_void, kname: *const c_char, prog: *mut c_void, buildopts: *const c_char, errmsg: *mut *mut c_void) -> Result<bool>;
		pub fn cv_ocl_Kernel_set_int_const_voidX_size_t(instance: *mut c_void, i: i32, value: *const c_void, sz: size_t) -> Result<i32>;
		pub fn cv_ocl_Kernel_set_int_const_Image2DX(instance: *mut c_void, i: i32, image_2d: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Kernel_set_int_const_UMatX(instance: *mut c_void, i: i32, m: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Kernel_set_int_const_KernelArgX(instance: *mut c_void, i: i32, arg: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_Kernel_run_int_size_tX_size_tX_bool_const_QueueX(instance: *mut c_void, dims: i32, globalsize: *mut size_t, localsize: *mut size_t, sync: bool, q: *mut c_void) -> Result<bool>;
		pub fn cv_ocl_Kernel_runTask_bool_const_QueueX(instance: *mut c_void, sync: bool, q: *mut c_void) -> Result<bool>;
		pub fn cv_ocl_Kernel_runProfiling_int_size_tX_size_tX_const_QueueX(instance: *mut c_void, dims: i32, globalsize: *mut size_t, localsize: *mut size_t, q: *mut c_void) -> Result<i64>;
		pub fn cv_ocl_Kernel_workGroupSize_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_ocl_Kernel_preferedWorkGroupSizeMultiple_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_ocl_Kernel_compileWorkGroupSize_const_size_tX(instance: *mut c_void, wsz: *mut size_t) -> Result<bool>;
		pub fn cv_ocl_Kernel_localMemSize_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_ocl_Kernel_ptr_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_KernelArg_flags_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_KernelArg_setFlags_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ocl_KernelArg_m(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_KernelArg_setM_UMatX(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_ocl_KernelArg_obj_const(instance: *mut c_void) -> Result<*const c_void>;
		pub fn cv_ocl_KernelArg_sz_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_ocl_KernelArg_setSz_size_t(instance: *mut c_void, val: size_t) -> Result_void;
		pub fn cv_ocl_KernelArg_wscale_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_KernelArg_setWscale_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ocl_KernelArg_iwscale_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_KernelArg_setIwscale_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ocl_KernelArg_KernelArg_int_UMatX_int_int_const_voidX_size_t(_flags: i32, _m: *mut c_void, wscale: i32, iwscale: i32, _obj: *const c_void, _sz: size_t) -> Result<*mut c_void>;
		pub fn cv_ocl_KernelArg_KernelArg() -> Result<*mut c_void>;
		pub fn cv_ocl_KernelArg_Local_size_t(local_mem_size: size_t) -> Result<*mut c_void>;
		pub fn cv_ocl_KernelArg_PtrWriteOnly_const_UMatX(m: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_KernelArg_PtrReadOnly_const_UMatX(m: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_KernelArg_PtrReadWrite_const_UMatX(m: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_KernelArg_ReadWrite_const_UMatX_int_int(m: *mut c_void, wscale: i32, iwscale: i32) -> Result<*mut c_void>;
		pub fn cv_ocl_KernelArg_ReadWriteNoSize_const_UMatX_int_int(m: *mut c_void, wscale: i32, iwscale: i32) -> Result<*mut c_void>;
		pub fn cv_ocl_KernelArg_ReadOnly_const_UMatX_int_int(m: *mut c_void, wscale: i32, iwscale: i32) -> Result<*mut c_void>;
		pub fn cv_ocl_KernelArg_WriteOnly_const_UMatX_int_int(m: *mut c_void, wscale: i32, iwscale: i32) -> Result<*mut c_void>;
		pub fn cv_ocl_KernelArg_ReadOnlyNoSize_const_UMatX_int_int(m: *mut c_void, wscale: i32, iwscale: i32) -> Result<*mut c_void>;
		pub fn cv_ocl_KernelArg_WriteOnlyNoSize_const_UMatX_int_int(m: *mut c_void, wscale: i32, iwscale: i32) -> Result<*mut c_void>;
		pub fn cv_ocl_KernelArg_Constant_const_MatX(m: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Platform_Platform() -> Result<*mut c_void>;
		pub fn cv_ocl_Platform_Platform_const_PlatformX(p: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Platform_ptr_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Platform_getDefault() -> Result<*mut c_void>;
		pub fn cv_ocl_PlatformInfo_PlatformInfo() -> Result<*mut c_void>;
		pub fn cv_ocl_PlatformInfo_PlatformInfo_voidX(id: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_PlatformInfo_PlatformInfo_const_PlatformInfoX(i: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_PlatformInfo_name_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_PlatformInfo_vendor_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_PlatformInfo_version_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_PlatformInfo_deviceNumber_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ocl_PlatformInfo_getDevice_const_DeviceX_int(instance: *mut c_void, device: *mut c_void, d: i32) -> Result_void;
		pub fn cv_ocl_Program_Program() -> Result<*mut c_void>;
		pub fn cv_ocl_Program_Program_const_ProgramSourceX_const_StringX_StringX(src: *mut c_void, buildflags: *const c_char, errmsg: *mut *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Program_Program_const_ProgramX(prog: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Program_create_const_ProgramSourceX_const_StringX_StringX(instance: *mut c_void, src: *mut c_void, buildflags: *const c_char, errmsg: *mut *mut c_void) -> Result<bool>;
		pub fn cv_ocl_Program_ptr_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Program_getBinary_const_vector_char_X(instance: *mut c_void, binary: *mut c_void) -> Result_void;
		pub fn cv_ocl_Program_read_const_StringX_const_StringX(instance: *mut c_void, buf: *const c_char, buildflags: *const c_char) -> Result<bool>;
		pub fn cv_ocl_Program_write_const_StringX(instance: *mut c_void, buf: *mut *mut c_void) -> Result<bool>;
		pub fn cv_ocl_Program_source_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Program_getPrefix_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Program_getPrefix_const_StringX(buildflags: *const c_char) -> Result<*mut c_void>;
		pub fn cv_ocl_ProgramSource_ProgramSource() -> Result<*mut c_void>;
		pub fn cv_ocl_ProgramSource_ProgramSource_const_StringX_const_StringX_const_StringX_const_StringX(module: *const c_char, name: *const c_char, code_str: *const c_char, code_hash: *const c_char) -> Result<*mut c_void>;
		pub fn cv_ocl_ProgramSource_ProgramSource_const_StringX(prog: *const c_char) -> Result<*mut c_void>;
		pub fn cv_ocl_ProgramSource_ProgramSource_const_ProgramSourceX(prog: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_ProgramSource_source_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_ProgramSource_hash_const(instance: *mut c_void) -> Result<core::ProgramSource_hash_t>;
		pub fn cv_ocl_ProgramSource_fromBinary_const_StringX_const_StringX_const_unsigned_charX_size_t_const_StringX(module: *const c_char, name: *const c_char, binary: *const u8, size: size_t, build_options: *const c_char) -> Result<*mut c_void>;
		pub fn cv_ocl_ProgramSource_fromSPIR_const_StringX_const_StringX_const_unsigned_charX_size_t_const_StringX(module: *const c_char, name: *const c_char, binary: *const u8, size: size_t, build_options: *const c_char) -> Result<*mut c_void>;
		pub fn cv_ocl_Queue_Queue() -> Result<*mut c_void>;
		pub fn cv_ocl_Queue_Queue_const_ContextX_const_DeviceX(c: *mut c_void, d: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Queue_Queue_const_QueueX(q: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Queue_create_const_ContextX_const_DeviceX(instance: *mut c_void, c: *mut c_void, d: *mut c_void) -> Result<bool>;
		pub fn cv_ocl_Queue_finish(instance: *mut c_void) -> Result_void;
		pub fn cv_ocl_Queue_ptr_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Queue_getDefault() -> Result<*mut c_void>;
		pub fn cv_ocl_Queue_getProfilingQueue_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Timer_Timer_const_QueueX(q: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ocl_Timer_start(instance: *mut c_void) -> Result_void;
		pub fn cv_ocl_Timer_stop(instance: *mut c_void) -> Result_void;
		pub fn cv_ocl_Timer_durationNS_const(instance: *mut c_void) -> Result<u64>;
		pub fn cv_utils_logging_LogTag_name_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_utils_logging_LogTag_level_const(instance: *mut c_void) -> Result<core::LogLevel>;
		pub fn cv_utils_logging_LogTag_setLevel_LogLevel(instance: *mut c_void, val: core::LogLevel) -> Result_void;
		pub fn cv_utils_logging_LogTag_LogTag_const_charX_LogLevel(_name: *const c_char, _level: core::LogLevel) -> Result<*mut c_void>;
	}
}
pub use core_sys::*;

#[cfg(feature = "contrib")]
mod cvv_sys {
	use super::*;

	extern "C" {
		pub fn cvv_impl_debugDMatch_const__InputArrayX_vector_KeyPoint__const__InputArrayX_vector_KeyPoint__vector_DMatch__const_CallMetaDataX_const_charX_const_charX_bool(img1: *mut c_void, keypoints1: *mut c_void, img2: *mut c_void, keypoints2: *mut c_void, matches: *mut c_void, data: *mut c_void, description: *const c_char, view: *const c_char, use_train_descriptor: bool) -> Result_void;
		pub fn cvv_impl_debugFilter_const__InputArrayX_const__InputArrayX_const_CallMetaDataX_const_charX_const_charX(original: *mut c_void, result: *mut c_void, data: *mut c_void, description: *const c_char, view: *const c_char) -> Result_void;
		pub fn cvv_impl_finalShow() -> Result_void;
		pub fn cvv_impl_showImage_const__InputArrayX_const_CallMetaDataX_const_charX_const_charX(img: *mut c_void, data: *mut c_void, description: *const c_char, view: *const c_char) -> Result_void;
		pub fn cvv_impl_CallMetaData_file_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cvv_impl_CallMetaData_line_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cvv_impl_CallMetaData_function_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cvv_impl_CallMetaData_isKnown_const(instance: *mut c_void) -> Result<bool>;
		pub fn cvv_impl_CallMetaData_CallMetaData() -> Result<*mut c_void>;
		pub fn cvv_impl_CallMetaData_CallMetaData_const_charX_size_t_const_charX(file: *const c_char, line: size_t, function: *const c_char) -> Result<*mut c_void>;
		pub fn cvv_impl_CallMetaData_operator_bool(instance: *mut c_void) -> Result<bool>;
	}
}
#[cfg(feature = "contrib")]
pub use cvv_sys::*;

mod dnn_sys {
	use super::*;

	extern "C" {
		pub fn cv_dnn_NMSBoxes_const_vector_Rect2d_X_const_vector_float_X_float_float_vector_int_X_float_int(bboxes: *mut c_void, scores: *mut c_void, score_threshold: f32, nms_threshold: f32, indices: *mut c_void, eta: f32, top_k: i32) -> Result_void;
		pub fn cv_dnn_NMSBoxes_const_vector_Rect_X_const_vector_float_X_float_float_vector_int_X_float_int(bboxes: *mut c_void, scores: *mut c_void, score_threshold: f32, nms_threshold: f32, indices: *mut c_void, eta: f32, top_k: i32) -> Result_void;
		pub fn cv_dnn_NMSBoxes_const_vector_RotatedRect_X_const_vector_float_X_float_float_vector_int_X_float_int(bboxes: *mut c_void, scores: *mut c_void, score_threshold: f32, nms_threshold: f32, indices: *mut c_void, eta: f32, top_k: i32) -> Result_void;
		pub fn cv_dnn_blobFromImage_const__InputArrayX_const__OutputArrayX_double_const_SizeX_const_ScalarX_bool_bool_int(image: *mut c_void, blob: *mut c_void, scalefactor: f64, size: *const core::Size, mean: *const core::Scalar, swap_rb: bool, crop: bool, ddepth: i32) -> Result_void;
		pub fn cv_dnn_blobFromImage_const__InputArrayX_double_const_SizeX_const_ScalarX_bool_bool_int(image: *mut c_void, scalefactor: f64, size: *const core::Size, mean: *const core::Scalar, swap_rb: bool, crop: bool, ddepth: i32) -> Result<*mut c_void>;
		pub fn cv_dnn_blobFromImages_const__InputArrayX_const__OutputArrayX_double_Size_const_ScalarX_bool_bool_int(images: *mut c_void, blob: *mut c_void, scalefactor: f64, size: *const core::Size, mean: *const core::Scalar, swap_rb: bool, crop: bool, ddepth: i32) -> Result_void;
		pub fn cv_dnn_blobFromImages_const__InputArrayX_double_Size_const_ScalarX_bool_bool_int(images: *mut c_void, scalefactor: f64, size: *const core::Size, mean: *const core::Scalar, swap_rb: bool, crop: bool, ddepth: i32) -> Result<*mut c_void>;
		pub fn cv_dnn_clamp_const_RangeX_int(r: *mut c_void, axis_size: i32) -> Result<*mut c_void>;
		pub fn cv_dnn_clamp_int_const_MatShapeX(ax: i32, shape: *mut c_void) -> Result<i32>;
		pub fn cv_dnn_clamp_int_int(ax: i32, dims: i32) -> Result<i32>;
		pub fn cv_dnn_concat_const_MatShapeX_const_MatShapeX(a: *mut c_void, b: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_getAvailableTargets_Backend(be: crate::dnn::Backend) -> Result<*mut c_void>;
		pub fn cv_dnn_getInferenceEngineBackendType() -> Result<*mut c_void>;
		pub fn cv_dnn_getInferenceEngineVPUType() -> Result<*mut c_void>;
		pub fn cv_dnn_getPlane_const_MatX_int_int(m: *mut c_void, n: i32, cn: i32) -> Result<*mut c_void>;
		pub fn cv_dnn_imagesFromBlob_const_MatX_const__OutputArrayX(blob_: *mut c_void, images_: *mut c_void) -> Result_void;
		pub fn cv_dnn_print_const_MatShapeX_const_StringX(shape: *mut c_void, name: *const c_char) -> Result_void;
		pub fn cv_dnn_readNetFromCaffe_const_StringX_const_StringX(prototxt: *const c_char, caffe_model: *const c_char) -> Result<*mut c_void>;
		pub fn cv_dnn_readNetFromCaffe_const_charX_size_t_const_charX_size_t(buffer_proto: *const c_char, len_proto: size_t, buffer_model: *const c_char, len_model: size_t) -> Result<*mut c_void>;
		pub fn cv_dnn_readNetFromCaffe_const_vector_unsigned_char_X_const_vector_unsigned_char_X(buffer_proto: *mut c_void, buffer_model: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_readNetFromDarknet_const_StringX_const_StringX(cfg_file: *const c_char, darknet_model: *const c_char) -> Result<*mut c_void>;
		pub fn cv_dnn_readNetFromDarknet_const_charX_size_t_const_charX_size_t(buffer_cfg: *const c_char, len_cfg: size_t, buffer_model: *const c_char, len_model: size_t) -> Result<*mut c_void>;
		pub fn cv_dnn_readNetFromDarknet_const_vector_unsigned_char_X_const_vector_unsigned_char_X(buffer_cfg: *mut c_void, buffer_model: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_readNetFromModelOptimizer_const_StringX_const_StringX(xml: *const c_char, bin: *const c_char) -> Result<*mut c_void>;
		pub fn cv_dnn_readNetFromModelOptimizer_const_unsigned_charX_size_t_const_unsigned_charX_size_t(buffer_model_config_ptr: *const u8, buffer_model_config_size: size_t, buffer_weights_ptr: *const u8, buffer_weights_size: size_t) -> Result<*mut c_void>;
		pub fn cv_dnn_readNetFromModelOptimizer_const_vector_unsigned_char_X_const_vector_unsigned_char_X(buffer_model_config: *mut c_void, buffer_weights: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_readNetFromONNX_const_StringX(onnx_file: *const c_char) -> Result<*mut c_void>;
		pub fn cv_dnn_readNetFromONNX_const_charX_size_t(buffer: *const c_char, size_buffer: size_t) -> Result<*mut c_void>;
		pub fn cv_dnn_readNetFromONNX_const_vector_unsigned_char_X(buffer: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_readNetFromTensorflow_const_StringX_const_StringX(model: *const c_char, config: *const c_char) -> Result<*mut c_void>;
		pub fn cv_dnn_readNetFromTensorflow_const_charX_size_t_const_charX_size_t(buffer_model: *const c_char, len_model: size_t, buffer_config: *const c_char, len_config: size_t) -> Result<*mut c_void>;
		pub fn cv_dnn_readNetFromTensorflow_const_vector_unsigned_char_X_const_vector_unsigned_char_X(buffer_model: *mut c_void, buffer_config: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_readNetFromTorch_const_StringX_bool_bool(model: *const c_char, is_binary: bool, evaluate: bool) -> Result<*mut c_void>;
		pub fn cv_dnn_readNet_const_StringX_const_StringX_const_StringX(model: *const c_char, config: *const c_char, framework: *const c_char) -> Result<*mut c_void>;
		pub fn cv_dnn_readNet_const_StringX_const_vector_unsigned_char_X_const_vector_unsigned_char_X(framework: *const c_char, buffer_model: *mut c_void, buffer_config: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_readTensorFromONNX_const_StringX(path: *const c_char) -> Result<*mut c_void>;
		pub fn cv_dnn_readTorchBlob_const_StringX_bool(filename: *const c_char, is_binary: bool) -> Result<*mut c_void>;
		pub fn cv_dnn_resetMyriadDevice() -> Result_void;
		pub fn cv_dnn_setInferenceEngineBackendType_const_StringX(new_backend_type: *const c_char) -> Result<*mut c_void>;
		pub fn cv_dnn_shape_const_MatSizeX(sz: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_shape_const_MatX(mat: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_shape_const_UMatX(mat: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_shape_const_intX_int(dims: *const i32, n: i32) -> Result<*mut c_void>;
		pub fn cv_dnn_shape_int_int_int_int(a0: i32, a1: i32, a2: i32, a3: i32) -> Result<*mut c_void>;
		pub fn cv_dnn_shrinkCaffeModel_const_StringX_const_StringX_const_vector_String_X(src: *const c_char, dst: *const c_char, layers_types: *mut c_void) -> Result_void;
		pub fn cv_dnn_slice_const_MatX_const__RangeX(m: *mut c_void, r0: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_slice_const_MatX_const__RangeX_const__RangeX(m: *mut c_void, r0: *mut c_void, r1: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_slice_const_MatX_const__RangeX_const__RangeX_const__RangeX(m: *mut c_void, r0: *mut c_void, r1: *mut c_void, r2: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_slice_const_MatX_const__RangeX_const__RangeX_const__RangeX_const__RangeX(m: *mut c_void, r0: *mut c_void, r1: *mut c_void, r2: *mut c_void, r3: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_toString_const_MatShapeX_const_StringX(shape: *mut c_void, name: *const c_char) -> Result<*mut c_void>;
		pub fn cv_dnn_total_const_MatShapeX_int_int(shape: *mut c_void, start: i32, end: i32) -> Result<i32>;
		pub fn cv_dnn_writeTextGraph_const_StringX_const_StringX(model: *const c_char, output: *const c_char) -> Result_void;
		pub fn cv_dnn_AbsLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_ActivationLayer_forwardSlice_const_const_floatX_floatX_int_size_t_int_int(instance: *mut c_void, src: *const f32, dst: *mut f32, len: i32, out_plane_size: size_t, cn0: i32, cn1: i32) -> Result_void;
		pub fn cv_dnn_BNLLLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_BackendNode_backendId_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_dnn_BackendNode_setBackendId_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_dnn_BackendNode_BackendNode_int(backend_id: i32) -> Result<*mut c_void>;
		pub fn cv_dnn_BackendWrapper_backendId_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_dnn_BackendWrapper_setBackendId_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_dnn_BackendWrapper_targetId_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_dnn_BackendWrapper_setTargetId_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_dnn_BackendWrapper_copyToHost(instance: *mut c_void) -> Result_void;
		pub fn cv_dnn_BackendWrapper_setHostDirty(instance: *mut c_void) -> Result_void;
		pub fn cv_dnn_BaseConvolutionLayer_kernel_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_dnn_BaseConvolutionLayer_setKernel_Size(instance: *mut c_void, val: *const core::Size) -> Result_void;
		pub fn cv_dnn_BaseConvolutionLayer_stride_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_dnn_BaseConvolutionLayer_setStride_Size(instance: *mut c_void, val: *const core::Size) -> Result_void;
		pub fn cv_dnn_BaseConvolutionLayer_pad_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_dnn_BaseConvolutionLayer_setPad_Size(instance: *mut c_void, val: *const core::Size) -> Result_void;
		pub fn cv_dnn_BaseConvolutionLayer_dilation_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_dnn_BaseConvolutionLayer_setDilation_Size(instance: *mut c_void, val: *const core::Size) -> Result_void;
		pub fn cv_dnn_BaseConvolutionLayer_adjustPad_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_dnn_BaseConvolutionLayer_setAdjustPad_Size(instance: *mut c_void, val: *const core::Size) -> Result_void;
		pub fn cv_dnn_BaseConvolutionLayer_adjust_pads(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_BaseConvolutionLayer_setAdjust_pads_vector_size_t_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_dnn_BaseConvolutionLayer_kernel_size(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_BaseConvolutionLayer_setKernel_size_vector_size_t_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_dnn_BaseConvolutionLayer_strides(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_BaseConvolutionLayer_setStrides_vector_size_t_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_dnn_BaseConvolutionLayer_dilations(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_BaseConvolutionLayer_setDilations_vector_size_t_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_dnn_BaseConvolutionLayer_pads_begin(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_BaseConvolutionLayer_setPads_begin_vector_size_t_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_dnn_BaseConvolutionLayer_pads_end(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_BaseConvolutionLayer_setPads_end_vector_size_t_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_dnn_BaseConvolutionLayer_padMode_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_BaseConvolutionLayer_setPadMode_String(instance: *mut c_void, val: *mut c_char) -> Result_void;
		pub fn cv_dnn_BaseConvolutionLayer_numOutput_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_dnn_BaseConvolutionLayer_setNumOutput_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_dnn_BatchNormLayer_hasWeights_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_dnn_BatchNormLayer_setHasWeights_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_dnn_BatchNormLayer_hasBias_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_dnn_BatchNormLayer_setHasBias_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_dnn_BatchNormLayer_epsilon_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_dnn_BatchNormLayer_setEpsilon_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_dnn_BatchNormLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_BlankLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_ChannelsPReLULayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_ClassificationModel_ClassificationModel_const_StringX_const_StringX(model: *const c_char, config: *const c_char) -> Result<*mut c_void>;
		pub fn cv_dnn_ClassificationModel_ClassificationModel_const_NetX(network: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_ClassificationModel_classify_const__InputArrayX_intX_floatX(instance: *mut c_void, frame: *mut c_void, class_id: *mut i32, conf: *mut f32) -> Result_void;
		pub fn cv_dnn_ConcatLayer_axis_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_dnn_ConcatLayer_setAxis_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_dnn_ConcatLayer_padding_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_dnn_ConcatLayer_setPadding_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_dnn_ConcatLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_ConstLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_ConvolutionLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_CropAndResizeLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_CropLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_DeconvolutionLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_DetectionModel_DetectionModel_const_StringX_const_StringX(model: *const c_char, config: *const c_char) -> Result<*mut c_void>;
		pub fn cv_dnn_DetectionModel_DetectionModel_const_NetX(network: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_DetectionModel_detect_const__InputArrayX_vector_int_X_vector_float_X_vector_Rect_X_float_float(instance: *mut c_void, frame: *mut c_void, class_ids: *mut c_void, confidences: *mut c_void, boxes: *mut c_void, conf_threshold: f32, nms_threshold: f32) -> Result_void;
		pub fn cv_dnn_DetectionOutputLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_Dict_has_const_const_StringX(instance: *mut c_void, key: *const c_char) -> Result<bool>;
		pub fn cv_dnn_Dict_ptr_const_StringX(instance: *mut c_void, key: *const c_char) -> Result<*mut c_void>;
		pub fn cv_dnn_Dict_ptr_const_const_StringX(instance: *mut c_void, key: *const c_char) -> Result<*mut c_void>;
		pub fn cv_dnn_Dict_get_const_const_StringX(instance: *mut c_void, key: *const c_char) -> Result<*mut c_void>;
		pub fn cv_dnn_Dict_set_cv_String_const_StringX_const_StringX(instance: *mut c_void, key: *const c_char, value: *const c_char) -> Result<*mut c_void>;
		pub fn cv_dnn_Dict_set_cv_dnn_DictValue_const_StringX_const_DictValueX(instance: *mut c_void, key: *const c_char, value: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_Dict_set_double_const_StringX_const_doubleX(instance: *mut c_void, key: *const c_char, value: *const f64) -> Result<f64>;
		pub fn cv_dnn_Dict_set_int64_t_const_StringX_const_int64_tX(instance: *mut c_void, key: *const c_char, value: *const i64) -> Result<i64>;
		pub fn cv_dnn_Dict_erase_const_StringX(instance: *mut c_void, key: *const c_char) -> Result_void;
		pub fn cv_dnn_DictValue_DictValue_const_DictValueX(r: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_DictValue_DictValue_bool(i: bool) -> Result<*mut c_void>;
		pub fn cv_dnn_DictValue_DictValue_int64_t(i: i64) -> Result<*mut c_void>;
		pub fn cv_dnn_DictValue_DictValue_int(i: i32) -> Result<*mut c_void>;
		pub fn cv_dnn_DictValue_DictValue_unsigned_int(p: u32) -> Result<*mut c_void>;
		pub fn cv_dnn_DictValue_DictValue_double(p: f64) -> Result<*mut c_void>;
		pub fn cv_dnn_DictValue_DictValue_const_charX(s: *const c_char) -> Result<*mut c_void>;
		pub fn cv_dnn_DictValue_get_cv_String_const_int(instance: *mut c_void, idx: i32) -> Result<*mut c_void>;
		pub fn cv_dnn_DictValue_get_double_const_int(instance: *mut c_void, idx: i32) -> Result<f64>;
		pub fn cv_dnn_DictValue_get_int_const_int(instance: *mut c_void, idx: i32) -> Result<i32>;
		pub fn cv_dnn_DictValue_get_int64_t_const_int(instance: *mut c_void, idx: i32) -> Result<i64>;
		pub fn cv_dnn_DictValue_size_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_dnn_DictValue_isInt_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_dnn_DictValue_isString_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_dnn_DictValue_isReal_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_dnn_DictValue_getIntValue_const_int(instance: *mut c_void, idx: i32) -> Result<i32>;
		pub fn cv_dnn_DictValue_getRealValue_const_int(instance: *mut c_void, idx: i32) -> Result<f64>;
		pub fn cv_dnn_DictValue_getStringValue_const_int(instance: *mut c_void, idx: i32) -> Result<*mut c_void>;
		pub fn cv_dnn_ELULayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_EltwiseLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_FlattenLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_InnerProductLayer_axis_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_dnn_InnerProductLayer_setAxis_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_dnn_InnerProductLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_InterpLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_KeypointsModel_KeypointsModel_const_StringX_const_StringX(model: *const c_char, config: *const c_char) -> Result<*mut c_void>;
		pub fn cv_dnn_KeypointsModel_KeypointsModel_const_NetX(network: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_KeypointsModel_estimate_const__InputArrayX_float(instance: *mut c_void, frame: *mut c_void, thresh: f32) -> Result<*mut c_void>;
		pub fn cv_dnn_LRNLayer_type_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_dnn_LRNLayer_setType_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_dnn_LRNLayer_size_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_dnn_LRNLayer_setSize_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_dnn_LRNLayer_alpha_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_dnn_LRNLayer_setAlpha_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_dnn_LRNLayer_beta_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_dnn_LRNLayer_setBeta_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_dnn_LRNLayer_bias_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_dnn_LRNLayer_setBias_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_dnn_LRNLayer_normBySize_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_dnn_LRNLayer_setNormBySize_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_dnn_LRNLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_LSTMLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_LSTMLayer_setWeights_const_MatX_const_MatX_const_MatX(instance: *mut c_void, wh: *mut c_void, wx: *mut c_void, b: *mut c_void) -> Result_void;
		pub fn cv_dnn_LSTMLayer_setOutShape_const_MatShapeX(instance: *mut c_void, out_tail_shape: *mut c_void) -> Result_void;
		pub fn cv_dnn_LSTMLayer_setUseTimstampsDim_bool(instance: *mut c_void, use_: bool) -> Result_void;
		pub fn cv_dnn_LSTMLayer_setProduceCellOutput_bool(instance: *mut c_void, produce: bool) -> Result_void;
		pub fn cv_dnn_LSTMLayer_inputNameToIndex_String(instance: *mut c_void, input_name: *mut c_char) -> Result<i32>;
		pub fn cv_dnn_LSTMLayer_outputNameToIndex_const_StringX(instance: *mut c_void, output_name: *const c_char) -> Result<i32>;
		pub fn cv_dnn_Layer_blobs(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_Layer_setBlobs_vector_Mat_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_dnn_Layer_name_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_Layer_setName_String(instance: *mut c_void, val: *mut c_char) -> Result_void;
		pub fn cv_dnn_Layer_type_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_Layer_setType_String(instance: *mut c_void, val: *mut c_char) -> Result_void;
		pub fn cv_dnn_Layer_preferableTarget_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_dnn_Layer_setPreferableTarget_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_dnn_Layer_finalize_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, inputs: *mut c_void, outputs: *mut c_void) -> Result_void;
		pub fn cv_dnn_Layer_forward_vector_MatX_X_vector_Mat_X_vector_Mat_X(instance: *mut c_void, input: *mut c_void, output: *mut c_void, internals: *mut c_void) -> Result_void;
		pub fn cv_dnn_Layer_forward_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, inputs: *mut c_void, outputs: *mut c_void, internals: *mut c_void) -> Result_void;
		pub fn cv_dnn_Layer_forward_fallback_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, inputs: *mut c_void, outputs: *mut c_void, internals: *mut c_void) -> Result_void;
		pub fn cv_dnn_Layer_finalize_const_vector_Mat_X_vector_Mat_X(instance: *mut c_void, inputs: *mut c_void, outputs: *mut c_void) -> Result_void;
		pub fn cv_dnn_Layer_finalize_const_vector_Mat_X(instance: *mut c_void, inputs: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_Layer_run_const_vector_Mat_X_vector_Mat_X_vector_Mat_X(instance: *mut c_void, inputs: *mut c_void, outputs: *mut c_void, internals: *mut c_void) -> Result_void;
		pub fn cv_dnn_Layer_inputNameToIndex_String(instance: *mut c_void, input_name: *mut c_char) -> Result<i32>;
		pub fn cv_dnn_Layer_outputNameToIndex_const_StringX(instance: *mut c_void, output_name: *const c_char) -> Result<i32>;
		pub fn cv_dnn_Layer_supportBackend_int(instance: *mut c_void, backend_id: i32) -> Result<bool>;
		pub fn cv_dnn_Layer_initHalide_const_vector_Ptr_BackendWrapper__X(instance: *mut c_void, inputs: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_Layer_initInfEngine_const_vector_Ptr_BackendWrapper__X(instance: *mut c_void, inputs: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_Layer_initNgraph_const_vector_Ptr_BackendWrapper__X_const_vector_Ptr_BackendNode__X(instance: *mut c_void, inputs: *mut c_void, nodes: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_Layer_initVkCom_const_vector_Ptr_BackendWrapper__X(instance: *mut c_void, inputs: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_Layer_initCUDA_voidX_const_vector_Ptr_BackendWrapper__X_const_vector_Ptr_BackendWrapper__X(instance: *mut c_void, context: *mut c_void, inputs: *mut c_void, outputs: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_Layer_applyHalideScheduler_const_Ptr_BackendNode_X_const_vector_MatX_X_const_vector_Mat_X_int(instance: *mut c_void, node: *mut c_void, inputs: *mut c_void, outputs: *mut c_void, target_id: i32) -> Result_void;
		pub fn cv_dnn_Layer_tryAttach_const_Ptr_BackendNode_X(instance: *mut c_void, node: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_Layer_setActivation_const_Ptr_ActivationLayer_X(instance: *mut c_void, layer: *mut c_void) -> Result<bool>;
		pub fn cv_dnn_Layer_tryFuse_Ptr_Layer_X(instance: *mut c_void, top: *mut c_void) -> Result<bool>;
		pub fn cv_dnn_Layer_getScaleShift_const_MatX_MatX(instance: *mut c_void, scale: *mut c_void, shift: *mut c_void) -> Result_void;
		pub fn cv_dnn_Layer_unsetAttached(instance: *mut c_void) -> Result_void;
		pub fn cv_dnn_Layer_getMemoryShapes_const_const_vector_MatShape_X_int_vector_MatShape_X_vector_MatShape_X(instance: *mut c_void, inputs: *mut c_void, required_outputs: i32, outputs: *mut c_void, internals: *mut c_void) -> Result<bool>;
		pub fn cv_dnn_Layer_getFLOPS_const_const_vector_MatShape_X_const_vector_MatShape_X(instance: *mut c_void, inputs: *mut c_void, outputs: *mut c_void) -> Result<i64>;
		pub fn cv_dnn_Layer_Layer() -> Result<*mut c_void>;
		pub fn cv_dnn_Layer_Layer_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_Layer_setParamsFrom_const_LayerParamsX(instance: *mut c_void, params: *mut c_void) -> Result_void;
		pub fn cv_dnn_LayerFactory_registerLayer_const_StringX_Constructor(typ: *const c_char, constructor: Option<extern "C" fn(*mut c_void) -> *mut c_void>) -> Result_void;
		pub fn cv_dnn_LayerFactory_unregisterLayer_const_StringX(typ: *const c_char) -> Result_void;
		pub fn cv_dnn_LayerFactory_createLayerInstance_const_StringX_LayerParamsX(typ: *const c_char, params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_LayerParams_blobs(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_LayerParams_setBlobs_vector_Mat_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_dnn_LayerParams_name_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_LayerParams_setName_String(instance: *mut c_void, val: *mut c_char) -> Result_void;
		pub fn cv_dnn_LayerParams_type_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_LayerParams_setType_String(instance: *mut c_void, val: *mut c_char) -> Result_void;
		pub fn cv_dnn_MVNLayer_eps_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_dnn_MVNLayer_setEps_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_dnn_MVNLayer_normVariance_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_dnn_MVNLayer_setNormVariance_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_dnn_MVNLayer_acrossChannels_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_dnn_MVNLayer_setAcrossChannels_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_dnn_MVNLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_MaxUnpoolLayer_poolKernel_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_dnn_MaxUnpoolLayer_setPoolKernel_Size(instance: *mut c_void, val: *const core::Size) -> Result_void;
		pub fn cv_dnn_MaxUnpoolLayer_poolPad_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_dnn_MaxUnpoolLayer_setPoolPad_Size(instance: *mut c_void, val: *const core::Size) -> Result_void;
		pub fn cv_dnn_MaxUnpoolLayer_poolStride_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_dnn_MaxUnpoolLayer_setPoolStride_Size(instance: *mut c_void, val: *const core::Size) -> Result_void;
		pub fn cv_dnn_MaxUnpoolLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_MishLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_Model_Model() -> Result<*mut c_void>;
		pub fn cv_dnn_Model_Model_const_StringX_const_StringX(model: *const c_char, config: *const c_char) -> Result<*mut c_void>;
		pub fn cv_dnn_Model_Model_const_NetX(network: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_Model_setInputSize_const_SizeX(instance: *mut c_void, size: *const core::Size) -> Result<*mut c_void>;
		pub fn cv_dnn_Model_setInputSize_int_int(instance: *mut c_void, width: i32, height: i32) -> Result<*mut c_void>;
		pub fn cv_dnn_Model_setInputMean_const_ScalarX(instance: *mut c_void, mean: *const core::Scalar) -> Result<*mut c_void>;
		pub fn cv_dnn_Model_setInputScale_double(instance: *mut c_void, scale: f64) -> Result<*mut c_void>;
		pub fn cv_dnn_Model_setInputCrop_bool(instance: *mut c_void, crop: bool) -> Result<*mut c_void>;
		pub fn cv_dnn_Model_setInputSwapRB_bool(instance: *mut c_void, swap_rb: bool) -> Result<*mut c_void>;
		pub fn cv_dnn_Model_setInputParams_double_const_SizeX_const_ScalarX_bool_bool(instance: *mut c_void, scale: f64, size: *const core::Size, mean: *const core::Scalar, swap_rb: bool, crop: bool) -> Result_void;
		pub fn cv_dnn_Model_predict_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, frame: *mut c_void, outs: *mut c_void) -> Result_void;
		pub fn cv_dnn_Net_Net() -> Result<*mut c_void>;
		pub fn cv_dnn_Net_readFromModelOptimizer_const_StringX_const_StringX(xml: *const c_char, bin: *const c_char) -> Result<*mut c_void>;
		pub fn cv_dnn_Net_readFromModelOptimizer_const_vector_unsigned_char_X_const_vector_unsigned_char_X(buffer_model_config: *mut c_void, buffer_weights: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_Net_readFromModelOptimizer_const_unsigned_charX_size_t_const_unsigned_charX_size_t(buffer_model_config_ptr: *const u8, buffer_model_config_size: size_t, buffer_weights_ptr: *const u8, buffer_weights_size: size_t) -> Result<*mut c_void>;
		pub fn cv_dnn_Net_empty_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_dnn_Net_dump(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_Net_dumpToFile_const_StringX(instance: *mut c_void, path: *const c_char) -> Result_void;
		pub fn cv_dnn_Net_addLayer_const_StringX_const_StringX_LayerParamsX(instance: *mut c_void, name: *const c_char, typ: *const c_char, params: *mut c_void) -> Result<i32>;
		pub fn cv_dnn_Net_addLayerToPrev_const_StringX_const_StringX_LayerParamsX(instance: *mut c_void, name: *const c_char, typ: *const c_char, params: *mut c_void) -> Result<i32>;
		pub fn cv_dnn_Net_getLayerId_const_StringX(instance: *mut c_void, layer: *const c_char) -> Result<i32>;
		pub fn cv_dnn_Net_getLayerNames_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_Net_getLayer_LayerId(instance: *mut c_void, layer_id: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_Net_getLayerInputs_LayerId(instance: *mut c_void, layer_id: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_Net_connect_String_String(instance: *mut c_void, out_pin: *mut c_char, inp_pin: *mut c_char) -> Result_void;
		pub fn cv_dnn_Net_connect_int_int_int_int(instance: *mut c_void, out_layer_id: i32, out_num: i32, inp_layer_id: i32, inp_num: i32) -> Result_void;
		pub fn cv_dnn_Net_setInputsNames_const_vector_String_X(instance: *mut c_void, input_blob_names: *mut c_void) -> Result_void;
		pub fn cv_dnn_Net_forward_const_StringX(instance: *mut c_void, output_name: *const c_char) -> Result<*mut c_void>;
		pub fn cv_dnn_Net_forwardAsync_const_StringX(instance: *mut c_void, output_name: *const c_char) -> Result<*mut c_void>;
		pub fn cv_dnn_Net_forward_const__OutputArrayX_const_StringX(instance: *mut c_void, output_blobs: *mut c_void, output_name: *const c_char) -> Result_void;
		pub fn cv_dnn_Net_forward_const__OutputArrayX_const_vector_String_X(instance: *mut c_void, output_blobs: *mut c_void, out_blob_names: *mut c_void) -> Result_void;
		pub fn cv_dnn_Net_forward_vector_vector_Mat__X_const_vector_String_X(instance: *mut c_void, output_blobs: *mut c_void, out_blob_names: *mut c_void) -> Result_void;
		pub fn cv_dnn_Net_setHalideScheduler_const_StringX(instance: *mut c_void, scheduler: *const c_char) -> Result_void;
		pub fn cv_dnn_Net_setPreferableBackend_int(instance: *mut c_void, backend_id: i32) -> Result_void;
		pub fn cv_dnn_Net_setPreferableTarget_int(instance: *mut c_void, target_id: i32) -> Result_void;
		pub fn cv_dnn_Net_setInput_const__InputArrayX_const_StringX_double_const_ScalarX(instance: *mut c_void, blob: *mut c_void, name: *const c_char, scalefactor: f64, mean: *const core::Scalar) -> Result_void;
		pub fn cv_dnn_Net_setParam_LayerId_int_const_MatX(instance: *mut c_void, layer: *mut c_void, num_param: i32, blob: *mut c_void) -> Result_void;
		pub fn cv_dnn_Net_getParam_LayerId_int(instance: *mut c_void, layer: *mut c_void, num_param: i32) -> Result<*mut c_void>;
		pub fn cv_dnn_Net_getUnconnectedOutLayers_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_Net_getUnconnectedOutLayersNames_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_Net_getLayersShapes_const_const_vector_MatShape_X_vector_int_X_vector_vector_MatShape__X_vector_vector_MatShape__X(instance: *mut c_void, net_input_shapes: *mut c_void, layers_ids: *mut c_void, in_layers_shapes: *mut c_void, out_layers_shapes: *mut c_void) -> Result_void;
		pub fn cv_dnn_Net_getLayersShapes_const_const_MatShapeX_vector_int_X_vector_vector_MatShape__X_vector_vector_MatShape__X(instance: *mut c_void, net_input_shape: *mut c_void, layers_ids: *mut c_void, in_layers_shapes: *mut c_void, out_layers_shapes: *mut c_void) -> Result_void;
		pub fn cv_dnn_Net_getLayerShapes_const_const_MatShapeX_int_vector_MatShape_X_vector_MatShape_X(instance: *mut c_void, net_input_shape: *mut c_void, layer_id: i32, in_layer_shapes: *mut c_void, out_layer_shapes: *mut c_void) -> Result_void;
		pub fn cv_dnn_Net_getLayerShapes_const_const_vector_MatShape_X_int_vector_MatShape_X_vector_MatShape_X(instance: *mut c_void, net_input_shapes: *mut c_void, layer_id: i32, in_layer_shapes: *mut c_void, out_layer_shapes: *mut c_void) -> Result_void;
		pub fn cv_dnn_Net_getFLOPS_const_const_vector_MatShape_X(instance: *mut c_void, net_input_shapes: *mut c_void) -> Result<i64>;
		pub fn cv_dnn_Net_getFLOPS_const_const_MatShapeX(instance: *mut c_void, net_input_shape: *mut c_void) -> Result<i64>;
		pub fn cv_dnn_Net_getFLOPS_const_int_const_vector_MatShape_X(instance: *mut c_void, layer_id: i32, net_input_shapes: *mut c_void) -> Result<i64>;
		pub fn cv_dnn_Net_getFLOPS_const_int_const_MatShapeX(instance: *mut c_void, layer_id: i32, net_input_shape: *mut c_void) -> Result<i64>;
		pub fn cv_dnn_Net_getLayerTypes_const_vector_String_X(instance: *mut c_void, layers_types: *mut c_void) -> Result_void;
		pub fn cv_dnn_Net_getLayersCount_const_const_StringX(instance: *mut c_void, layer_type: *const c_char) -> Result<i32>;
		pub fn cv_dnn_Net_getMemoryConsumption_const_const_vector_MatShape_X_size_tX_size_tX(instance: *mut c_void, net_input_shapes: *mut c_void, weights: *mut size_t, blobs: *mut size_t) -> Result_void;
		pub fn cv_dnn_Net_getMemoryConsumption_const_const_MatShapeX_size_tX_size_tX(instance: *mut c_void, net_input_shape: *mut c_void, weights: *mut size_t, blobs: *mut size_t) -> Result_void;
		pub fn cv_dnn_Net_getMemoryConsumption_const_int_const_vector_MatShape_X_size_tX_size_tX(instance: *mut c_void, layer_id: i32, net_input_shapes: *mut c_void, weights: *mut size_t, blobs: *mut size_t) -> Result_void;
		pub fn cv_dnn_Net_getMemoryConsumption_const_int_const_MatShapeX_size_tX_size_tX(instance: *mut c_void, layer_id: i32, net_input_shape: *mut c_void, weights: *mut size_t, blobs: *mut size_t) -> Result_void;
		pub fn cv_dnn_Net_getMemoryConsumption_const_const_vector_MatShape_X_vector_int_X_vector_size_t_X_vector_size_t_X(instance: *mut c_void, net_input_shapes: *mut c_void, layer_ids: *mut c_void, weights: *mut c_void, blobs: *mut c_void) -> Result_void;
		pub fn cv_dnn_Net_getMemoryConsumption_const_const_MatShapeX_vector_int_X_vector_size_t_X_vector_size_t_X(instance: *mut c_void, net_input_shape: *mut c_void, layer_ids: *mut c_void, weights: *mut c_void, blobs: *mut c_void) -> Result_void;
		pub fn cv_dnn_Net_enableFusion_bool(instance: *mut c_void, fusion: bool) -> Result_void;
		pub fn cv_dnn_Net_getPerfProfile_vector_double_X(instance: *mut c_void, timings: *mut c_void) -> Result<i64>;
		pub fn cv_dnn_NormalizeBBoxLayer_pnorm_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_dnn_NormalizeBBoxLayer_setPnorm_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_dnn_NormalizeBBoxLayer_epsilon_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_dnn_NormalizeBBoxLayer_setEpsilon_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_dnn_NormalizeBBoxLayer_acrossSpatial_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_dnn_NormalizeBBoxLayer_setAcrossSpatial_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_dnn_NormalizeBBoxLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_PaddingLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_PermuteLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_PoolingLayer_type_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_dnn_PoolingLayer_setType_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_dnn_PoolingLayer_kernel_size(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_PoolingLayer_setKernel_size_vector_size_t_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_dnn_PoolingLayer_strides(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_PoolingLayer_setStrides_vector_size_t_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_dnn_PoolingLayer_pads_begin(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_PoolingLayer_setPads_begin_vector_size_t_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_dnn_PoolingLayer_pads_end(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_PoolingLayer_setPads_end_vector_size_t_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_dnn_PoolingLayer_kernel_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_dnn_PoolingLayer_setKernel_Size(instance: *mut c_void, val: *const core::Size) -> Result_void;
		pub fn cv_dnn_PoolingLayer_stride_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_dnn_PoolingLayer_setStride_Size(instance: *mut c_void, val: *const core::Size) -> Result_void;
		pub fn cv_dnn_PoolingLayer_pad_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_dnn_PoolingLayer_setPad_Size(instance: *mut c_void, val: *const core::Size) -> Result_void;
		pub fn cv_dnn_PoolingLayer_pad_l_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_dnn_PoolingLayer_setPad_l_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_dnn_PoolingLayer_pad_t_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_dnn_PoolingLayer_setPad_t_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_dnn_PoolingLayer_pad_r_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_dnn_PoolingLayer_setPad_r_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_dnn_PoolingLayer_pad_b_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_dnn_PoolingLayer_setPad_b_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_dnn_PoolingLayer_globalPooling_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_dnn_PoolingLayer_setGlobalPooling_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_dnn_PoolingLayer_computeMaxIdx_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_dnn_PoolingLayer_setComputeMaxIdx_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_dnn_PoolingLayer_padMode_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_PoolingLayer_setPadMode_String(instance: *mut c_void, val: *mut c_char) -> Result_void;
		pub fn cv_dnn_PoolingLayer_ceilMode_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_dnn_PoolingLayer_setCeilMode_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_dnn_PoolingLayer_avePoolPaddedArea_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_dnn_PoolingLayer_setAvePoolPaddedArea_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_dnn_PoolingLayer_pooledSize_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_dnn_PoolingLayer_setPooledSize_Size(instance: *mut c_void, val: *const core::Size) -> Result_void;
		pub fn cv_dnn_PoolingLayer_spatialScale_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_dnn_PoolingLayer_setSpatialScale_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_dnn_PoolingLayer_psRoiOutChannels_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_dnn_PoolingLayer_setPsRoiOutChannels_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_dnn_PoolingLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_PowerLayer_power_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_dnn_PowerLayer_setPower_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_dnn_PowerLayer_scale_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_dnn_PowerLayer_setScale_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_dnn_PowerLayer_shift_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_dnn_PowerLayer_setShift_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_dnn_PowerLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_PriorBoxLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_ProposalLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_RNNLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_RNNLayer_setWeights_const_MatX_const_MatX_const_MatX_const_MatX_const_MatX(instance: *mut c_void, wxh: *mut c_void, bh: *mut c_void, whh: *mut c_void, who: *mut c_void, bo: *mut c_void) -> Result_void;
		pub fn cv_dnn_RNNLayer_setProduceHiddenOutput_bool(instance: *mut c_void, produce: bool) -> Result_void;
		pub fn cv_dnn_ReLU6Layer_minValue_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_dnn_ReLU6Layer_setMinValue_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_dnn_ReLU6Layer_maxValue_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_dnn_ReLU6Layer_setMaxValue_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_dnn_ReLU6Layer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_ReLULayer_negativeSlope_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_dnn_ReLULayer_setNegativeSlope_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_dnn_ReLULayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_RegionLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_ReorgLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_ReshapeLayer_newShapeDesc(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_ReshapeLayer_setNewShapeDesc_MatShape(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_dnn_ReshapeLayer_newShapeRange(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_ReshapeLayer_setNewShapeRange_Range(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_dnn_ReshapeLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_ResizeLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_ScaleLayer_hasBias_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_dnn_ScaleLayer_setHasBias_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_dnn_ScaleLayer_axis_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_dnn_ScaleLayer_setAxis_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_dnn_ScaleLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_SegmentationModel_SegmentationModel_const_StringX_const_StringX(model: *const c_char, config: *const c_char) -> Result<*mut c_void>;
		pub fn cv_dnn_SegmentationModel_SegmentationModel_const_NetX(network: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_SegmentationModel_segment_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, frame: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_dnn_ShiftLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_ShuffleChannelLayer_group_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_dnn_ShuffleChannelLayer_setGroup_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_dnn_ShuffleChannelLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_SigmoidLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_SliceLayer_sliceRanges(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_SliceLayer_setSliceRanges_vector_vector_Range__(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_dnn_SliceLayer_axis_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_dnn_SliceLayer_setAxis_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_dnn_SliceLayer_num_split_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_dnn_SliceLayer_setNum_split_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_dnn_SliceLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_SoftmaxLayer_logSoftMax_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_dnn_SoftmaxLayer_setLogSoftMax_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_dnn_SoftmaxLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_SplitLayer_outputsCount_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_dnn_SplitLayer_setOutputsCount_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_dnn_SplitLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_SwishLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn_TanHLayer_create_const_LayerParamsX(params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn__Range__Range_const_RangeX(r: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dnn__Range__Range_int_int(start_: i32, size_: i32) -> Result<*mut c_void>;
	}
}
pub use dnn_sys::*;

mod dnn_superres_sys {
	use super::*;

	extern "C" {
		pub fn cv_dnn_superres_DnnSuperResImpl_DnnSuperResImpl() -> Result<*mut c_void>;
		pub fn cv_dnn_superres_DnnSuperResImpl_DnnSuperResImpl_const_stringX_int(algo: *const c_char, scale: i32) -> Result<*mut c_void>;
		pub fn cv_dnn_superres_DnnSuperResImpl_readModel_const_stringX(instance: *mut c_void, path: *const c_char) -> Result_void;
		pub fn cv_dnn_superres_DnnSuperResImpl_readModel_const_stringX_const_stringX(instance: *mut c_void, weights: *const c_char, definition: *const c_char) -> Result_void;
		pub fn cv_dnn_superres_DnnSuperResImpl_setModel_const_stringX_int(instance: *mut c_void, algo: *const c_char, scale: i32) -> Result_void;
		pub fn cv_dnn_superres_DnnSuperResImpl_upsample_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, img: *mut c_void, result: *mut c_void) -> Result_void;
		pub fn cv_dnn_superres_DnnSuperResImpl_upsampleMultioutput_const__InputArrayX_vector_Mat_X_const_vector_int_X_const_vector_String_X(instance: *mut c_void, img: *mut c_void, imgs_new: *mut c_void, scale_factors: *mut c_void, node_names: *mut c_void) -> Result_void;
		pub fn cv_dnn_superres_DnnSuperResImpl_getScale(instance: *mut c_void) -> Result<i32>;
		pub fn cv_dnn_superres_DnnSuperResImpl_getAlgorithm(instance: *mut c_void) -> Result<*mut c_void>;
	}
}
pub use dnn_superres_sys::*;

#[cfg(feature = "contrib")]
mod dpm_sys {
	use super::*;

	extern "C" {
		pub fn cv_dpm_DPMDetector_isEmpty_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_dpm_DPMDetector_detect_MatX_vector_ObjectDetection_X(instance: *mut c_void, image: *mut c_void, objects: *mut c_void) -> Result_void;
		pub fn cv_dpm_DPMDetector_getClassNames_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dpm_DPMDetector_getClassCount_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_dpm_DPMDetector_create_const_vector_string_X_const_vector_string_X(filenames: *mut c_void, class_names: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_dpm_DPMDetector_ObjectDetection_rect_const(instance: *mut c_void) -> Result<core::Rect>;
		pub fn cv_dpm_DPMDetector_ObjectDetection_setRect_Rect(instance: *mut c_void, val: *const core::Rect) -> Result_void;
		pub fn cv_dpm_DPMDetector_ObjectDetection_score_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_dpm_DPMDetector_ObjectDetection_setScore_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_dpm_DPMDetector_ObjectDetection_classID_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_dpm_DPMDetector_ObjectDetection_setClassID_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_dpm_DPMDetector_ObjectDetection_ObjectDetection() -> Result<*mut c_void>;
		pub fn cv_dpm_DPMDetector_ObjectDetection_ObjectDetection_const_RectX_float_int(rect: *const core::Rect, score: f32, class_id: i32) -> Result<*mut c_void>;
	}
}
#[cfg(feature = "contrib")]
pub use dpm_sys::*;

#[cfg(feature = "contrib")]
mod face_sys {
	use super::*;

	extern "C" {
		pub fn cv_face_createFacemarkAAM() -> Result<*mut c_void>;
		pub fn cv_face_createFacemarkKazemi() -> Result<*mut c_void>;
		pub fn cv_face_createFacemarkLBF() -> Result<*mut c_void>;
		pub fn cv_face_drawFacemarks_const__InputOutputArrayX_const__InputArrayX_Scalar(image: *mut c_void, points: *mut c_void, color: *const core::Scalar) -> Result_void;
		pub fn cv_face_getFacesHAAR_const__InputArrayX_const__OutputArrayX_const_StringX(image: *mut c_void, faces: *mut c_void, face_cascade_name: *const c_char) -> Result<bool>;
		pub fn cv_face_getFaces_const__InputArrayX_const__OutputArrayX_CParamsX(image: *mut c_void, faces: *mut c_void, params: *mut c_void) -> Result<bool>;
		pub fn cv_face_loadDatasetList_String_String_vector_String_X_vector_String_X(image_list: *mut c_char, annotation_list: *mut c_char, images: *mut c_void, annotations: *mut c_void) -> Result<bool>;
		pub fn cv_face_loadFacePoints_String_const__OutputArrayX_float(filename: *mut c_char, points: *mut c_void, offset: f32) -> Result<bool>;
		pub fn cv_face_loadTrainingData_String_String_vector_String_X_const__OutputArrayX_float(image_list: *mut c_char, ground_truth: *mut c_char, images: *mut c_void, face_points: *mut c_void, offset: f32) -> Result<bool>;
		pub fn cv_face_loadTrainingData_String_vector_String_X_const__OutputArrayX_char_float(filename: *mut c_char, images: *mut c_void, face_points: *mut c_void, delim: i8, offset: f32) -> Result<bool>;
		pub fn cv_face_loadTrainingData_vector_String__vector_vector_Point2f__X_vector_String_X(filename: *mut c_void, trainlandmarks: *mut c_void, trainimages: *mut c_void) -> Result<bool>;
		pub fn cv_face_BIF_getNumBands_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_face_BIF_getNumRotations_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_face_BIF_compute_const_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, image: *mut c_void, features: *mut c_void) -> Result_void;
		pub fn cv_face_BIF_create_int_int(num_bands: i32, num_rotations: i32) -> Result<*mut c_void>;
		pub fn cv_face_BasicFaceRecognizer_getNumComponents_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_face_BasicFaceRecognizer_setNumComponents_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_face_BasicFaceRecognizer_getThreshold_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_face_BasicFaceRecognizer_setThreshold_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_face_BasicFaceRecognizer_getProjections_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_BasicFaceRecognizer_getLabels_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_BasicFaceRecognizer_getEigenValues_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_BasicFaceRecognizer_getEigenVectors_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_BasicFaceRecognizer_getMean_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_BasicFaceRecognizer_read_const_FileNodeX(instance: *mut c_void, fn_: *mut c_void) -> Result_void;
		pub fn cv_face_BasicFaceRecognizer_write_const_FileStorageX(instance: *mut c_void, fs: *mut c_void) -> Result_void;
		pub fn cv_face_BasicFaceRecognizer_empty_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_face_CParams_cascade_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_CParams_setCascade_String(instance: *mut c_void, val: *mut c_char) -> Result_void;
		pub fn cv_face_CParams_scaleFactor_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_face_CParams_setScaleFactor_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_face_CParams_minNeighbors_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_face_CParams_setMinNeighbors_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_face_CParams_minSize_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_face_CParams_setMinSize_Size(instance: *mut c_void, val: *const core::Size) -> Result_void;
		pub fn cv_face_CParams_maxSize_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_face_CParams_setMaxSize_Size(instance: *mut c_void, val: *const core::Size) -> Result_void;
		pub fn cv_face_CParams_face_cascade(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_CParams_setFace_cascade_CascadeClassifier(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_face_CParams_CParams_String_double_int_Size_Size(cascade_model: *mut c_char, sf: f64, min_n: i32, min_sz: *const core::Size, max_sz: *const core::Size) -> Result<*mut c_void>;
		pub fn cv_face_EigenFaceRecognizer_create_int_double(num_components: i32, threshold: f64) -> Result<*mut c_void>;
		pub fn cv_face_FaceRecognizer_train_const__InputArrayX_const__InputArrayX(instance: *mut c_void, src: *mut c_void, labels: *mut c_void) -> Result_void;
		pub fn cv_face_FaceRecognizer_update_const__InputArrayX_const__InputArrayX(instance: *mut c_void, src: *mut c_void, labels: *mut c_void) -> Result_void;
		pub fn cv_face_FaceRecognizer_predict_const_const__InputArrayX(instance: *mut c_void, src: *mut c_void) -> Result<i32>;
		pub fn cv_face_FaceRecognizer_predict_const_const__InputArrayX_intX_doubleX(instance: *mut c_void, src: *mut c_void, label: *mut i32, confidence: *mut f64) -> Result_void;
		pub fn cv_face_FaceRecognizer_predict_const_const__InputArrayX_Ptr_PredictCollector_(instance: *mut c_void, src: *mut c_void, collector: *mut c_void) -> Result_void;
		pub fn cv_face_FaceRecognizer_write_const_const_StringX(instance: *mut c_void, filename: *const c_char) -> Result_void;
		pub fn cv_face_FaceRecognizer_read_const_StringX(instance: *mut c_void, filename: *const c_char) -> Result_void;
		pub fn cv_face_FaceRecognizer_write_const_FileStorageX(instance: *mut c_void, fs: *mut c_void) -> Result_void;
		pub fn cv_face_FaceRecognizer_read_const_FileNodeX(instance: *mut c_void, fn_: *mut c_void) -> Result_void;
		pub fn cv_face_FaceRecognizer_empty_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_face_FaceRecognizer_setLabelInfo_int_const_StringX(instance: *mut c_void, label: i32, str_info: *const c_char) -> Result_void;
		pub fn cv_face_FaceRecognizer_getLabelInfo_const_int(instance: *mut c_void, label: i32) -> Result<*mut c_void>;
		pub fn cv_face_FaceRecognizer_getLabelsByString_const_const_StringX(instance: *mut c_void, str: *const c_char) -> Result<*mut c_void>;
		pub fn cv_face_FaceRecognizer_getThreshold_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_face_FaceRecognizer_setThreshold_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_face_Facemark_loadModel_String(instance: *mut c_void, model: *mut c_char) -> Result_void;
		pub fn cv_face_Facemark_fit_const__InputArrayX_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, image: *mut c_void, faces: *mut c_void, landmarks: *mut c_void) -> Result<bool>;
		pub fn cv_face_FacemarkAAM_fitConfig_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const_vector_Config_X(instance: *mut c_void, image: *mut c_void, roi: *mut c_void, _landmarks: *mut c_void, runtime_params: *mut c_void) -> Result<bool>;
		pub fn cv_face_FacemarkAAM_create_const_ParamsX(parameters: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkAAM_Config_R(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkAAM_Config_setR_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_face_FacemarkAAM_Config_t_const(instance: *mut c_void) -> Result<core::Point2f>;
		pub fn cv_face_FacemarkAAM_Config_setT_Point2f(instance: *mut c_void, val: *const core::Point2f) -> Result_void;
		pub fn cv_face_FacemarkAAM_Config_scale_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_face_FacemarkAAM_Config_setScale_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_face_FacemarkAAM_Config_model_scale_idx_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_face_FacemarkAAM_Config_setModel_scale_idx_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_face_FacemarkAAM_Config_Config_Mat_Point2f_float_int(rot: *mut c_void, trans: *const core::Point2f, scaling: f32, scale_id: i32) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkAAM_Data_s0(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkAAM_Data_setS0_vector_Point2f_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_face_FacemarkAAM_Model_scales(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkAAM_Model_setScales_vector_float_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_face_FacemarkAAM_Model_triangles(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkAAM_Model_setTriangles_vector_Vec3i_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_face_FacemarkAAM_Model_textures(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkAAM_Model_setTextures_vector_Texture_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_face_FacemarkAAM_Model_s0(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkAAM_Model_setS0_vector_Point2f_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_face_FacemarkAAM_Model_S(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkAAM_Model_setS_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_face_FacemarkAAM_Model_Q(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkAAM_Model_setQ_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_face_FacemarkAAM_Model_Texture_max_m_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_face_FacemarkAAM_Model_Texture_setMax_m_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_face_FacemarkAAM_Model_Texture_resolution_const(instance: *mut c_void) -> Result<core::Rect>;
		pub fn cv_face_FacemarkAAM_Model_Texture_setResolution_Rect(instance: *mut c_void, val: *const core::Rect) -> Result_void;
		pub fn cv_face_FacemarkAAM_Model_Texture_A(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkAAM_Model_Texture_setA_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_face_FacemarkAAM_Model_Texture_A0(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkAAM_Model_Texture_setA0_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_face_FacemarkAAM_Model_Texture_AA(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkAAM_Model_Texture_setAA_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_face_FacemarkAAM_Model_Texture_AA0(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkAAM_Model_Texture_setAA0_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_face_FacemarkAAM_Model_Texture_textureIdx(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkAAM_Model_Texture_setTextureIdx_vector_vector_Point__(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_face_FacemarkAAM_Model_Texture_base_shape(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkAAM_Model_Texture_setBase_shape_vector_Point2f_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_face_FacemarkAAM_Model_Texture_ind1(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkAAM_Model_Texture_setInd1_vector_int_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_face_FacemarkAAM_Model_Texture_ind2(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkAAM_Model_Texture_setInd2_vector_int_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_face_FacemarkAAM_Params_model_filename_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkAAM_Params_setModel_filename_string(instance: *mut c_void, val: *mut c_char) -> Result_void;
		pub fn cv_face_FacemarkAAM_Params_m_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_face_FacemarkAAM_Params_setM_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_face_FacemarkAAM_Params_n_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_face_FacemarkAAM_Params_setN_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_face_FacemarkAAM_Params_n_iter_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_face_FacemarkAAM_Params_setN_iter_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_face_FacemarkAAM_Params_verbose_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_face_FacemarkAAM_Params_setVerbose_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_face_FacemarkAAM_Params_save_model_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_face_FacemarkAAM_Params_setSave_model_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_face_FacemarkAAM_Params_max_m_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_face_FacemarkAAM_Params_setMax_m_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_face_FacemarkAAM_Params_max_n_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_face_FacemarkAAM_Params_setMax_n_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_face_FacemarkAAM_Params_texture_max_m_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_face_FacemarkAAM_Params_setTexture_max_m_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_face_FacemarkAAM_Params_scales(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkAAM_Params_setScales_vector_float_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_face_FacemarkAAM_Params_Params() -> Result<*mut c_void>;
		pub fn cv_face_FacemarkAAM_Params_read_const_FileNodeX(instance: *mut c_void, unnamed: *mut c_void) -> Result_void;
		pub fn cv_face_FacemarkAAM_Params_write_const_FileStorageX(instance: *mut c_void, unnamed: *mut c_void) -> Result_void;
		pub fn cv_face_FacemarkKazemi_create_const_ParamsX(parameters: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkKazemi_training_vector_Mat_X_vector_vector_Point2f__X_string_Size_string(instance: *mut c_void, images: *mut c_void, landmarks: *mut c_void, configfile: *mut c_char, scale: *const core::Size, model_filename: *mut c_char) -> Result<bool>;
		pub fn cv_face_FacemarkKazemi_getFaces_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, image: *mut c_void, faces: *mut c_void) -> Result<bool>;
		pub fn cv_face_FacemarkKazemi_Params_cascade_depth_const(instance: *mut c_void) -> Result<u32>;
		pub fn cv_face_FacemarkKazemi_Params_setCascade_depth_unsigned_long(instance: *mut c_void, val: u32) -> Result_void;
		pub fn cv_face_FacemarkKazemi_Params_tree_depth_const(instance: *mut c_void) -> Result<u32>;
		pub fn cv_face_FacemarkKazemi_Params_setTree_depth_unsigned_long(instance: *mut c_void, val: u32) -> Result_void;
		pub fn cv_face_FacemarkKazemi_Params_num_trees_per_cascade_level_const(instance: *mut c_void) -> Result<u32>;
		pub fn cv_face_FacemarkKazemi_Params_setNum_trees_per_cascade_level_unsigned_long(instance: *mut c_void, val: u32) -> Result_void;
		pub fn cv_face_FacemarkKazemi_Params_learning_rate_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_face_FacemarkKazemi_Params_setLearning_rate_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_face_FacemarkKazemi_Params_oversampling_amount_const(instance: *mut c_void) -> Result<u32>;
		pub fn cv_face_FacemarkKazemi_Params_setOversampling_amount_unsigned_long(instance: *mut c_void, val: u32) -> Result_void;
		pub fn cv_face_FacemarkKazemi_Params_num_test_coordinates_const(instance: *mut c_void) -> Result<u32>;
		pub fn cv_face_FacemarkKazemi_Params_setNum_test_coordinates_unsigned_long(instance: *mut c_void, val: u32) -> Result_void;
		pub fn cv_face_FacemarkKazemi_Params_lambda_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_face_FacemarkKazemi_Params_setLambda_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_face_FacemarkKazemi_Params_num_test_splits_const(instance: *mut c_void) -> Result<u32>;
		pub fn cv_face_FacemarkKazemi_Params_setNum_test_splits_unsigned_long(instance: *mut c_void, val: u32) -> Result_void;
		pub fn cv_face_FacemarkKazemi_Params_configfile_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkKazemi_Params_setConfigfile_String(instance: *mut c_void, val: *mut c_char) -> Result_void;
		pub fn cv_face_FacemarkKazemi_Params_Params() -> Result<*mut c_void>;
		pub fn cv_face_FacemarkLBF_create_const_ParamsX(parameters: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkLBF_Params_shape_offset_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_face_FacemarkLBF_Params_setShape_offset_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_face_FacemarkLBF_Params_cascade_face_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkLBF_Params_setCascade_face_String(instance: *mut c_void, val: *mut c_char) -> Result_void;
		pub fn cv_face_FacemarkLBF_Params_verbose_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_face_FacemarkLBF_Params_setVerbose_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_face_FacemarkLBF_Params_n_landmarks_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_face_FacemarkLBF_Params_setN_landmarks_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_face_FacemarkLBF_Params_initShape_n_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_face_FacemarkLBF_Params_setInitShape_n_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_face_FacemarkLBF_Params_stages_n_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_face_FacemarkLBF_Params_setStages_n_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_face_FacemarkLBF_Params_tree_n_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_face_FacemarkLBF_Params_setTree_n_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_face_FacemarkLBF_Params_tree_depth_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_face_FacemarkLBF_Params_setTree_depth_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_face_FacemarkLBF_Params_bagging_overlap_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_face_FacemarkLBF_Params_setBagging_overlap_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_face_FacemarkLBF_Params_model_filename_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkLBF_Params_setModel_filename_string(instance: *mut c_void, val: *mut c_char) -> Result_void;
		pub fn cv_face_FacemarkLBF_Params_save_model_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_face_FacemarkLBF_Params_setSave_model_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_face_FacemarkLBF_Params_seed_const(instance: *mut c_void) -> Result<u32>;
		pub fn cv_face_FacemarkLBF_Params_setSeed_unsigned_int(instance: *mut c_void, val: u32) -> Result_void;
		pub fn cv_face_FacemarkLBF_Params_feats_m(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkLBF_Params_setFeats_m_vector_int_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_face_FacemarkLBF_Params_radius_m(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_FacemarkLBF_Params_setRadius_m_vector_double_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_face_FacemarkLBF_Params_detectROI_const(instance: *mut c_void) -> Result<core::Rect>;
		pub fn cv_face_FacemarkLBF_Params_setDetectROI_Rect(instance: *mut c_void, val: *const core::Rect) -> Result_void;
		pub fn cv_face_FacemarkLBF_Params_Params() -> Result<*mut c_void>;
		pub fn cv_face_FacemarkLBF_Params_read_const_FileNodeX(instance: *mut c_void, unnamed: *mut c_void) -> Result_void;
		pub fn cv_face_FacemarkLBF_Params_write_const_FileStorageX(instance: *mut c_void, unnamed: *mut c_void) -> Result_void;
		pub fn cv_face_FacemarkTrain_addTrainingSample_const__InputArrayX_const__InputArrayX(instance: *mut c_void, image: *mut c_void, landmarks: *mut c_void) -> Result<bool>;
		pub fn cv_face_FacemarkTrain_training_voidX(instance: *mut c_void, parameters: *mut c_void) -> Result_void;
		pub fn cv_face_FacemarkTrain_setFaceDetector_FN_FaceDetector_voidX(instance: *mut c_void, detector: Option<extern "C" fn(*mut c_void, *mut c_void, *mut c_void) -> bool>, user_data: *mut c_void) -> Result<bool>;
		pub fn cv_face_FacemarkTrain_getFaces_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, image: *mut c_void, faces: *mut c_void) -> Result<bool>;
		pub fn cv_face_FacemarkTrain_getData_voidX(instance: *mut c_void, items: *mut c_void) -> Result<bool>;
		pub fn cv_face_FisherFaceRecognizer_create_int_double(num_components: i32, threshold: f64) -> Result<*mut c_void>;
		pub fn cv_face_LBPHFaceRecognizer_getGridX_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_face_LBPHFaceRecognizer_setGridX_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_face_LBPHFaceRecognizer_getGridY_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_face_LBPHFaceRecognizer_setGridY_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_face_LBPHFaceRecognizer_getRadius_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_face_LBPHFaceRecognizer_setRadius_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_face_LBPHFaceRecognizer_getNeighbors_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_face_LBPHFaceRecognizer_setNeighbors_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_face_LBPHFaceRecognizer_getThreshold_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_face_LBPHFaceRecognizer_setThreshold_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_face_LBPHFaceRecognizer_getHistograms_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_LBPHFaceRecognizer_getLabels_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_face_LBPHFaceRecognizer_create_int_int_int_int_double(radius: i32, neighbors: i32, grid_x: i32, grid_y: i32, threshold: f64) -> Result<*mut c_void>;
		pub fn cv_face_MACE_salt_const_StringX(instance: *mut c_void, passphrase: *const c_char) -> Result_void;
		pub fn cv_face_MACE_train_const__InputArrayX(instance: *mut c_void, images: *mut c_void) -> Result_void;
		pub fn cv_face_MACE_same_const_const__InputArrayX(instance: *mut c_void, query: *mut c_void) -> Result<bool>;
		pub fn cv_face_MACE_load_const_StringX_const_StringX(filename: *const c_char, objname: *const c_char) -> Result<*mut c_void>;
		pub fn cv_face_MACE_create_int(imgsize: i32) -> Result<*mut c_void>;
		pub fn cv_face_PredictCollector_init_size_t(instance: *mut c_void, size: size_t) -> Result_void;
		pub fn cv_face_PredictCollector_collect_int_double(instance: *mut c_void, label: i32, dist: f64) -> Result<bool>;
		pub fn cv_face_StandardCollector_StandardCollector_double(threshold_: f64) -> Result<*mut c_void>;
		pub fn cv_face_StandardCollector_init_size_t(instance: *mut c_void, size: size_t) -> Result_void;
		pub fn cv_face_StandardCollector_collect_int_double(instance: *mut c_void, label: i32, dist: f64) -> Result<bool>;
		pub fn cv_face_StandardCollector_getMinLabel_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_face_StandardCollector_getMinDist_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_face_StandardCollector_create_double(threshold: f64) -> Result<*mut c_void>;
		pub fn cv_face_StandardCollector_PredictResult_PredictResult_int_double(label_: i32, distance_: f64) -> Result<crate::face::StandardCollector_PredictResult>;
	}
}
#[cfg(feature = "contrib")]
pub use face_sys::*;

mod features2d_sys {
	use super::*;

	extern "C" {
		pub fn cv_AGAST_const__InputArrayX_vector_KeyPoint_X_int_bool(image: *mut c_void, keypoints: *mut c_void, threshold: i32, nonmax_suppression: bool) -> Result_void;
		pub fn cv_AGAST_const__InputArrayX_vector_KeyPoint_X_int_bool_DetectorType(image: *mut c_void, keypoints: *mut c_void, threshold: i32, nonmax_suppression: bool, typ: crate::features2d::AgastFeatureDetector_DetectorType) -> Result_void;
		pub fn cv_FAST_const__InputArrayX_vector_KeyPoint_X_int_bool(image: *mut c_void, keypoints: *mut c_void, threshold: i32, nonmax_suppression: bool) -> Result_void;
		pub fn cv_FAST_const__InputArrayX_vector_KeyPoint_X_int_bool_DetectorType(image: *mut c_void, keypoints: *mut c_void, threshold: i32, nonmax_suppression: bool, typ: crate::features2d::FastFeatureDetector_DetectorType) -> Result_void;
		pub fn cv_computeRecallPrecisionCurve_const_vector_vector_DMatch__X_const_vector_vector_unsigned_char__X_vector_Point2f_X(matches1to2: *mut c_void, correct_matches1to2_mask: *mut c_void, recall_precision_curve: *mut c_void) -> Result_void;
		pub fn cv_drawKeypoints_const__InputArrayX_const_vector_KeyPoint_X_const__InputOutputArrayX_const_ScalarX_DrawMatchesFlags(image: *mut c_void, keypoints: *mut c_void, out_image: *mut c_void, color: *const core::Scalar, flags: crate::features2d::DrawMatchesFlags) -> Result_void;
		pub fn cv_drawMatches_const__InputArrayX_const_vector_KeyPoint_X_const__InputArrayX_const_vector_KeyPoint_X_const_vector_DMatch_X_const__InputOutputArrayX_const_ScalarX_const_ScalarX_const_vector_char_X_DrawMatchesFlags(img1: *mut c_void, keypoints1: *mut c_void, img2: *mut c_void, keypoints2: *mut c_void, matches1to2: *mut c_void, out_img: *mut c_void, match_color: *const core::Scalar, single_point_color: *const core::Scalar, matches_mask: *mut c_void, flags: crate::features2d::DrawMatchesFlags) -> Result_void;
		pub fn cv_drawMatches_const__InputArrayX_const_vector_KeyPoint_X_const__InputArrayX_const_vector_KeyPoint_X_const_vector_vector_DMatch__X_const__InputOutputArrayX_const_ScalarX_const_ScalarX_const_vector_vector_char__X_DrawMatchesFlags(img1: *mut c_void, keypoints1: *mut c_void, img2: *mut c_void, keypoints2: *mut c_void, matches1to2: *mut c_void, out_img: *mut c_void, match_color: *const core::Scalar, single_point_color: *const core::Scalar, matches_mask: *mut c_void, flags: crate::features2d::DrawMatchesFlags) -> Result_void;
		pub fn cv_evaluateFeatureDetector_const_MatX_const_MatX_const_MatX_vector_KeyPoint_X_vector_KeyPoint_X_floatX_intX_const_Ptr_FeatureDetector_X(img1: *mut c_void, img2: *mut c_void, h1to2: *mut c_void, keypoints1: *mut c_void, keypoints2: *mut c_void, repeatability: *mut f32, corresp_count: *mut i32, fdetector: *mut c_void) -> Result_void;
		pub fn cv_getNearestPoint_const_vector_Point2f_X_float(recall_precision_curve: *mut c_void, l_precision: f32) -> Result<i32>;
		pub fn cv_getRecall_const_vector_Point2f_X_float(recall_precision_curve: *mut c_void, l_precision: f32) -> Result<f32>;
		pub fn cv_AKAZE_create_DescriptorType_int_int_float_int_int_DiffusivityType(descriptor_type: crate::features2d::AKAZE_DescriptorType, descriptor_size: i32, descriptor_channels: i32, threshold: f32, n_octaves: i32, n_octave_layers: i32, diffusivity: crate::features2d::KAZE_DiffusivityType) -> Result<*mut c_void>;
		pub fn cv_AKAZE_setDescriptorType_DescriptorType(instance: *mut c_void, dtype: crate::features2d::AKAZE_DescriptorType) -> Result_void;
		pub fn cv_AKAZE_getDescriptorType_const(instance: *mut c_void) -> Result<crate::features2d::AKAZE_DescriptorType>;
		pub fn cv_AKAZE_setDescriptorSize_int(instance: *mut c_void, dsize: i32) -> Result_void;
		pub fn cv_AKAZE_getDescriptorSize_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_AKAZE_setDescriptorChannels_int(instance: *mut c_void, dch: i32) -> Result_void;
		pub fn cv_AKAZE_getDescriptorChannels_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_AKAZE_setThreshold_double(instance: *mut c_void, threshold: f64) -> Result_void;
		pub fn cv_AKAZE_getThreshold_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_AKAZE_setNOctaves_int(instance: *mut c_void, octaves: i32) -> Result_void;
		pub fn cv_AKAZE_getNOctaves_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_AKAZE_setNOctaveLayers_int(instance: *mut c_void, octave_layers: i32) -> Result_void;
		pub fn cv_AKAZE_getNOctaveLayers_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_AKAZE_setDiffusivity_DiffusivityType(instance: *mut c_void, diff: crate::features2d::KAZE_DiffusivityType) -> Result_void;
		pub fn cv_AKAZE_getDiffusivity_const(instance: *mut c_void) -> Result<crate::features2d::KAZE_DiffusivityType>;
		pub fn cv_AKAZE_getDefaultName_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_AgastFeatureDetector_create_int_bool_DetectorType(threshold: i32, nonmax_suppression: bool, typ: crate::features2d::AgastFeatureDetector_DetectorType) -> Result<*mut c_void>;
		pub fn cv_AgastFeatureDetector_setThreshold_int(instance: *mut c_void, threshold: i32) -> Result_void;
		pub fn cv_AgastFeatureDetector_getThreshold_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_AgastFeatureDetector_setNonmaxSuppression_bool(instance: *mut c_void, f: bool) -> Result_void;
		pub fn cv_AgastFeatureDetector_getNonmaxSuppression_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_AgastFeatureDetector_setType_DetectorType(instance: *mut c_void, typ: crate::features2d::AgastFeatureDetector_DetectorType) -> Result_void;
		pub fn cv_AgastFeatureDetector_getType_const(instance: *mut c_void) -> Result<crate::features2d::AgastFeatureDetector_DetectorType>;
		pub fn cv_AgastFeatureDetector_getDefaultName_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_BFMatcher_BFMatcher_int_bool(norm_type: i32, cross_check: bool) -> Result<*mut c_void>;
		pub fn cv_BFMatcher_isMaskSupported_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_BFMatcher_create_int_bool(norm_type: i32, cross_check: bool) -> Result<*mut c_void>;
		pub fn cv_BFMatcher_clone_const_bool(instance: *mut c_void, empty_train_data: bool) -> Result<*mut c_void>;
		pub fn cv_BOWImgDescriptorExtractor_BOWImgDescriptorExtractor_const_Ptr_DescriptorExtractor_X_const_Ptr_DescriptorMatcher_X(dextractor: *mut c_void, dmatcher: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_BOWImgDescriptorExtractor_BOWImgDescriptorExtractor_const_Ptr_DescriptorMatcher_X(dmatcher: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_BOWImgDescriptorExtractor_setVocabulary_const_MatX(instance: *mut c_void, vocabulary: *mut c_void) -> Result_void;
		pub fn cv_BOWImgDescriptorExtractor_getVocabulary_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_BOWImgDescriptorExtractor_compute_const__InputArrayX_vector_KeyPoint_X_const__OutputArrayX_vector_vector_int__X_MatX(instance: *mut c_void, image: *mut c_void, keypoints: *mut c_void, img_descriptor: *mut c_void, point_idxs_of_clusters: *mut c_void, descriptors: *mut c_void) -> Result_void;
		pub fn cv_BOWImgDescriptorExtractor_compute_const__InputArrayX_const__OutputArrayX_vector_vector_int__X(instance: *mut c_void, keypoint_descriptors: *mut c_void, img_descriptor: *mut c_void, point_idxs_of_clusters: *mut c_void) -> Result_void;
		pub fn cv_BOWImgDescriptorExtractor_compute2_const_MatX_vector_KeyPoint_X_MatX(instance: *mut c_void, image: *mut c_void, keypoints: *mut c_void, img_descriptor: *mut c_void) -> Result_void;
		pub fn cv_BOWImgDescriptorExtractor_descriptorSize_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_BOWImgDescriptorExtractor_descriptorType_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_BOWKMeansTrainer_BOWKMeansTrainer_int_const_TermCriteriaX_int_int(cluster_count: i32, termcrit: *mut c_void, attempts: i32, flags: i32) -> Result<*mut c_void>;
		pub fn cv_BOWKMeansTrainer_cluster_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_BOWKMeansTrainer_cluster_const_const_MatX(instance: *mut c_void, descriptors: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_BOWTrainer_add_const_MatX(instance: *mut c_void, descriptors: *mut c_void) -> Result_void;
		pub fn cv_BOWTrainer_getDescriptors_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_BOWTrainer_descriptorsCount_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_BOWTrainer_clear(instance: *mut c_void) -> Result_void;
		pub fn cv_BOWTrainer_cluster_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_BOWTrainer_cluster_const_const_MatX(instance: *mut c_void, descriptors: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_BRISK_create_int_int_float(thresh: i32, octaves: i32, pattern_scale: f32) -> Result<*mut c_void>;
		pub fn cv_BRISK_create_const_vector_float_X_const_vector_int_X_float_float_const_vector_int_X(radius_list: *mut c_void, number_list: *mut c_void, d_max: f32, d_min: f32, index_change: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_BRISK_create_int_int_const_vector_float_X_const_vector_int_X_float_float_const_vector_int_X(thresh: i32, octaves: i32, radius_list: *mut c_void, number_list: *mut c_void, d_max: f32, d_min: f32, index_change: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_BRISK_getDefaultName_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_BRISK_setThreshold_int(instance: *mut c_void, threshold: i32) -> Result_void;
		pub fn cv_BRISK_getThreshold_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_BRISK_setOctaves_int(instance: *mut c_void, octaves: i32) -> Result_void;
		pub fn cv_BRISK_getOctaves_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_DescriptorMatcher_add_const__InputArrayX(instance: *mut c_void, descriptors: *mut c_void) -> Result_void;
		pub fn cv_DescriptorMatcher_getTrainDescriptors_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_DescriptorMatcher_clear(instance: *mut c_void) -> Result_void;
		pub fn cv_DescriptorMatcher_empty_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_DescriptorMatcher_isMaskSupported_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_DescriptorMatcher_train(instance: *mut c_void) -> Result_void;
		pub fn cv_DescriptorMatcher_match_const_const__InputArrayX_const__InputArrayX_vector_DMatch_X_const__InputArrayX(instance: *mut c_void, query_descriptors: *mut c_void, train_descriptors: *mut c_void, matches: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_DescriptorMatcher_knnMatch_const_const__InputArrayX_const__InputArrayX_vector_vector_DMatch__X_int_const__InputArrayX_bool(instance: *mut c_void, query_descriptors: *mut c_void, train_descriptors: *mut c_void, matches: *mut c_void, k: i32, mask: *mut c_void, compact_result: bool) -> Result_void;
		pub fn cv_DescriptorMatcher_radiusMatch_const_const__InputArrayX_const__InputArrayX_vector_vector_DMatch__X_float_const__InputArrayX_bool(instance: *mut c_void, query_descriptors: *mut c_void, train_descriptors: *mut c_void, matches: *mut c_void, max_distance: f32, mask: *mut c_void, compact_result: bool) -> Result_void;
		pub fn cv_DescriptorMatcher_match_const__InputArrayX_vector_DMatch_X_const__InputArrayX(instance: *mut c_void, query_descriptors: *mut c_void, matches: *mut c_void, masks: *mut c_void) -> Result_void;
		pub fn cv_DescriptorMatcher_knnMatch_const__InputArrayX_vector_vector_DMatch__X_int_const__InputArrayX_bool(instance: *mut c_void, query_descriptors: *mut c_void, matches: *mut c_void, k: i32, masks: *mut c_void, compact_result: bool) -> Result_void;
		pub fn cv_DescriptorMatcher_radiusMatch_const__InputArrayX_vector_vector_DMatch__X_float_const__InputArrayX_bool(instance: *mut c_void, query_descriptors: *mut c_void, matches: *mut c_void, max_distance: f32, masks: *mut c_void, compact_result: bool) -> Result_void;
		pub fn cv_DescriptorMatcher_write_const_const_StringX(instance: *mut c_void, file_name: *const c_char) -> Result_void;
		pub fn cv_DescriptorMatcher_read_const_StringX(instance: *mut c_void, file_name: *const c_char) -> Result_void;
		pub fn cv_DescriptorMatcher_read_const_FileNodeX(instance: *mut c_void, unnamed: *mut c_void) -> Result_void;
		pub fn cv_DescriptorMatcher_write_const_FileStorageX(instance: *mut c_void, unnamed: *mut c_void) -> Result_void;
		pub fn cv_DescriptorMatcher_clone_const_bool(instance: *mut c_void, empty_train_data: bool) -> Result<*mut c_void>;
		pub fn cv_DescriptorMatcher_create_const_StringX(descriptor_matcher_type: *const c_char) -> Result<*mut c_void>;
		pub fn cv_DescriptorMatcher_create_const_MatcherTypeX(matcher_type: *const crate::features2d::DescriptorMatcher_MatcherType) -> Result<*mut c_void>;
		pub fn cv_DescriptorMatcher_write_const_const_Ptr_FileStorage_X_const_StringX(instance: *mut c_void, fs: *mut c_void, name: *const c_char) -> Result_void;
		pub fn cv_FastFeatureDetector_create_int_bool_DetectorType(threshold: i32, nonmax_suppression: bool, typ: crate::features2d::FastFeatureDetector_DetectorType) -> Result<*mut c_void>;
		pub fn cv_FastFeatureDetector_setThreshold_int(instance: *mut c_void, threshold: i32) -> Result_void;
		pub fn cv_FastFeatureDetector_getThreshold_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_FastFeatureDetector_setNonmaxSuppression_bool(instance: *mut c_void, f: bool) -> Result_void;
		pub fn cv_FastFeatureDetector_getNonmaxSuppression_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_FastFeatureDetector_setType_DetectorType(instance: *mut c_void, typ: crate::features2d::FastFeatureDetector_DetectorType) -> Result_void;
		pub fn cv_FastFeatureDetector_getType_const(instance: *mut c_void) -> Result<crate::features2d::FastFeatureDetector_DetectorType>;
		pub fn cv_FastFeatureDetector_getDefaultName_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Feature2D_detect_const__InputArrayX_vector_KeyPoint_X_const__InputArrayX(instance: *mut c_void, image: *mut c_void, keypoints: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_Feature2D_detect_const__InputArrayX_vector_vector_KeyPoint__X_const__InputArrayX(instance: *mut c_void, images: *mut c_void, keypoints: *mut c_void, masks: *mut c_void) -> Result_void;
		pub fn cv_Feature2D_compute_const__InputArrayX_vector_KeyPoint_X_const__OutputArrayX(instance: *mut c_void, image: *mut c_void, keypoints: *mut c_void, descriptors: *mut c_void) -> Result_void;
		pub fn cv_Feature2D_compute_const__InputArrayX_vector_vector_KeyPoint__X_const__OutputArrayX(instance: *mut c_void, images: *mut c_void, keypoints: *mut c_void, descriptors: *mut c_void) -> Result_void;
		pub fn cv_Feature2D_detectAndCompute_const__InputArrayX_const__InputArrayX_vector_KeyPoint_X_const__OutputArrayX_bool(instance: *mut c_void, image: *mut c_void, mask: *mut c_void, keypoints: *mut c_void, descriptors: *mut c_void, use_provided_keypoints: bool) -> Result_void;
		pub fn cv_Feature2D_descriptorSize_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_Feature2D_descriptorType_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_Feature2D_defaultNorm_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_Feature2D_write_const_const_StringX(instance: *mut c_void, file_name: *const c_char) -> Result_void;
		pub fn cv_Feature2D_read_const_StringX(instance: *mut c_void, file_name: *const c_char) -> Result_void;
		pub fn cv_Feature2D_write_const_FileStorageX(instance: *mut c_void, unnamed: *mut c_void) -> Result_void;
		pub fn cv_Feature2D_read_const_FileNodeX(instance: *mut c_void, unnamed: *mut c_void) -> Result_void;
		pub fn cv_Feature2D_empty_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_Feature2D_getDefaultName_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Feature2D_write_const_const_Ptr_FileStorage_X_const_StringX(instance: *mut c_void, fs: *mut c_void, name: *const c_char) -> Result_void;
		pub fn cv_FlannBasedMatcher_FlannBasedMatcher_const_Ptr_IndexParams_X_const_Ptr_SearchParams_X(index_params: *mut c_void, search_params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_FlannBasedMatcher_add_const__InputArrayX(instance: *mut c_void, descriptors: *mut c_void) -> Result_void;
		pub fn cv_FlannBasedMatcher_clear(instance: *mut c_void) -> Result_void;
		pub fn cv_FlannBasedMatcher_read_const_FileNodeX(instance: *mut c_void, unnamed: *mut c_void) -> Result_void;
		pub fn cv_FlannBasedMatcher_write_const_FileStorageX(instance: *mut c_void, unnamed: *mut c_void) -> Result_void;
		pub fn cv_FlannBasedMatcher_train(instance: *mut c_void) -> Result_void;
		pub fn cv_FlannBasedMatcher_isMaskSupported_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_FlannBasedMatcher_create() -> Result<*mut c_void>;
		pub fn cv_FlannBasedMatcher_clone_const_bool(instance: *mut c_void, empty_train_data: bool) -> Result<*mut c_void>;
		pub fn cv_GFTTDetector_create_int_double_double_int_bool_double(max_corners: i32, quality_level: f64, min_distance: f64, block_size: i32, use_harris_detector: bool, k: f64) -> Result<*mut c_void>;
		pub fn cv_GFTTDetector_create_int_double_double_int_int_bool_double(max_corners: i32, quality_level: f64, min_distance: f64, block_size: i32, gradiant_size: i32, use_harris_detector: bool, k: f64) -> Result<*mut c_void>;
		pub fn cv_GFTTDetector_setMaxFeatures_int(instance: *mut c_void, max_features: i32) -> Result_void;
		pub fn cv_GFTTDetector_getMaxFeatures_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_GFTTDetector_setQualityLevel_double(instance: *mut c_void, qlevel: f64) -> Result_void;
		pub fn cv_GFTTDetector_getQualityLevel_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_GFTTDetector_setMinDistance_double(instance: *mut c_void, min_distance: f64) -> Result_void;
		pub fn cv_GFTTDetector_getMinDistance_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_GFTTDetector_setBlockSize_int(instance: *mut c_void, block_size: i32) -> Result_void;
		pub fn cv_GFTTDetector_getBlockSize_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_GFTTDetector_setHarrisDetector_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_GFTTDetector_getHarrisDetector_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_GFTTDetector_setK_double(instance: *mut c_void, k: f64) -> Result_void;
		pub fn cv_GFTTDetector_getK_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_GFTTDetector_getDefaultName_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_KAZE_create_bool_bool_float_int_int_DiffusivityType(extended: bool, upright: bool, threshold: f32, n_octaves: i32, n_octave_layers: i32, diffusivity: crate::features2d::KAZE_DiffusivityType) -> Result<*mut c_void>;
		pub fn cv_KAZE_setExtended_bool(instance: *mut c_void, extended: bool) -> Result_void;
		pub fn cv_KAZE_getExtended_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_KAZE_setUpright_bool(instance: *mut c_void, upright: bool) -> Result_void;
		pub fn cv_KAZE_getUpright_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_KAZE_setThreshold_double(instance: *mut c_void, threshold: f64) -> Result_void;
		pub fn cv_KAZE_getThreshold_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_KAZE_setNOctaves_int(instance: *mut c_void, octaves: i32) -> Result_void;
		pub fn cv_KAZE_getNOctaves_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_KAZE_setNOctaveLayers_int(instance: *mut c_void, octave_layers: i32) -> Result_void;
		pub fn cv_KAZE_getNOctaveLayers_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_KAZE_setDiffusivity_DiffusivityType(instance: *mut c_void, diff: crate::features2d::KAZE_DiffusivityType) -> Result_void;
		pub fn cv_KAZE_getDiffusivity_const(instance: *mut c_void) -> Result<crate::features2d::KAZE_DiffusivityType>;
		pub fn cv_KAZE_getDefaultName_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_KeyPointsFilter_KeyPointsFilter() -> Result<*mut c_void>;
		pub fn cv_KeyPointsFilter_runByImageBorder_vector_KeyPoint_X_Size_int(keypoints: *mut c_void, image_size: *const core::Size, border_size: i32) -> Result_void;
		pub fn cv_KeyPointsFilter_runByKeypointSize_vector_KeyPoint_X_float_float(keypoints: *mut c_void, min_size: f32, max_size: f32) -> Result_void;
		pub fn cv_KeyPointsFilter_runByPixelsMask_vector_KeyPoint_X_const_MatX(keypoints: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_KeyPointsFilter_removeDuplicated_vector_KeyPoint_X(keypoints: *mut c_void) -> Result_void;
		pub fn cv_KeyPointsFilter_removeDuplicatedSorted_vector_KeyPoint_X(keypoints: *mut c_void) -> Result_void;
		pub fn cv_KeyPointsFilter_retainBest_vector_KeyPoint_X_int(keypoints: *mut c_void, npoints: i32) -> Result_void;
		pub fn cv_MSER_create_int_int_int_double_double_int_double_double_int(_delta: i32, _min_area: i32, _max_area: i32, _max_variation: f64, _min_diversity: f64, _max_evolution: i32, _area_threshold: f64, _min_margin: f64, _edge_blur_size: i32) -> Result<*mut c_void>;
		pub fn cv_MSER_detectRegions_const__InputArrayX_vector_vector_Point__X_vector_Rect_X(instance: *mut c_void, image: *mut c_void, msers: *mut c_void, bboxes: *mut c_void) -> Result_void;
		pub fn cv_MSER_setDelta_int(instance: *mut c_void, delta: i32) -> Result_void;
		pub fn cv_MSER_getDelta_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_MSER_setMinArea_int(instance: *mut c_void, min_area: i32) -> Result_void;
		pub fn cv_MSER_getMinArea_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_MSER_setMaxArea_int(instance: *mut c_void, max_area: i32) -> Result_void;
		pub fn cv_MSER_getMaxArea_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_MSER_setPass2Only_bool(instance: *mut c_void, f: bool) -> Result_void;
		pub fn cv_MSER_getPass2Only_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_MSER_getDefaultName_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ORB_kBytes_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ORB_create_int_float_int_int_int_int_ScoreType_int_int(nfeatures: i32, scale_factor: f32, nlevels: i32, edge_threshold: i32, first_level: i32, wta_k: i32, score_type: crate::features2d::ORB_ScoreType, patch_size: i32, fast_threshold: i32) -> Result<*mut c_void>;
		pub fn cv_ORB_setMaxFeatures_int(instance: *mut c_void, max_features: i32) -> Result_void;
		pub fn cv_ORB_getMaxFeatures_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ORB_setScaleFactor_double(instance: *mut c_void, scale_factor: f64) -> Result_void;
		pub fn cv_ORB_getScaleFactor_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ORB_setNLevels_int(instance: *mut c_void, nlevels: i32) -> Result_void;
		pub fn cv_ORB_getNLevels_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ORB_setEdgeThreshold_int(instance: *mut c_void, edge_threshold: i32) -> Result_void;
		pub fn cv_ORB_getEdgeThreshold_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ORB_setFirstLevel_int(instance: *mut c_void, first_level: i32) -> Result_void;
		pub fn cv_ORB_getFirstLevel_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ORB_setWTA_K_int(instance: *mut c_void, wta_k: i32) -> Result_void;
		pub fn cv_ORB_getWTA_K_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ORB_setScoreType_ScoreType(instance: *mut c_void, score_type: crate::features2d::ORB_ScoreType) -> Result_void;
		pub fn cv_ORB_getScoreType_const(instance: *mut c_void) -> Result<crate::features2d::ORB_ScoreType>;
		pub fn cv_ORB_setPatchSize_int(instance: *mut c_void, patch_size: i32) -> Result_void;
		pub fn cv_ORB_getPatchSize_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ORB_setFastThreshold_int(instance: *mut c_void, fast_threshold: i32) -> Result_void;
		pub fn cv_ORB_getFastThreshold_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ORB_getDefaultName_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_SimpleBlobDetector_create_const_ParamsX(parameters: *const crate::features2d::SimpleBlobDetector_Params) -> Result<*mut c_void>;
		pub fn cv_SimpleBlobDetector_getDefaultName_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_SimpleBlobDetector_Params_Params() -> Result<crate::features2d::SimpleBlobDetector_Params>;
		pub fn cv_SimpleBlobDetector_Params_read_const_FileNodeX(instance: *const crate::features2d::SimpleBlobDetector_Params, fn_: *mut c_void) -> Result_void;
		pub fn cv_SimpleBlobDetector_Params_write_const_FileStorageX(instance: *const crate::features2d::SimpleBlobDetector_Params, fs: *mut c_void) -> Result_void;
	}
}
pub use features2d_sys::*;

mod flann_sys {
	use super::*;

	extern "C" {
		pub fn cvflann_flann_distance_type() -> Result<crate::flann::flann_distance_t>;
		pub fn cvflann_set_distance_type_flann_distance_t_int(distance_type: crate::flann::flann_distance_t, order: i32) -> Result_void;
		pub fn cv_flann_AutotunedIndexParams_AutotunedIndexParams_float_float_float_float(target_precision: f32, build_weight: f32, memory_weight: f32, sample_fraction: f32) -> Result<*mut c_void>;
		pub fn cv_flann_CompositeIndexParams_CompositeIndexParams_int_int_int_flann_centers_init_t_float(trees: i32, branching: i32, iterations: i32, centers_init: crate::flann::flann_centers_init_t, cb_index: f32) -> Result<*mut c_void>;
		pub fn cv_flann_HierarchicalClusteringIndexParams_HierarchicalClusteringIndexParams_int_flann_centers_init_t_int_int(branching: i32, centers_init: crate::flann::flann_centers_init_t, trees: i32, leaf_size: i32) -> Result<*mut c_void>;
		pub fn cv_flann_Index_Index() -> Result<*mut c_void>;
		pub fn cv_flann_Index_Index_const__InputArrayX_const_IndexParamsX_flann_distance_t(features: *mut c_void, params: *mut c_void, dist_type: crate::flann::flann_distance_t) -> Result<*mut c_void>;
		pub fn cv_flann_Index_build_const__InputArrayX_const_IndexParamsX_flann_distance_t(instance: *mut c_void, features: *mut c_void, params: *mut c_void, dist_type: crate::flann::flann_distance_t) -> Result_void;
		pub fn cv_flann_Index_knnSearch_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_int_const_SearchParamsX(instance: *mut c_void, query: *mut c_void, indices: *mut c_void, dists: *mut c_void, knn: i32, params: *mut c_void) -> Result_void;
		pub fn cv_flann_Index_radiusSearch_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_double_int_const_SearchParamsX(instance: *mut c_void, query: *mut c_void, indices: *mut c_void, dists: *mut c_void, radius: f64, max_results: i32, params: *mut c_void) -> Result<i32>;
		pub fn cv_flann_Index_save_const_const_StringX(instance: *mut c_void, filename: *const c_char) -> Result_void;
		pub fn cv_flann_Index_load_const__InputArrayX_const_StringX(instance: *mut c_void, features: *mut c_void, filename: *const c_char) -> Result<bool>;
		pub fn cv_flann_Index_release(instance: *mut c_void) -> Result_void;
		pub fn cv_flann_Index_getDistance_const(instance: *mut c_void) -> Result<crate::flann::flann_distance_t>;
		pub fn cv_flann_Index_getAlgorithm_const(instance: *mut c_void) -> Result<crate::flann::flann_algorithm_t>;
		pub fn cv_flann_IndexParams_params(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_flann_IndexParams_setParams_voidX(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_flann_IndexParams_IndexParams() -> Result<*mut c_void>;
		pub fn cv_flann_IndexParams_getString_const_const_StringX_const_StringX(instance: *mut c_void, key: *const c_char, default_val: *const c_char) -> Result<*mut c_void>;
		pub fn cv_flann_IndexParams_getInt_const_const_StringX_int(instance: *mut c_void, key: *const c_char, default_val: i32) -> Result<i32>;
		pub fn cv_flann_IndexParams_getDouble_const_const_StringX_double(instance: *mut c_void, key: *const c_char, default_val: f64) -> Result<f64>;
		pub fn cv_flann_IndexParams_setString_const_StringX_const_StringX(instance: *mut c_void, key: *const c_char, value: *const c_char) -> Result_void;
		pub fn cv_flann_IndexParams_setInt_const_StringX_int(instance: *mut c_void, key: *const c_char, value: i32) -> Result_void;
		pub fn cv_flann_IndexParams_setDouble_const_StringX_double(instance: *mut c_void, key: *const c_char, value: f64) -> Result_void;
		pub fn cv_flann_IndexParams_setFloat_const_StringX_float(instance: *mut c_void, key: *const c_char, value: f32) -> Result_void;
		pub fn cv_flann_IndexParams_setBool_const_StringX_bool(instance: *mut c_void, key: *const c_char, value: bool) -> Result_void;
		pub fn cv_flann_IndexParams_setAlgorithm_int(instance: *mut c_void, value: i32) -> Result_void;
		pub fn cv_flann_IndexParams_getAll_const_vector_String_X_vector_FlannIndexType_X_vector_String_X_vector_double_X(instance: *mut c_void, names: *mut c_void, types: *mut c_void, str_values: *mut c_void, num_values: *mut c_void) -> Result_void;
		pub fn cv_flann_KDTreeIndexParams_KDTreeIndexParams_int(trees: i32) -> Result<*mut c_void>;
		pub fn cv_flann_KMeansIndexParams_KMeansIndexParams_int_int_flann_centers_init_t_float(branching: i32, iterations: i32, centers_init: crate::flann::flann_centers_init_t, cb_index: f32) -> Result<*mut c_void>;
		pub fn cv_flann_LinearIndexParams_LinearIndexParams() -> Result<*mut c_void>;
		pub fn cv_flann_LshIndexParams_LshIndexParams_int_int_int(table_number: i32, key_size: i32, multi_probe_level: i32) -> Result<*mut c_void>;
		pub fn cv_flann_SavedIndexParams_SavedIndexParams_const_StringX(filename: *const c_char) -> Result<*mut c_void>;
		pub fn cv_flann_SearchParams_SearchParams_int_float_bool(checks: i32, eps: f32, sorted: bool) -> Result<*mut c_void>;
	}
}
pub use flann_sys::*;

#[cfg(feature = "contrib")]
mod freetype_sys {
	use super::*;

	extern "C" {
		pub fn cv_freetype_createFreeType2() -> Result<*mut c_void>;
		pub fn cv_freetype_FreeType2_loadFontData_String_int(instance: *mut c_void, font_file_name: *mut c_char, id: i32) -> Result_void;
		pub fn cv_freetype_FreeType2_setSplitNumber_int(instance: *mut c_void, num: i32) -> Result_void;
		pub fn cv_freetype_FreeType2_putText_const__InputOutputArrayX_const_StringX_Point_int_Scalar_int_int_bool(instance: *mut c_void, img: *mut c_void, text: *const c_char, org: *const core::Point, font_height: i32, color: *const core::Scalar, thickness: i32, line_type: i32, bottom_left_origin: bool) -> Result_void;
		pub fn cv_freetype_FreeType2_getTextSize_const_StringX_int_int_intX(instance: *mut c_void, text: *const c_char, font_height: i32, thickness: i32, base_line: *mut i32) -> Result<core::Size>;
	}
}
#[cfg(feature = "contrib")]
pub use freetype_sys::*;

#[cfg(feature = "contrib")]
mod fuzzy_sys {
	use super::*;

	extern "C" {
		pub fn cv_ft_FT02D_FL_process_const__InputArrayX_int_const__OutputArrayX(matrix: *mut c_void, radius: i32, output: *mut c_void) -> Result_void;
		pub fn cv_ft_FT02D_FL_process_float_const__InputArrayX_int_const__OutputArrayX(matrix: *mut c_void, radius: i32, output: *mut c_void) -> Result_void;
		pub fn cv_ft_FT02D_components_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__InputArrayX(matrix: *mut c_void, kernel: *mut c_void, components: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_ft_FT02D_inverseFT_const__InputArrayX_const__InputArrayX_const__OutputArrayX_int_int(components: *mut c_void, kernel: *mut c_void, output: *mut c_void, width: i32, height: i32) -> Result_void;
		pub fn cv_ft_FT02D_iteration_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__InputArrayX_const__OutputArrayX_bool(matrix: *mut c_void, kernel: *mut c_void, output: *mut c_void, mask: *mut c_void, mask_output: *mut c_void, first_stop: bool) -> Result<i32>;
		pub fn cv_ft_FT02D_process_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__InputArrayX(matrix: *mut c_void, kernel: *mut c_void, output: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_ft_FT12D_components_const__InputArrayX_const__InputArrayX_const__OutputArrayX(matrix: *mut c_void, kernel: *mut c_void, components: *mut c_void) -> Result_void;
		pub fn cv_ft_FT12D_createPolynomMatrixHorizontal_int_const__OutputArrayX_int(radius: i32, matrix: *mut c_void, chn: i32) -> Result_void;
		pub fn cv_ft_FT12D_createPolynomMatrixVertical_int_const__OutputArrayX_int(radius: i32, matrix: *mut c_void, chn: i32) -> Result_void;
		pub fn cv_ft_FT12D_inverseFT_const__InputArrayX_const__InputArrayX_const__OutputArrayX_int_int(components: *mut c_void, kernel: *mut c_void, output: *mut c_void, width: i32, height: i32) -> Result_void;
		pub fn cv_ft_FT12D_polynomial_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__InputArrayX(matrix: *mut c_void, kernel: *mut c_void, c00: *mut c_void, c10: *mut c_void, c01: *mut c_void, components: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_ft_FT12D_process_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__InputArrayX(matrix: *mut c_void, kernel: *mut c_void, output: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_ft_createKernel_const__InputArrayX_const__InputArrayX_const__OutputArrayX_int(a: *mut c_void, b: *mut c_void, kernel: *mut c_void, chn: i32) -> Result_void;
		pub fn cv_ft_createKernel_int_int_const__OutputArrayX_int(function: i32, radius: i32, kernel: *mut c_void, chn: i32) -> Result_void;
		pub fn cv_ft_filter_const__InputArrayX_const__InputArrayX_const__OutputArrayX(image: *mut c_void, kernel: *mut c_void, output: *mut c_void) -> Result_void;
		pub fn cv_ft_inpaint_const__InputArrayX_const__InputArrayX_const__OutputArrayX_int_int_int(image: *mut c_void, mask: *mut c_void, output: *mut c_void, radius: i32, function: i32, algorithm: i32) -> Result_void;
	}
}
#[cfg(feature = "contrib")]
pub use fuzzy_sys::*;

#[cfg(feature = "contrib")]
mod hdf_sys {
	use super::*;

	extern "C" {
		pub fn cv_hdf_open_const_StringX(hdf5_filename: *const c_char) -> Result<*mut c_void>;
		pub fn cv_hdf_HDF5_close(instance: *mut c_void) -> Result_void;
		pub fn cv_hdf_HDF5_grcreate_const_StringX(instance: *mut c_void, grlabel: *const c_char) -> Result_void;
		pub fn cv_hdf_HDF5_hlexists_const_const_StringX(instance: *mut c_void, label: *const c_char) -> Result<bool>;
		pub fn cv_hdf_HDF5_atexists_const_const_StringX(instance: *mut c_void, atlabel: *const c_char) -> Result<bool>;
		pub fn cv_hdf_HDF5_atdelete_const_StringX(instance: *mut c_void, atlabel: *const c_char) -> Result_void;
		pub fn cv_hdf_HDF5_atwrite_int_const_StringX(instance: *mut c_void, value: i32, atlabel: *const c_char) -> Result_void;
		pub fn cv_hdf_HDF5_atread_intX_const_StringX(instance: *mut c_void, value: *mut i32, atlabel: *const c_char) -> Result_void;
		pub fn cv_hdf_HDF5_atwrite_double_const_StringX(instance: *mut c_void, value: f64, atlabel: *const c_char) -> Result_void;
		pub fn cv_hdf_HDF5_atread_doubleX_const_StringX(instance: *mut c_void, value: *mut f64, atlabel: *const c_char) -> Result_void;
		pub fn cv_hdf_HDF5_atwrite_const_StringX_const_StringX(instance: *mut c_void, value: *const c_char, atlabel: *const c_char) -> Result_void;
		pub fn cv_hdf_HDF5_atread_StringX_const_StringX(instance: *mut c_void, value: *mut *mut c_void, atlabel: *const c_char) -> Result_void;
		pub fn cv_hdf_HDF5_atwrite_const__InputArrayX_const_StringX(instance: *mut c_void, value: *mut c_void, atlabel: *const c_char) -> Result_void;
		pub fn cv_hdf_HDF5_atread_const__OutputArrayX_const_StringX(instance: *mut c_void, value: *mut c_void, atlabel: *const c_char) -> Result_void;
		pub fn cv_hdf_HDF5_dscreate_const_int_int_int_const_StringX(instance: *mut c_void, rows: i32, cols: i32, typ: i32, dslabel: *const c_char) -> Result_void;
		pub fn cv_hdf_HDF5_dscreate_const_int_int_int_const_StringX_int(instance: *mut c_void, rows: i32, cols: i32, typ: i32, dslabel: *const c_char, compresslevel: i32) -> Result_void;
		pub fn cv_hdf_HDF5_dscreate_const_int_int_int_const_StringX_int_const_vector_int_X(instance: *mut c_void, rows: i32, cols: i32, typ: i32, dslabel: *const c_char, compresslevel: i32, dims_chunks: *mut c_void) -> Result_void;
		pub fn cv_hdf_HDF5_dscreate_const_int_int_int_const_StringX_int_const_intX(instance: *mut c_void, rows: i32, cols: i32, typ: i32, dslabel: *const c_char, compresslevel: i32, dims_chunks: *const i32) -> Result_void;
		pub fn cv_hdf_HDF5_dscreate_const_int_const_intX_int_const_StringX(instance: *mut c_void, n_dims: i32, sizes: *const i32, typ: i32, dslabel: *const c_char) -> Result_void;
		pub fn cv_hdf_HDF5_dscreate_const_int_const_intX_int_const_StringX_int(instance: *mut c_void, n_dims: i32, sizes: *const i32, typ: i32, dslabel: *const c_char, compresslevel: i32) -> Result_void;
		pub fn cv_hdf_HDF5_dscreate_const_const_vector_int_X_int_const_StringX_int_const_vector_int_X(instance: *mut c_void, sizes: *mut c_void, typ: i32, dslabel: *const c_char, compresslevel: i32, dims_chunks: *mut c_void) -> Result_void;
		pub fn cv_hdf_HDF5_dscreate_const_int_const_intX_int_const_StringX_int_const_intX(instance: *mut c_void, n_dims: i32, sizes: *const i32, typ: i32, dslabel: *const c_char, compresslevel: i32, dims_chunks: *const i32) -> Result_void;
		pub fn cv_hdf_HDF5_dsgetsize_const_const_StringX_int(instance: *mut c_void, dslabel: *const c_char, dims_flag: i32) -> Result<*mut c_void>;
		pub fn cv_hdf_HDF5_dsgettype_const_const_StringX(instance: *mut c_void, dslabel: *const c_char) -> Result<i32>;
		pub fn cv_hdf_HDF5_dswrite_const_const__InputArrayX_const_StringX(instance: *mut c_void, array: *mut c_void, dslabel: *const c_char) -> Result_void;
		pub fn cv_hdf_HDF5_dswrite_const_const__InputArrayX_const_StringX_const_intX(instance: *mut c_void, array: *mut c_void, dslabel: *const c_char, dims_offset: *const i32) -> Result_void;
		pub fn cv_hdf_HDF5_dswrite_const_const__InputArrayX_const_StringX_const_vector_int_X_const_vector_int_X(instance: *mut c_void, array: *mut c_void, dslabel: *const c_char, dims_offset: *mut c_void, dims_counts: *mut c_void) -> Result_void;
		pub fn cv_hdf_HDF5_dswrite_const_const__InputArrayX_const_StringX_const_intX_const_intX(instance: *mut c_void, array: *mut c_void, dslabel: *const c_char, dims_offset: *const i32, dims_counts: *const i32) -> Result_void;
		pub fn cv_hdf_HDF5_dsinsert_const_const__InputArrayX_const_StringX(instance: *mut c_void, array: *mut c_void, dslabel: *const c_char) -> Result_void;
		pub fn cv_hdf_HDF5_dsinsert_const_const__InputArrayX_const_StringX_const_intX(instance: *mut c_void, array: *mut c_void, dslabel: *const c_char, dims_offset: *const i32) -> Result_void;
		pub fn cv_hdf_HDF5_dsinsert_const_const__InputArrayX_const_StringX_const_vector_int_X_const_vector_int_X(instance: *mut c_void, array: *mut c_void, dslabel: *const c_char, dims_offset: *mut c_void, dims_counts: *mut c_void) -> Result_void;
		pub fn cv_hdf_HDF5_dsinsert_const_const__InputArrayX_const_StringX_const_intX_const_intX(instance: *mut c_void, array: *mut c_void, dslabel: *const c_char, dims_offset: *const i32, dims_counts: *const i32) -> Result_void;
		pub fn cv_hdf_HDF5_dsread_const_const__OutputArrayX_const_StringX(instance: *mut c_void, array: *mut c_void, dslabel: *const c_char) -> Result_void;
		pub fn cv_hdf_HDF5_dsread_const_const__OutputArrayX_const_StringX_const_intX(instance: *mut c_void, array: *mut c_void, dslabel: *const c_char, dims_offset: *const i32) -> Result_void;
		pub fn cv_hdf_HDF5_dsread_const_const__OutputArrayX_const_StringX_const_vector_int_X_const_vector_int_X(instance: *mut c_void, array: *mut c_void, dslabel: *const c_char, dims_offset: *mut c_void, dims_counts: *mut c_void) -> Result_void;
		pub fn cv_hdf_HDF5_dsread_const_const__OutputArrayX_const_StringX_const_intX_const_intX(instance: *mut c_void, array: *mut c_void, dslabel: *const c_char, dims_offset: *const i32, dims_counts: *const i32) -> Result_void;
		pub fn cv_hdf_HDF5_kpgetsize_const_const_StringX_int(instance: *mut c_void, kplabel: *const c_char, dims_flag: i32) -> Result<i32>;
		pub fn cv_hdf_HDF5_kpcreate_const_int_const_StringX_int_int(instance: *mut c_void, size: i32, kplabel: *const c_char, compresslevel: i32, chunks: i32) -> Result_void;
		pub fn cv_hdf_HDF5_kpwrite_const_vector_KeyPoint__const_StringX_int_int(instance: *mut c_void, keypoints: *mut c_void, kplabel: *const c_char, offset: i32, counts: i32) -> Result_void;
		pub fn cv_hdf_HDF5_kpinsert_const_vector_KeyPoint__const_StringX_int_int(instance: *mut c_void, keypoints: *mut c_void, kplabel: *const c_char, offset: i32, counts: i32) -> Result_void;
		pub fn cv_hdf_HDF5_kpread_const_vector_KeyPoint_X_const_StringX_int_int(instance: *mut c_void, keypoints: *mut c_void, kplabel: *const c_char, offset: i32, counts: i32) -> Result_void;
	}
}
#[cfg(feature = "contrib")]
pub use hdf_sys::*;

mod highgui_sys {
	use super::*;

	extern "C" {
		pub fn cv_addText_const_MatX_const_StringX_Point_const_QtFontX(img: *mut c_void, text: *const c_char, org: *const core::Point, font: *mut c_void) -> Result_void;
		pub fn cv_addText_const_MatX_const_StringX_Point_const_StringX_int_Scalar_int_int_int(img: *mut c_void, text: *const c_char, org: *const core::Point, name_font: *const c_char, point_size: i32, color: *const core::Scalar, weight: i32, style: i32, spacing: i32) -> Result_void;
		pub fn cv_createButton_const_StringX_ButtonCallback_voidX_int_bool(bar_name: *const c_char, on_change: Option<extern "C" fn(i32, *mut c_void) -> ()>, userdata: *mut c_void, typ: i32, initial_button_state: bool) -> Result<i32>;
		pub fn cv_createTrackbar_const_StringX_const_StringX_intX_int_TrackbarCallback_voidX(trackbarname: *const c_char, winname: *const c_char, value: *mut i32, count: i32, on_change: Option<extern "C" fn(i32, *mut c_void) -> ()>, userdata: *mut c_void) -> Result<i32>;
		pub fn cv_destroyAllWindows() -> Result_void;
		pub fn cv_destroyWindow_const_StringX(winname: *const c_char) -> Result_void;
		pub fn cv_displayOverlay_const_StringX_const_StringX_int(winname: *const c_char, text: *const c_char, delayms: i32) -> Result_void;
		pub fn cv_displayStatusBar_const_StringX_const_StringX_int(winname: *const c_char, text: *const c_char, delayms: i32) -> Result_void;
		pub fn cv_fontQt_const_StringX_int_Scalar_int_int_int(name_font: *const c_char, point_size: i32, color: *const core::Scalar, weight: i32, style: i32, spacing: i32) -> Result<*mut c_void>;
		pub fn cv_getMouseWheelDelta_int(flags: i32) -> Result<i32>;
		pub fn cv_getTrackbarPos_const_StringX_const_StringX(trackbarname: *const c_char, winname: *const c_char) -> Result<i32>;
		pub fn cv_getWindowImageRect_const_StringX(winname: *const c_char) -> Result<core::Rect>;
		pub fn cv_getWindowProperty_const_StringX_int(winname: *const c_char, prop_id: i32) -> Result<f64>;
		pub fn cv_imshow_const_StringX_const__InputArrayX(winname: *const c_char, mat: *mut c_void) -> Result_void;
		pub fn cv_loadWindowParameters_const_StringX(window_name: *const c_char) -> Result_void;
		pub fn cv_moveWindow_const_StringX_int_int(winname: *const c_char, x: i32, y: i32) -> Result_void;
		pub fn cv_namedWindow_const_StringX_int(winname: *const c_char, flags: i32) -> Result_void;
		pub fn cv_resizeWindow_const_StringX_const_SizeX(winname: *const c_char, size: *const core::Size) -> Result_void;
		pub fn cv_resizeWindow_const_StringX_int_int(winname: *const c_char, width: i32, height: i32) -> Result_void;
		pub fn cv_saveWindowParameters_const_StringX(window_name: *const c_char) -> Result_void;
		pub fn cv_selectROI_const_StringX_const__InputArrayX_bool_bool(window_name: *const c_char, img: *mut c_void, show_crosshair: bool, from_center: bool) -> Result<core::Rect>;
		pub fn cv_selectROI_const__InputArrayX_bool_bool(img: *mut c_void, show_crosshair: bool, from_center: bool) -> Result<core::Rect>;
		pub fn cv_selectROIs_const_StringX_const__InputArrayX_vector_Rect_X_bool_bool(window_name: *const c_char, img: *mut c_void, bounding_boxes: *mut c_void, show_crosshair: bool, from_center: bool) -> Result_void;
		pub fn cv_setMouseCallback_const_StringX_MouseCallback_voidX(winname: *const c_char, on_mouse: Option<extern "C" fn(i32, i32, i32, i32, *mut c_void) -> ()>, userdata: *mut c_void) -> Result_void;
		pub fn cv_setOpenGlContext_const_StringX(winname: *const c_char) -> Result_void;
		pub fn cv_setOpenGlDrawCallback_const_StringX_OpenGlDrawCallback_voidX(winname: *const c_char, on_opengl_draw: Option<extern "C" fn(*mut c_void) -> ()>, userdata: *mut c_void) -> Result_void;
		pub fn cv_setTrackbarMax_const_StringX_const_StringX_int(trackbarname: *const c_char, winname: *const c_char, maxval: i32) -> Result_void;
		pub fn cv_setTrackbarMin_const_StringX_const_StringX_int(trackbarname: *const c_char, winname: *const c_char, minval: i32) -> Result_void;
		pub fn cv_setTrackbarPos_const_StringX_const_StringX_int(trackbarname: *const c_char, winname: *const c_char, pos: i32) -> Result_void;
		pub fn cv_setWindowProperty_const_StringX_int_double(winname: *const c_char, prop_id: i32, prop_value: f64) -> Result_void;
		pub fn cv_setWindowTitle_const_StringX_const_StringX(winname: *const c_char, title: *const c_char) -> Result_void;
		pub fn cv_startLoop_int__X__int__charXX__int_charXX(pt2_func: Option<extern "C" fn(i32, *mut *mut c_char) -> i32>, argc: i32, argv: *mut *mut c_char) -> Result<i32>;
		pub fn cv_startWindowThread() -> Result<i32>;
		pub fn cv_stopLoop() -> Result_void;
		pub fn cv_updateWindow_const_StringX(winname: *const c_char) -> Result_void;
		pub fn cv_waitKeyEx_int(delay: i32) -> Result<i32>;
		pub fn cv_waitKey_int(delay: i32) -> Result<i32>;
		pub fn cv_QtFont_nameFont_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_QtFont_color_const(instance: *mut c_void) -> Result<core::Scalar>;
		pub fn cv_QtFont_setColor_Scalar(instance: *mut c_void, val: *const core::Scalar) -> Result_void;
		pub fn cv_QtFont_font_face_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_QtFont_setFont_face_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_QtFont_ascii_const(instance: *mut c_void) -> Result<*const i32>;
		pub fn cv_QtFont_greek_const(instance: *mut c_void) -> Result<*const i32>;
		pub fn cv_QtFont_cyrillic_const(instance: *mut c_void) -> Result<*const i32>;
		pub fn cv_QtFont_hscale_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_QtFont_setHscale_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_QtFont_vscale_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_QtFont_setVscale_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_QtFont_shear_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_QtFont_setShear_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_QtFont_thickness_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_QtFont_setThickness_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_QtFont_dx_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_QtFont_setDx_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_QtFont_line_type_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_QtFont_setLine_type_int(instance: *mut c_void, val: i32) -> Result_void;
	}
}
pub use highgui_sys::*;

#[cfg(feature = "contrib")]
mod img_hash_sys {
	use super::*;

	extern "C" {
		pub fn cv_img_hash_averageHash_const__InputArrayX_const__OutputArrayX(input_arr: *mut c_void, output_arr: *mut c_void) -> Result_void;
		pub fn cv_img_hash_blockMeanHash_const__InputArrayX_const__OutputArrayX_int(input_arr: *mut c_void, output_arr: *mut c_void, mode: i32) -> Result_void;
		pub fn cv_img_hash_colorMomentHash_const__InputArrayX_const__OutputArrayX(input_arr: *mut c_void, output_arr: *mut c_void) -> Result_void;
		pub fn cv_img_hash_marrHildrethHash_const__InputArrayX_const__OutputArrayX_float_float(input_arr: *mut c_void, output_arr: *mut c_void, alpha: f32, scale: f32) -> Result_void;
		pub fn cv_img_hash_pHash_const__InputArrayX_const__OutputArrayX(input_arr: *mut c_void, output_arr: *mut c_void) -> Result_void;
		pub fn cv_img_hash_radialVarianceHash_const__InputArrayX_const__OutputArrayX_double_int(input_arr: *mut c_void, output_arr: *mut c_void, sigma: f64, num_of_angle_line: i32) -> Result_void;
		pub fn cv_img_hash_AverageHash_create() -> Result<*mut c_void>;
		pub fn cv_img_hash_BlockMeanHash_setMode_int(instance: *mut c_void, mode: i32) -> Result_void;
		pub fn cv_img_hash_BlockMeanHash_getMean_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_img_hash_BlockMeanHash_create_int(mode: i32) -> Result<*mut c_void>;
		pub fn cv_img_hash_ColorMomentHash_create() -> Result<*mut c_void>;
		pub fn cv_img_hash_ImgHashBase_compute_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, input_arr: *mut c_void, output_arr: *mut c_void) -> Result_void;
		pub fn cv_img_hash_ImgHashBase_compare_const_const__InputArrayX_const__InputArrayX(instance: *mut c_void, hash_one: *mut c_void, hash_two: *mut c_void) -> Result<f64>;
		pub fn cv_img_hash_MarrHildrethHash_getAlpha_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_img_hash_MarrHildrethHash_getScale_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_img_hash_MarrHildrethHash_setKernelParam_float_float(instance: *mut c_void, alpha: f32, scale: f32) -> Result_void;
		pub fn cv_img_hash_MarrHildrethHash_create_float_float(alpha: f32, scale: f32) -> Result<*mut c_void>;
		pub fn cv_img_hash_PHash_create() -> Result<*mut c_void>;
		pub fn cv_img_hash_RadialVarianceHash_create_double_int(sigma: f64, num_of_angle_line: i32) -> Result<*mut c_void>;
		pub fn cv_img_hash_RadialVarianceHash_getNumOfAngleLine_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_img_hash_RadialVarianceHash_getSigma_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_img_hash_RadialVarianceHash_setNumOfAngleLine_int(instance: *mut c_void, value: i32) -> Result_void;
		pub fn cv_img_hash_RadialVarianceHash_setSigma_double(instance: *mut c_void, value: f64) -> Result_void;
		pub fn cv_img_hash_RadialVarianceHash_getFeatures(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_img_hash_RadialVarianceHash_getHash(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_img_hash_RadialVarianceHash_getPixPerLine_const_MatX(instance: *mut c_void, input: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_img_hash_RadialVarianceHash_getProjection(instance: *mut c_void) -> Result<*mut c_void>;
	}
}
#[cfg(feature = "contrib")]
pub use img_hash_sys::*;

mod imgcodecs_sys {
	use super::*;

	extern "C" {
		pub fn cv_haveImageReader_const_StringX(filename: *const c_char) -> Result<bool>;
		pub fn cv_haveImageWriter_const_StringX(filename: *const c_char) -> Result<bool>;
		pub fn cv_imdecode_const__InputArrayX_int(buf: *mut c_void, flags: i32) -> Result<*mut c_void>;
		pub fn cv_imdecode_const__InputArrayX_int_MatX(buf: *mut c_void, flags: i32, dst: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_imencode_const_StringX_const__InputArrayX_vector_unsigned_char_X_const_vector_int_X(ext: *const c_char, img: *mut c_void, buf: *mut c_void, params: *mut c_void) -> Result<bool>;
		pub fn cv_imread_const_StringX_int(filename: *const c_char, flags: i32) -> Result<*mut c_void>;
		pub fn cv_imreadmulti_const_StringX_vector_Mat_X_int(filename: *const c_char, mats: *mut c_void, flags: i32) -> Result<bool>;
		pub fn cv_imwrite_const_StringX_const__InputArrayX_const_vector_int_X(filename: *const c_char, img: *mut c_void, params: *mut c_void) -> Result<bool>;
	}
}
pub use imgcodecs_sys::*;

mod imgproc_sys {
	use super::*;

	extern "C" {
		pub fn cv_Canny_const__InputArrayX_const__InputArrayX_const__OutputArrayX_double_double_bool(dx: *mut c_void, dy: *mut c_void, edges: *mut c_void, threshold1: f64, threshold2: f64, l2gradient: bool) -> Result_void;
		pub fn cv_Canny_const__InputArrayX_const__OutputArrayX_double_double_int_bool(image: *mut c_void, edges: *mut c_void, threshold1: f64, threshold2: f64, aperture_size: i32, l2gradient: bool) -> Result_void;
		pub fn cv_EMD_const__InputArrayX_const__InputArrayX_int_const__InputArrayX_floatX_const__OutputArrayX(signature1: *mut c_void, signature2: *mut c_void, dist_type: i32, cost: *mut c_void, lower_bound: *mut f32, flow: *mut c_void) -> Result<f32>;
		pub fn cv_GaussianBlur_const__InputArrayX_const__OutputArrayX_Size_double_double_int(src: *mut c_void, dst: *mut c_void, ksize: *const core::Size, sigma_x: f64, sigma_y: f64, border_type: i32) -> Result_void;
		pub fn cv_HoughCircles_const__InputArrayX_const__OutputArrayX_int_double_double_double_double_int_int(image: *mut c_void, circles: *mut c_void, method: i32, dp: f64, min_dist: f64, param1: f64, param2: f64, min_radius: i32, max_radius: i32) -> Result_void;
		pub fn cv_HoughLinesP_const__InputArrayX_const__OutputArrayX_double_double_int_double_double(image: *mut c_void, lines: *mut c_void, rho: f64, theta: f64, threshold: i32, min_line_length: f64, max_line_gap: f64) -> Result_void;
		pub fn cv_HoughLinesPointSet_const__InputArrayX_const__OutputArrayX_int_int_double_double_double_double_double_double(_point: *mut c_void, _lines: *mut c_void, lines_max: i32, threshold: i32, min_rho: f64, max_rho: f64, rho_step: f64, min_theta: f64, max_theta: f64, theta_step: f64) -> Result_void;
		pub fn cv_HoughLines_const__InputArrayX_const__OutputArrayX_double_double_int_double_double_double_double(image: *mut c_void, lines: *mut c_void, rho: f64, theta: f64, threshold: i32, srn: f64, stn: f64, min_theta: f64, max_theta: f64) -> Result_void;
		pub fn cv_HuMoments_const_MomentsX_const__OutputArrayX(m: *const core::Moments, hu: *mut c_void) -> Result_void;
		pub fn cv_HuMoments_const_MomentsX_double_X__7_(moments: *const core::Moments, hu: *mut [f64; 7]) -> Result_void;
		pub fn cv_Laplacian_const__InputArrayX_const__OutputArrayX_int_int_double_double_int(src: *mut c_void, dst: *mut c_void, ddepth: i32, ksize: i32, scale: f64, delta: f64, border_type: i32) -> Result_void;
		pub fn cv_Scharr_const__InputArrayX_const__OutputArrayX_int_int_int_double_double_int(src: *mut c_void, dst: *mut c_void, ddepth: i32, dx: i32, dy: i32, scale: f64, delta: f64, border_type: i32) -> Result_void;
		pub fn cv_Sobel_const__InputArrayX_const__OutputArrayX_int_int_int_int_double_double_int(src: *mut c_void, dst: *mut c_void, ddepth: i32, dx: i32, dy: i32, ksize: i32, scale: f64, delta: f64, border_type: i32) -> Result_void;
		pub fn cv_accumulateProduct_const__InputArrayX_const__InputArrayX_const__InputOutputArrayX_const__InputArrayX(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_accumulateSquare_const__InputArrayX_const__InputOutputArrayX_const__InputArrayX(src: *mut c_void, dst: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_accumulateWeighted_const__InputArrayX_const__InputOutputArrayX_double_const__InputArrayX(src: *mut c_void, dst: *mut c_void, alpha: f64, mask: *mut c_void) -> Result_void;
		pub fn cv_accumulate_const__InputArrayX_const__InputOutputArrayX_const__InputArrayX(src: *mut c_void, dst: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_adaptiveThreshold_const__InputArrayX_const__OutputArrayX_double_int_int_int_double(src: *mut c_void, dst: *mut c_void, max_value: f64, adaptive_method: i32, threshold_type: i32, block_size: i32, c: f64) -> Result_void;
		pub fn cv_applyColorMap_const__InputArrayX_const__OutputArrayX_const__InputArrayX(src: *mut c_void, dst: *mut c_void, user_color: *mut c_void) -> Result_void;
		pub fn cv_applyColorMap_const__InputArrayX_const__OutputArrayX_int(src: *mut c_void, dst: *mut c_void, colormap: i32) -> Result_void;
		pub fn cv_approxPolyDP_const__InputArrayX_const__OutputArrayX_double_bool(curve: *mut c_void, approx_curve: *mut c_void, epsilon: f64, closed: bool) -> Result_void;
		pub fn cv_arcLength_const__InputArrayX_bool(curve: *mut c_void, closed: bool) -> Result<f64>;
		pub fn cv_arrowedLine_const__InputOutputArrayX_Point_Point_const_ScalarX_int_int_int_double(img: *mut c_void, pt1: *const core::Point, pt2: *const core::Point, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32, tip_length: f64) -> Result_void;
		pub fn cv_bilateralFilter_const__InputArrayX_const__OutputArrayX_int_double_double_int(src: *mut c_void, dst: *mut c_void, d: i32, sigma_color: f64, sigma_space: f64, border_type: i32) -> Result_void;
		pub fn cv_blendLinear_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX(src1: *mut c_void, src2: *mut c_void, weights1: *mut c_void, weights2: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_blur_const__InputArrayX_const__OutputArrayX_Size_Point_int(src: *mut c_void, dst: *mut c_void, ksize: *const core::Size, anchor: *const core::Point, border_type: i32) -> Result_void;
		pub fn cv_boundingRect_const__InputArrayX(array: *mut c_void) -> Result<core::Rect>;
		pub fn cv_boxFilter_const__InputArrayX_const__OutputArrayX_int_Size_Point_bool_int(src: *mut c_void, dst: *mut c_void, ddepth: i32, ksize: *const core::Size, anchor: *const core::Point, normalize: bool, border_type: i32) -> Result_void;
		pub fn cv_boxPoints_RotatedRect_const__OutputArrayX(box_: *mut c_void, points: *mut c_void) -> Result_void;
		pub fn cv_buildPyramid_const__InputArrayX_const__OutputArrayX_int_int(src: *mut c_void, dst: *mut c_void, maxlevel: i32, border_type: i32) -> Result_void;
		pub fn cv_calcBackProject_const__InputArrayX_const_vector_int_X_const__InputArrayX_const__OutputArrayX_const_vector_float_X_double(images: *mut c_void, channels: *mut c_void, hist: *mut c_void, dst: *mut c_void, ranges: *mut c_void, scale: f64) -> Result_void;
		pub fn cv_calcHist_const__InputArrayX_const_vector_int_X_const__InputArrayX_const__OutputArrayX_const_vector_int_X_const_vector_float_X_bool(images: *mut c_void, channels: *mut c_void, mask: *mut c_void, hist: *mut c_void, hist_size: *mut c_void, ranges: *mut c_void, accumulate: bool) -> Result_void;
		pub fn cv_circle_const__InputOutputArrayX_Point_int_const_ScalarX_int_int_int(img: *mut c_void, center: *const core::Point, radius: i32, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32) -> Result_void;
		pub fn cv_clipLine_Rect_PointX_PointX(img_rect: *const core::Rect, pt1: *mut core::Point, pt2: *mut core::Point) -> Result<bool>;
		pub fn cv_clipLine_Size2l_Point2lX_Point2lX(img_size: *const core::Size2l, pt1: *mut core::Point2l, pt2: *mut core::Point2l) -> Result<bool>;
		pub fn cv_clipLine_Size_PointX_PointX(img_size: *const core::Size, pt1: *mut core::Point, pt2: *mut core::Point) -> Result<bool>;
		pub fn cv_compareHist_const_SparseMatX_const_SparseMatX_int(h1: *mut c_void, h2: *mut c_void, method: i32) -> Result<f64>;
		pub fn cv_compareHist_const__InputArrayX_const__InputArrayX_int(h1: *mut c_void, h2: *mut c_void, method: i32) -> Result<f64>;
		pub fn cv_connectedComponentsWithStats_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_int_int(image: *mut c_void, labels: *mut c_void, stats: *mut c_void, centroids: *mut c_void, connectivity: i32, ltype: i32) -> Result<i32>;
		pub fn cv_connectedComponentsWithStats_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_int_int_int(image: *mut c_void, labels: *mut c_void, stats: *mut c_void, centroids: *mut c_void, connectivity: i32, ltype: i32, ccltype: i32) -> Result<i32>;
		pub fn cv_connectedComponents_const__InputArrayX_const__OutputArrayX_int_int(image: *mut c_void, labels: *mut c_void, connectivity: i32, ltype: i32) -> Result<i32>;
		pub fn cv_connectedComponents_const__InputArrayX_const__OutputArrayX_int_int_int(image: *mut c_void, labels: *mut c_void, connectivity: i32, ltype: i32, ccltype: i32) -> Result<i32>;
		pub fn cv_contourArea_const__InputArrayX_bool(contour: *mut c_void, oriented: bool) -> Result<f64>;
		pub fn cv_convertMaps_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_int_bool(map1: *mut c_void, map2: *mut c_void, dstmap1: *mut c_void, dstmap2: *mut c_void, dstmap1type: i32, nninterpolation: bool) -> Result_void;
		pub fn cv_convexHull_const__InputArrayX_const__OutputArrayX_bool_bool(points: *mut c_void, hull: *mut c_void, clockwise: bool, return_points: bool) -> Result_void;
		pub fn cv_convexityDefects_const__InputArrayX_const__InputArrayX_const__OutputArrayX(contour: *mut c_void, convexhull: *mut c_void, convexity_defects: *mut c_void) -> Result_void;
		pub fn cv_cornerEigenValsAndVecs_const__InputArrayX_const__OutputArrayX_int_int_int(src: *mut c_void, dst: *mut c_void, block_size: i32, ksize: i32, border_type: i32) -> Result_void;
		pub fn cv_cornerHarris_const__InputArrayX_const__OutputArrayX_int_int_double_int(src: *mut c_void, dst: *mut c_void, block_size: i32, ksize: i32, k: f64, border_type: i32) -> Result_void;
		pub fn cv_cornerMinEigenVal_const__InputArrayX_const__OutputArrayX_int_int_int(src: *mut c_void, dst: *mut c_void, block_size: i32, ksize: i32, border_type: i32) -> Result_void;
		pub fn cv_cornerSubPix_const__InputArrayX_const__InputOutputArrayX_Size_Size_TermCriteria(image: *mut c_void, corners: *mut c_void, win_size: *const core::Size, zero_zone: *const core::Size, criteria: *mut c_void) -> Result_void;
		pub fn cv_createCLAHE_double_Size(clip_limit: f64, tile_grid_size: *const core::Size) -> Result<*mut c_void>;
		pub fn cv_createGeneralizedHoughBallard() -> Result<*mut c_void>;
		pub fn cv_createGeneralizedHoughGuil() -> Result<*mut c_void>;
		pub fn cv_createHanningWindow_const__OutputArrayX_Size_int(dst: *mut c_void, win_size: *const core::Size, typ: i32) -> Result_void;
		pub fn cv_createLineSegmentDetector_int_double_double_double_double_double_double_int(_refine: i32, _scale: f64, _sigma_scale: f64, _quant: f64, _ang_th: f64, _log_eps: f64, _density_th: f64, _n_bins: i32) -> Result<*mut c_void>;
		pub fn cv_cvtColorTwoPlane_const__InputArrayX_const__InputArrayX_const__OutputArrayX_int(src1: *mut c_void, src2: *mut c_void, dst: *mut c_void, code: i32) -> Result_void;
		pub fn cv_cvtColor_const__InputArrayX_const__OutputArrayX_int_int(src: *mut c_void, dst: *mut c_void, code: i32, dst_cn: i32) -> Result_void;
		pub fn cv_demosaicing_const__InputArrayX_const__OutputArrayX_int_int(src: *mut c_void, dst: *mut c_void, code: i32, dst_cn: i32) -> Result_void;
		pub fn cv_dilate_const__InputArrayX_const__OutputArrayX_const__InputArrayX_Point_int_int_const_ScalarX(src: *mut c_void, dst: *mut c_void, kernel: *mut c_void, anchor: *const core::Point, iterations: i32, border_type: i32, border_value: *const core::Scalar) -> Result_void;
		pub fn cv_distanceTransform_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_int_int_int(src: *mut c_void, dst: *mut c_void, labels: *mut c_void, distance_type: i32, mask_size: i32, label_type: i32) -> Result_void;
		pub fn cv_distanceTransform_const__InputArrayX_const__OutputArrayX_int_int_int(src: *mut c_void, dst: *mut c_void, distance_type: i32, mask_size: i32, dst_type: i32) -> Result_void;
		pub fn cv_drawContours_const__InputOutputArrayX_const__InputArrayX_int_const_ScalarX_int_int_const__InputArrayX_int_Point(image: *mut c_void, contours: *mut c_void, contour_idx: i32, color: *const core::Scalar, thickness: i32, line_type: i32, hierarchy: *mut c_void, max_level: i32, offset: *const core::Point) -> Result_void;
		pub fn cv_drawMarker_const__InputOutputArrayX_Point_const_ScalarX_int_int_int_int(img: *mut c_void, position: *const core::Point, color: *const core::Scalar, marker_type: i32, marker_size: i32, thickness: i32, line_type: i32) -> Result_void;
		pub fn cv_ellipse2Poly_Point2d_Size2d_int_int_int_int_vector_Point2d_X(center: *const core::Point2d, axes: *const core::Size2d, angle: i32, arc_start: i32, arc_end: i32, delta: i32, pts: *mut c_void) -> Result_void;
		pub fn cv_ellipse2Poly_Point_Size_int_int_int_int_vector_Point_X(center: *const core::Point, axes: *const core::Size, angle: i32, arc_start: i32, arc_end: i32, delta: i32, pts: *mut c_void) -> Result_void;
		pub fn cv_ellipse_const__InputOutputArrayX_Point_Size_double_double_double_const_ScalarX_int_int_int(img: *mut c_void, center: *const core::Point, axes: *const core::Size, angle: f64, start_angle: f64, end_angle: f64, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32) -> Result_void;
		pub fn cv_ellipse_const__InputOutputArrayX_const_RotatedRectX_const_ScalarX_int_int(img: *mut c_void, box_: *mut c_void, color: *const core::Scalar, thickness: i32, line_type: i32) -> Result_void;
		pub fn cv_equalizeHist_const__InputArrayX_const__OutputArrayX(src: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_erode_const__InputArrayX_const__OutputArrayX_const__InputArrayX_Point_int_int_const_ScalarX(src: *mut c_void, dst: *mut c_void, kernel: *mut c_void, anchor: *const core::Point, iterations: i32, border_type: i32, border_value: *const core::Scalar) -> Result_void;
		pub fn cv_fillConvexPoly_const__InputOutputArrayX_const__InputArrayX_const_ScalarX_int_int(img: *mut c_void, points: *mut c_void, color: *const core::Scalar, line_type: i32, shift: i32) -> Result_void;
		pub fn cv_fillPoly_const__InputOutputArrayX_const__InputArrayX_const_ScalarX_int_int_Point(img: *mut c_void, pts: *mut c_void, color: *const core::Scalar, line_type: i32, shift: i32, offset: *const core::Point) -> Result_void;
		pub fn cv_filter2D_const__InputArrayX_const__OutputArrayX_int_const__InputArrayX_Point_double_int(src: *mut c_void, dst: *mut c_void, ddepth: i32, kernel: *mut c_void, anchor: *const core::Point, delta: f64, border_type: i32) -> Result_void;
		pub fn cv_findContours_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_int_int_Point(image: *mut c_void, contours: *mut c_void, hierarchy: *mut c_void, mode: i32, method: i32, offset: *const core::Point) -> Result_void;
		pub fn cv_findContours_const__InputArrayX_const__OutputArrayX_int_int_Point(image: *mut c_void, contours: *mut c_void, mode: i32, method: i32, offset: *const core::Point) -> Result_void;
		pub fn cv_fitEllipseAMS_const__InputArrayX(points: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_fitEllipseDirect_const__InputArrayX(points: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_fitEllipse_const__InputArrayX(points: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_fitLine_const__InputArrayX_const__OutputArrayX_int_double_double_double(points: *mut c_void, line: *mut c_void, dist_type: i32, param: f64, reps: f64, aeps: f64) -> Result_void;
		pub fn cv_floodFill_const__InputOutputArrayX_Point_Scalar_RectX_Scalar_Scalar_int(image: *mut c_void, seed_point: *const core::Point, new_val: *const core::Scalar, rect: *mut core::Rect, lo_diff: *const core::Scalar, up_diff: *const core::Scalar, flags: i32) -> Result<i32>;
		pub fn cv_floodFill_const__InputOutputArrayX_const__InputOutputArrayX_Point_Scalar_RectX_Scalar_Scalar_int(image: *mut c_void, mask: *mut c_void, seed_point: *const core::Point, new_val: *const core::Scalar, rect: *mut core::Rect, lo_diff: *const core::Scalar, up_diff: *const core::Scalar, flags: i32) -> Result<i32>;
		pub fn cv_getAffineTransform_const_Point2fX_const_Point2fX(src: *const core::Point2f, dst: *const core::Point2f) -> Result<*mut c_void>;
		pub fn cv_getAffineTransform_const__InputArrayX_const__InputArrayX(src: *mut c_void, dst: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_getDerivKernels_const__OutputArrayX_const__OutputArrayX_int_int_int_bool_int(kx: *mut c_void, ky: *mut c_void, dx: i32, dy: i32, ksize: i32, normalize: bool, ktype: i32) -> Result_void;
		pub fn cv_getFontScaleFromHeight_int_int_int(font_face: i32, pixel_height: i32, thickness: i32) -> Result<f64>;
		pub fn cv_getGaborKernel_Size_double_double_double_double_double_int(ksize: *const core::Size, sigma: f64, theta: f64, lambd: f64, gamma: f64, psi: f64, ktype: i32) -> Result<*mut c_void>;
		pub fn cv_getGaussianKernel_int_double_int(ksize: i32, sigma: f64, ktype: i32) -> Result<*mut c_void>;
		pub fn cv_getPerspectiveTransform_const_Point2fX_const_Point2fX_int(src: *const core::Point2f, dst: *const core::Point2f, solve_method: i32) -> Result<*mut c_void>;
		pub fn cv_getPerspectiveTransform_const__InputArrayX_const__InputArrayX_int(src: *mut c_void, dst: *mut c_void, solve_method: i32) -> Result<*mut c_void>;
		pub fn cv_getRectSubPix_const__InputArrayX_Size_Point2f_const__OutputArrayX_int(image: *mut c_void, patch_size: *const core::Size, center: *const core::Point2f, patch: *mut c_void, patch_type: i32) -> Result_void;
		pub fn cv_getRotationMatrix2D_Point2f_double_double(center: *const core::Point2f, angle: f64, scale: f64) -> Result<*mut c_void>;
		pub fn cv_getStructuringElement_int_Size_Point(shape: i32, ksize: *const core::Size, anchor: *const core::Point) -> Result<*mut c_void>;
		pub fn cv_getTextSize_const_StringX_int_double_int_intX(text: *const c_char, font_face: i32, font_scale: f64, thickness: i32, base_line: *mut i32) -> Result<core::Size>;
		pub fn cv_goodFeaturesToTrack_const__InputArrayX_const__OutputArrayX_int_double_double_const__InputArrayX_int_bool_double(image: *mut c_void, corners: *mut c_void, max_corners: i32, quality_level: f64, min_distance: f64, mask: *mut c_void, block_size: i32, use_harris_detector: bool, k: f64) -> Result_void;
		pub fn cv_goodFeaturesToTrack_const__InputArrayX_const__OutputArrayX_int_double_double_const__InputArrayX_int_int_bool_double(image: *mut c_void, corners: *mut c_void, max_corners: i32, quality_level: f64, min_distance: f64, mask: *mut c_void, block_size: i32, gradient_size: i32, use_harris_detector: bool, k: f64) -> Result_void;
		pub fn cv_grabCut_const__InputArrayX_const__InputOutputArrayX_Rect_const__InputOutputArrayX_const__InputOutputArrayX_int_int(img: *mut c_void, mask: *mut c_void, rect: *const core::Rect, bgd_model: *mut c_void, fgd_model: *mut c_void, iter_count: i32, mode: i32) -> Result_void;
		pub fn cv_integral_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_int_int(src: *mut c_void, sum: *mut c_void, sqsum: *mut c_void, tilted: *mut c_void, sdepth: i32, sqdepth: i32) -> Result_void;
		pub fn cv_integral_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_int_int(src: *mut c_void, sum: *mut c_void, sqsum: *mut c_void, sdepth: i32, sqdepth: i32) -> Result_void;
		pub fn cv_integral_const__InputArrayX_const__OutputArrayX_int(src: *mut c_void, sum: *mut c_void, sdepth: i32) -> Result_void;
		pub fn cv_intersectConvexConvex_const__InputArrayX_const__InputArrayX_const__OutputArrayX_bool(_p1: *mut c_void, _p2: *mut c_void, _p12: *mut c_void, handle_nested: bool) -> Result<f32>;
		pub fn cv_invertAffineTransform_const__InputArrayX_const__OutputArrayX(m: *mut c_void, i_m: *mut c_void) -> Result_void;
		pub fn cv_isContourConvex_const__InputArrayX(contour: *mut c_void) -> Result<bool>;
		pub fn cv_line_const__InputOutputArrayX_Point_Point_const_ScalarX_int_int_int(img: *mut c_void, pt1: *const core::Point, pt2: *const core::Point, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32) -> Result_void;
		pub fn cv_linearPolar_const__InputArrayX_const__OutputArrayX_Point2f_double_int(src: *mut c_void, dst: *mut c_void, center: *const core::Point2f, max_radius: f64, flags: i32) -> Result_void;
		pub fn cv_logPolar_const__InputArrayX_const__OutputArrayX_Point2f_double_int(src: *mut c_void, dst: *mut c_void, center: *const core::Point2f, m: f64, flags: i32) -> Result_void;
		pub fn cv_matchShapes_const__InputArrayX_const__InputArrayX_int_double(contour1: *mut c_void, contour2: *mut c_void, method: i32, parameter: f64) -> Result<f64>;
		pub fn cv_matchTemplate_const__InputArrayX_const__InputArrayX_const__OutputArrayX_int_const__InputArrayX(image: *mut c_void, templ: *mut c_void, result: *mut c_void, method: i32, mask: *mut c_void) -> Result_void;
		pub fn cv_medianBlur_const__InputArrayX_const__OutputArrayX_int(src: *mut c_void, dst: *mut c_void, ksize: i32) -> Result_void;
		pub fn cv_minAreaRect_const__InputArrayX(points: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_minEnclosingCircle_const__InputArrayX_Point2fX_floatX(points: *mut c_void, center: *mut core::Point2f, radius: *mut f32) -> Result_void;
		pub fn cv_minEnclosingTriangle_const__InputArrayX_const__OutputArrayX(points: *mut c_void, triangle: *mut c_void) -> Result<f64>;
		pub fn cv_moments_const__InputArrayX_bool(array: *mut c_void, binary_image: bool) -> Result<core::Moments>;
		pub fn cv_morphologyDefaultBorderValue() -> Result<core::Scalar>;
		pub fn cv_morphologyEx_const__InputArrayX_const__OutputArrayX_int_const__InputArrayX_Point_int_int_const_ScalarX(src: *mut c_void, dst: *mut c_void, op: i32, kernel: *mut c_void, anchor: *const core::Point, iterations: i32, border_type: i32, border_value: *const core::Scalar) -> Result_void;
		pub fn cv_phaseCorrelate_const__InputArrayX_const__InputArrayX_const__InputArrayX_doubleX(src1: *mut c_void, src2: *mut c_void, window: *mut c_void, response: *mut f64) -> Result<core::Point2d>;
		pub fn cv_pointPolygonTest_const__InputArrayX_Point2f_bool(contour: *mut c_void, pt: *const core::Point2f, measure_dist: bool) -> Result<f64>;
		pub fn cv_polylines_const__InputOutputArrayX_const__InputArrayX_bool_const_ScalarX_int_int_int(img: *mut c_void, pts: *mut c_void, is_closed: bool, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32) -> Result_void;
		pub fn cv_preCornerDetect_const__InputArrayX_const__OutputArrayX_int_int(src: *mut c_void, dst: *mut c_void, ksize: i32, border_type: i32) -> Result_void;
		pub fn cv_putText_const__InputOutputArrayX_const_StringX_Point_int_double_Scalar_int_int_bool(img: *mut c_void, text: *const c_char, org: *const core::Point, font_face: i32, font_scale: f64, color: *const core::Scalar, thickness: i32, line_type: i32, bottom_left_origin: bool) -> Result_void;
		pub fn cv_pyrDown_const__InputArrayX_const__OutputArrayX_const_SizeX_int(src: *mut c_void, dst: *mut c_void, dstsize: *const core::Size, border_type: i32) -> Result_void;
		pub fn cv_pyrMeanShiftFiltering_const__InputArrayX_const__OutputArrayX_double_double_int_TermCriteria(src: *mut c_void, dst: *mut c_void, sp: f64, sr: f64, max_level: i32, termcrit: *mut c_void) -> Result_void;
		pub fn cv_pyrUp_const__InputArrayX_const__OutputArrayX_const_SizeX_int(src: *mut c_void, dst: *mut c_void, dstsize: *const core::Size, border_type: i32) -> Result_void;
		pub fn cv_rectangle_const__InputOutputArrayX_Point_Point_const_ScalarX_int_int_int(img: *mut c_void, pt1: *const core::Point, pt2: *const core::Point, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32) -> Result_void;
		pub fn cv_rectangle_const__InputOutputArrayX_Rect_const_ScalarX_int_int_int(img: *mut c_void, rec: *const core::Rect, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32) -> Result_void;
		pub fn cv_remap_const__InputArrayX_const__OutputArrayX_const__InputArrayX_const__InputArrayX_int_int_const_ScalarX(src: *mut c_void, dst: *mut c_void, map1: *mut c_void, map2: *mut c_void, interpolation: i32, border_mode: i32, border_value: *const core::Scalar) -> Result_void;
		pub fn cv_resize_const__InputArrayX_const__OutputArrayX_Size_double_double_int(src: *mut c_void, dst: *mut c_void, dsize: *const core::Size, fx: f64, fy: f64, interpolation: i32) -> Result_void;
		pub fn cv_rotatedRectangleIntersection_const_RotatedRectX_const_RotatedRectX_const__OutputArrayX(rect1: *mut c_void, rect2: *mut c_void, intersecting_region: *mut c_void) -> Result<i32>;
		pub fn cv_sepFilter2D_const__InputArrayX_const__OutputArrayX_int_const__InputArrayX_const__InputArrayX_Point_double_int(src: *mut c_void, dst: *mut c_void, ddepth: i32, kernel_x: *mut c_void, kernel_y: *mut c_void, anchor: *const core::Point, delta: f64, border_type: i32) -> Result_void;
		pub fn cv_spatialGradient_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_int_int(src: *mut c_void, dx: *mut c_void, dy: *mut c_void, ksize: i32, border_type: i32) -> Result_void;
		pub fn cv_sqrBoxFilter_const__InputArrayX_const__OutputArrayX_int_Size_Point_bool_int(src: *mut c_void, dst: *mut c_void, ddepth: i32, ksize: *const core::Size, anchor: *const core::Point, normalize: bool, border_type: i32) -> Result_void;
		pub fn cv_threshold_const__InputArrayX_const__OutputArrayX_double_double_int(src: *mut c_void, dst: *mut c_void, thresh: f64, maxval: f64, typ: i32) -> Result<f64>;
		pub fn cv_warpAffine_const__InputArrayX_const__OutputArrayX_const__InputArrayX_Size_int_int_const_ScalarX(src: *mut c_void, dst: *mut c_void, m: *mut c_void, dsize: *const core::Size, flags: i32, border_mode: i32, border_value: *const core::Scalar) -> Result_void;
		pub fn cv_warpPerspective_const__InputArrayX_const__OutputArrayX_const__InputArrayX_Size_int_int_const_ScalarX(src: *mut c_void, dst: *mut c_void, m: *mut c_void, dsize: *const core::Size, flags: i32, border_mode: i32, border_value: *const core::Scalar) -> Result_void;
		pub fn cv_warpPolar_const__InputArrayX_const__OutputArrayX_Size_Point2f_double_int(src: *mut c_void, dst: *mut c_void, dsize: *const core::Size, center: *const core::Point2f, max_radius: f64, flags: i32) -> Result_void;
		pub fn cv_watershed_const__InputArrayX_const__InputOutputArrayX(image: *mut c_void, markers: *mut c_void) -> Result_void;
		pub fn cv_wrapperEMD_const__InputArrayX_const__InputArrayX_int_const__InputArrayX_Ptr_float__const__OutputArrayX(signature1: *mut c_void, signature2: *mut c_void, dist_type: i32, cost: *mut c_void, lower_bound: *mut c_void, flow: *mut c_void) -> Result<f32>;
		pub fn cv_CLAHE_apply_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, src: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_CLAHE_setClipLimit_double(instance: *mut c_void, clip_limit: f64) -> Result_void;
		pub fn cv_CLAHE_getClipLimit_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_CLAHE_setTilesGridSize_Size(instance: *mut c_void, tile_grid_size: *const core::Size) -> Result_void;
		pub fn cv_CLAHE_getTilesGridSize_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_CLAHE_collectGarbage(instance: *mut c_void) -> Result_void;
		pub fn cv_GeneralizedHough_setTemplate_const__InputArrayX_Point(instance: *mut c_void, templ: *mut c_void, templ_center: *const core::Point) -> Result_void;
		pub fn cv_GeneralizedHough_setTemplate_const__InputArrayX_const__InputArrayX_const__InputArrayX_Point(instance: *mut c_void, edges: *mut c_void, dx: *mut c_void, dy: *mut c_void, templ_center: *const core::Point) -> Result_void;
		pub fn cv_GeneralizedHough_detect_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, image: *mut c_void, positions: *mut c_void, votes: *mut c_void) -> Result_void;
		pub fn cv_GeneralizedHough_detect_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, edges: *mut c_void, dx: *mut c_void, dy: *mut c_void, positions: *mut c_void, votes: *mut c_void) -> Result_void;
		pub fn cv_GeneralizedHough_setCannyLowThresh_int(instance: *mut c_void, canny_low_thresh: i32) -> Result_void;
		pub fn cv_GeneralizedHough_getCannyLowThresh_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_GeneralizedHough_setCannyHighThresh_int(instance: *mut c_void, canny_high_thresh: i32) -> Result_void;
		pub fn cv_GeneralizedHough_getCannyHighThresh_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_GeneralizedHough_setMinDist_double(instance: *mut c_void, min_dist: f64) -> Result_void;
		pub fn cv_GeneralizedHough_getMinDist_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_GeneralizedHough_setDp_double(instance: *mut c_void, dp: f64) -> Result_void;
		pub fn cv_GeneralizedHough_getDp_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_GeneralizedHough_setMaxBufferSize_int(instance: *mut c_void, max_buffer_size: i32) -> Result_void;
		pub fn cv_GeneralizedHough_getMaxBufferSize_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_GeneralizedHoughBallard_setLevels_int(instance: *mut c_void, levels: i32) -> Result_void;
		pub fn cv_GeneralizedHoughBallard_getLevels_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_GeneralizedHoughBallard_setVotesThreshold_int(instance: *mut c_void, votes_threshold: i32) -> Result_void;
		pub fn cv_GeneralizedHoughBallard_getVotesThreshold_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_GeneralizedHoughGuil_setXi_double(instance: *mut c_void, xi: f64) -> Result_void;
		pub fn cv_GeneralizedHoughGuil_getXi_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_GeneralizedHoughGuil_setLevels_int(instance: *mut c_void, levels: i32) -> Result_void;
		pub fn cv_GeneralizedHoughGuil_getLevels_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_GeneralizedHoughGuil_setAngleEpsilon_double(instance: *mut c_void, angle_epsilon: f64) -> Result_void;
		pub fn cv_GeneralizedHoughGuil_getAngleEpsilon_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_GeneralizedHoughGuil_setMinAngle_double(instance: *mut c_void, min_angle: f64) -> Result_void;
		pub fn cv_GeneralizedHoughGuil_getMinAngle_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_GeneralizedHoughGuil_setMaxAngle_double(instance: *mut c_void, max_angle: f64) -> Result_void;
		pub fn cv_GeneralizedHoughGuil_getMaxAngle_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_GeneralizedHoughGuil_setAngleStep_double(instance: *mut c_void, angle_step: f64) -> Result_void;
		pub fn cv_GeneralizedHoughGuil_getAngleStep_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_GeneralizedHoughGuil_setAngleThresh_int(instance: *mut c_void, angle_thresh: i32) -> Result_void;
		pub fn cv_GeneralizedHoughGuil_getAngleThresh_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_GeneralizedHoughGuil_setMinScale_double(instance: *mut c_void, min_scale: f64) -> Result_void;
		pub fn cv_GeneralizedHoughGuil_getMinScale_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_GeneralizedHoughGuil_setMaxScale_double(instance: *mut c_void, max_scale: f64) -> Result_void;
		pub fn cv_GeneralizedHoughGuil_getMaxScale_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_GeneralizedHoughGuil_setScaleStep_double(instance: *mut c_void, scale_step: f64) -> Result_void;
		pub fn cv_GeneralizedHoughGuil_getScaleStep_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_GeneralizedHoughGuil_setScaleThresh_int(instance: *mut c_void, scale_thresh: i32) -> Result_void;
		pub fn cv_GeneralizedHoughGuil_getScaleThresh_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_GeneralizedHoughGuil_setPosThresh_int(instance: *mut c_void, pos_thresh: i32) -> Result_void;
		pub fn cv_GeneralizedHoughGuil_getPosThresh_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_LineIterator_ptr(instance: *mut c_void) -> Result<*mut u8>;
		pub fn cv_LineIterator_setPtr_unsigned_charX(instance: *mut c_void, val: *mut u8) -> Result_void;
		pub fn cv_LineIterator_ptr0_const(instance: *mut c_void) -> Result<*const u8>;
		pub fn cv_LineIterator_step_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_LineIterator_setStep_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_LineIterator_elemSize_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_LineIterator_setElemSize_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_LineIterator_err_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_LineIterator_setErr_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_LineIterator_count_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_LineIterator_setCount_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_LineIterator_minusDelta_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_LineIterator_setMinusDelta_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_LineIterator_plusDelta_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_LineIterator_setPlusDelta_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_LineIterator_minusStep_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_LineIterator_setMinusStep_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_LineIterator_plusStep_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_LineIterator_setPlusStep_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_LineIterator_LineIterator_const_MatX_Point_Point_int_bool(img: *mut c_void, pt1: *const core::Point, pt2: *const core::Point, connectivity: i32, left_to_right: bool) -> Result<*mut c_void>;
		pub fn cv_LineIterator_pos_const(instance: *mut c_void) -> Result<core::Point>;
		pub fn cv_LineSegmentDetector_detect_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, _image: *mut c_void, _lines: *mut c_void, width: *mut c_void, prec: *mut c_void, nfa: *mut c_void) -> Result_void;
		pub fn cv_LineSegmentDetector_drawSegments_const__InputOutputArrayX_const__InputArrayX(instance: *mut c_void, _image: *mut c_void, lines: *mut c_void) -> Result_void;
		pub fn cv_LineSegmentDetector_compareSegments_const_SizeX_const__InputArrayX_const__InputArrayX_const__InputOutputArrayX(instance: *mut c_void, size: *const core::Size, lines1: *mut c_void, lines2: *mut c_void, _image: *mut c_void) -> Result<i32>;
		pub fn cv_Subdiv2D_Subdiv2D() -> Result<*mut c_void>;
		pub fn cv_Subdiv2D_Subdiv2D_Rect(rect: *const core::Rect) -> Result<*mut c_void>;
		pub fn cv_Subdiv2D_initDelaunay_Rect(instance: *mut c_void, rect: *const core::Rect) -> Result_void;
		pub fn cv_Subdiv2D_insert_Point2f(instance: *mut c_void, pt: *const core::Point2f) -> Result<i32>;
		pub fn cv_Subdiv2D_insert_const_vector_Point2f_X(instance: *mut c_void, ptvec: *mut c_void) -> Result_void;
		pub fn cv_Subdiv2D_locate_Point2f_intX_intX(instance: *mut c_void, pt: *const core::Point2f, edge: *mut i32, vertex: *mut i32) -> Result<i32>;
		pub fn cv_Subdiv2D_findNearest_Point2f_Point2fX(instance: *mut c_void, pt: *const core::Point2f, nearest_pt: *mut core::Point2f) -> Result<i32>;
		pub fn cv_Subdiv2D_getEdgeList_const_vector_Vec4f_X(instance: *mut c_void, edge_list: *mut c_void) -> Result_void;
		pub fn cv_Subdiv2D_getLeadingEdgeList_const_vector_int_X(instance: *mut c_void, leading_edge_list: *mut c_void) -> Result_void;
		pub fn cv_Subdiv2D_getTriangleList_const_vector_Vec6f_X(instance: *mut c_void, triangle_list: *mut c_void) -> Result_void;
		pub fn cv_Subdiv2D_getVoronoiFacetList_const_vector_int_X_vector_vector_Point2f__X_vector_Point2f_X(instance: *mut c_void, idx: *mut c_void, facet_list: *mut c_void, facet_centers: *mut c_void) -> Result_void;
		pub fn cv_Subdiv2D_getVertex_const_int_intX(instance: *mut c_void, vertex: i32, first_edge: *mut i32) -> Result<core::Point2f>;
		pub fn cv_Subdiv2D_getEdge_const_int_int(instance: *mut c_void, edge: i32, next_edge_type: i32) -> Result<i32>;
		pub fn cv_Subdiv2D_nextEdge_const_int(instance: *mut c_void, edge: i32) -> Result<i32>;
		pub fn cv_Subdiv2D_rotateEdge_const_int_int(instance: *mut c_void, edge: i32, rotate: i32) -> Result<i32>;
		pub fn cv_Subdiv2D_symEdge_const_int(instance: *mut c_void, edge: i32) -> Result<i32>;
		pub fn cv_Subdiv2D_edgeOrg_const_int_Point2fX(instance: *mut c_void, edge: i32, orgpt: *mut core::Point2f) -> Result<i32>;
		pub fn cv_Subdiv2D_edgeDst_const_int_Point2fX(instance: *mut c_void, edge: i32, dstpt: *mut core::Point2f) -> Result<i32>;
	}
}
pub use imgproc_sys::*;

#[cfg(feature = "contrib")]
mod line_descriptor_sys {
	use super::*;

	extern "C" {
		pub fn cv_line_descriptor_drawKeylines_const_MatX_const_vector_KeyLine_X_MatX_const_ScalarX_int(image: *mut c_void, keylines: *mut c_void, out_image: *mut c_void, color: *const core::Scalar, flags: i32) -> Result_void;
		pub fn cv_line_descriptor_drawLineMatches_const_MatX_const_vector_KeyLine_X_const_MatX_const_vector_KeyLine_X_const_vector_DMatch_X_MatX_const_ScalarX_const_ScalarX_const_vector_char_X_int(img1: *mut c_void, keylines1: *mut c_void, img2: *mut c_void, keylines2: *mut c_void, matches1to2: *mut c_void, out_img: *mut c_void, match_color: *const core::Scalar, single_line_color: *const core::Scalar, matches_mask: *mut c_void, flags: i32) -> Result_void;
		pub fn cv_line_descriptor_BinaryDescriptor_BinaryDescriptor_const_ParamsX(parameters: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_line_descriptor_BinaryDescriptor_createBinaryDescriptor() -> Result<*mut c_void>;
		pub fn cv_line_descriptor_BinaryDescriptor_createBinaryDescriptor_Params(parameters: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_line_descriptor_BinaryDescriptor_getNumOfOctaves(instance: *mut c_void) -> Result<i32>;
		pub fn cv_line_descriptor_BinaryDescriptor_setNumOfOctaves_int(instance: *mut c_void, octaves: i32) -> Result_void;
		pub fn cv_line_descriptor_BinaryDescriptor_getWidthOfBand(instance: *mut c_void) -> Result<i32>;
		pub fn cv_line_descriptor_BinaryDescriptor_setWidthOfBand_int(instance: *mut c_void, width: i32) -> Result_void;
		pub fn cv_line_descriptor_BinaryDescriptor_getReductionRatio(instance: *mut c_void) -> Result<i32>;
		pub fn cv_line_descriptor_BinaryDescriptor_setReductionRatio_int(instance: *mut c_void, r_ratio: i32) -> Result_void;
		pub fn cv_line_descriptor_BinaryDescriptor_read_const_FileNodeX(instance: *mut c_void, fn_: *mut c_void) -> Result_void;
		pub fn cv_line_descriptor_BinaryDescriptor_write_const_FileStorageX(instance: *mut c_void, fs: *mut c_void) -> Result_void;
		pub fn cv_line_descriptor_BinaryDescriptor_detect_const_MatX_vector_KeyLine_X_const_MatX(instance: *mut c_void, image: *mut c_void, keypoints: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_line_descriptor_BinaryDescriptor_detect_const_const_vector_Mat_X_vector_vector_KeyLine__X_const_vector_Mat_X(instance: *mut c_void, images: *mut c_void, keylines: *mut c_void, masks: *mut c_void) -> Result_void;
		pub fn cv_line_descriptor_BinaryDescriptor_compute_const_const_MatX_vector_KeyLine_X_MatX_bool(instance: *mut c_void, image: *mut c_void, keylines: *mut c_void, descriptors: *mut c_void, return_float_descr: bool) -> Result_void;
		pub fn cv_line_descriptor_BinaryDescriptor_compute_const_const_vector_Mat_X_vector_vector_KeyLine__X_vector_Mat_X_bool(instance: *mut c_void, images: *mut c_void, keylines: *mut c_void, descriptors: *mut c_void, return_float_descr: bool) -> Result_void;
		pub fn cv_line_descriptor_BinaryDescriptor_descriptorSize_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_line_descriptor_BinaryDescriptor_descriptorType_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_line_descriptor_BinaryDescriptor_defaultNorm_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_line_descriptor_BinaryDescriptor_Params_numOfOctave__const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_line_descriptor_BinaryDescriptor_Params_setNumOfOctave__int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_line_descriptor_BinaryDescriptor_Params_widthOfBand__const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_line_descriptor_BinaryDescriptor_Params_setWidthOfBand__int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_line_descriptor_BinaryDescriptor_Params_reductionRatio_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_line_descriptor_BinaryDescriptor_Params_setReductionRatio_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_line_descriptor_BinaryDescriptor_Params_ksize__const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_line_descriptor_BinaryDescriptor_Params_setKsize__int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_line_descriptor_BinaryDescriptor_Params_Params() -> Result<*mut c_void>;
		pub fn cv_line_descriptor_BinaryDescriptor_Params_read_const_FileNodeX(instance: *mut c_void, fn_: *mut c_void) -> Result_void;
		pub fn cv_line_descriptor_BinaryDescriptor_Params_write_const_FileStorageX(instance: *mut c_void, fs: *mut c_void) -> Result_void;
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_match_const_const_MatX_const_MatX_vector_DMatch_X_const_MatX(instance: *mut c_void, query_descriptors: *mut c_void, train_descriptors: *mut c_void, matches: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_match_const_MatX_vector_DMatch_X_const_vector_Mat_X(instance: *mut c_void, query_descriptors: *mut c_void, matches: *mut c_void, masks: *mut c_void) -> Result_void;
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_knnMatch_const_const_MatX_const_MatX_vector_vector_DMatch__X_int_const_MatX_bool(instance: *mut c_void, query_descriptors: *mut c_void, train_descriptors: *mut c_void, matches: *mut c_void, k: i32, mask: *mut c_void, compact_result: bool) -> Result_void;
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_knnMatch_const_MatX_vector_vector_DMatch__X_int_const_vector_Mat_X_bool(instance: *mut c_void, query_descriptors: *mut c_void, matches: *mut c_void, k: i32, masks: *mut c_void, compact_result: bool) -> Result_void;
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_radiusMatch_const_const_MatX_const_MatX_vector_vector_DMatch__X_float_const_MatX_bool(instance: *mut c_void, query_descriptors: *mut c_void, train_descriptors: *mut c_void, matches: *mut c_void, max_distance: f32, mask: *mut c_void, compact_result: bool) -> Result_void;
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_radiusMatch_const_MatX_vector_vector_DMatch__X_float_const_vector_Mat_X_bool(instance: *mut c_void, query_descriptors: *mut c_void, matches: *mut c_void, max_distance: f32, masks: *mut c_void, compact_result: bool) -> Result_void;
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_add_const_vector_Mat_X(instance: *mut c_void, descriptors: *mut c_void) -> Result_void;
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_train(instance: *mut c_void) -> Result_void;
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_createBinaryDescriptorMatcher() -> Result<*mut c_void>;
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_clear(instance: *mut c_void) -> Result_void;
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_BinaryDescriptorMatcher() -> Result<*mut c_void>;
		pub fn cv_line_descriptor_KeyLine_getStartPoint_const(instance: *const crate::line_descriptor::KeyLine) -> Result<core::Point2f>;
		pub fn cv_line_descriptor_KeyLine_getEndPoint_const(instance: *const crate::line_descriptor::KeyLine) -> Result<core::Point2f>;
		pub fn cv_line_descriptor_KeyLine_getStartPointInOctave_const(instance: *const crate::line_descriptor::KeyLine) -> Result<core::Point2f>;
		pub fn cv_line_descriptor_KeyLine_getEndPointInOctave_const(instance: *const crate::line_descriptor::KeyLine) -> Result<core::Point2f>;
		pub fn cv_line_descriptor_KeyLine_KeyLine() -> Result<crate::line_descriptor::KeyLine>;
		pub fn cv_line_descriptor_LSDDetector_LSDDetector() -> Result<*mut c_void>;
		pub fn cv_line_descriptor_LSDDetector_LSDDetector_LSDParam(_params: *const crate::line_descriptor::LSDParam) -> Result<*mut c_void>;
		pub fn cv_line_descriptor_LSDDetector_createLSDDetector() -> Result<*mut c_void>;
		pub fn cv_line_descriptor_LSDDetector_createLSDDetector_LSDParam(params: *const crate::line_descriptor::LSDParam) -> Result<*mut c_void>;
		pub fn cv_line_descriptor_LSDDetector_detect_const_MatX_vector_KeyLine_X_int_int_const_MatX(instance: *mut c_void, image: *mut c_void, keypoints: *mut c_void, scale: i32, num_octaves: i32, mask: *mut c_void) -> Result_void;
		pub fn cv_line_descriptor_LSDDetector_detect_const_const_vector_Mat_X_vector_vector_KeyLine__X_int_int_const_vector_Mat_X(instance: *mut c_void, images: *mut c_void, keylines: *mut c_void, scale: i32, num_octaves: i32, masks: *mut c_void) -> Result_void;
		pub fn cv_line_descriptor_LSDParam_LSDParam() -> Result<crate::line_descriptor::LSDParam>;
	}
}
#[cfg(feature = "contrib")]
pub use line_descriptor_sys::*;

mod ml_sys {
	use super::*;

	extern "C" {
		pub fn cv_ml_createConcentricSpheresTestSet_int_int_int_const__OutputArrayX_const__OutputArrayX(nsamples: i32, nfeatures: i32, nclasses: i32, samples: *mut c_void, responses: *mut c_void) -> Result_void;
		pub fn cv_ml_randMVNormal_const__InputArrayX_const__InputArrayX_int_const__OutputArrayX(mean: *mut c_void, cov: *mut c_void, nsamples: i32, samples: *mut c_void) -> Result_void;
		pub fn cv_ml_ANN_MLP_setTrainMethod_int_double_double(instance: *mut c_void, method: i32, param1: f64, param2: f64) -> Result_void;
		pub fn cv_ml_ANN_MLP_getTrainMethod_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_ANN_MLP_setActivationFunction_int_double_double(instance: *mut c_void, typ: i32, param1: f64, param2: f64) -> Result_void;
		pub fn cv_ml_ANN_MLP_setLayerSizes_const__InputArrayX(instance: *mut c_void, _layer_sizes: *mut c_void) -> Result_void;
		pub fn cv_ml_ANN_MLP_getLayerSizes_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_ANN_MLP_getTermCriteria_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_ANN_MLP_setTermCriteria_TermCriteria(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_ml_ANN_MLP_getBackpropWeightScale_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ml_ANN_MLP_setBackpropWeightScale_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_ml_ANN_MLP_getBackpropMomentumScale_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ml_ANN_MLP_setBackpropMomentumScale_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_ml_ANN_MLP_getRpropDW0_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ml_ANN_MLP_setRpropDW0_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_ml_ANN_MLP_getRpropDWPlus_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ml_ANN_MLP_setRpropDWPlus_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_ml_ANN_MLP_getRpropDWMinus_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ml_ANN_MLP_setRpropDWMinus_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_ml_ANN_MLP_getRpropDWMin_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ml_ANN_MLP_setRpropDWMin_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_ml_ANN_MLP_getRpropDWMax_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ml_ANN_MLP_setRpropDWMax_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_ml_ANN_MLP_getAnnealInitialT_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ml_ANN_MLP_setAnnealInitialT_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_ml_ANN_MLP_getAnnealFinalT_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ml_ANN_MLP_setAnnealFinalT_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_ml_ANN_MLP_getAnnealCoolingRatio_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ml_ANN_MLP_setAnnealCoolingRatio_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_ml_ANN_MLP_getAnnealItePerStep_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_ANN_MLP_setAnnealItePerStep_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_ANN_MLP_setAnnealEnergyRNG_const_RNGX(instance: *mut c_void, rng: *mut c_void) -> Result_void;
		pub fn cv_ml_ANN_MLP_getWeights_const_int(instance: *mut c_void, layer_idx: i32) -> Result<*mut c_void>;
		pub fn cv_ml_ANN_MLP_create() -> Result<*mut c_void>;
		pub fn cv_ml_ANN_MLP_load_const_StringX(filepath: *const c_char) -> Result<*mut c_void>;
		pub fn cv_ml_Boost_getBoostType_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_Boost_setBoostType_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_Boost_getWeakCount_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_Boost_setWeakCount_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_Boost_getWeightTrimRate_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ml_Boost_setWeightTrimRate_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_ml_Boost_create() -> Result<*mut c_void>;
		pub fn cv_ml_Boost_load_const_StringX_const_StringX(filepath: *const c_char, node_name: *const c_char) -> Result<*mut c_void>;
		pub fn cv_ml_DTrees_getMaxCategories_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_DTrees_setMaxCategories_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_DTrees_getMaxDepth_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_DTrees_setMaxDepth_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_DTrees_getMinSampleCount_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_DTrees_setMinSampleCount_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_DTrees_getCVFolds_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_DTrees_setCVFolds_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_DTrees_getUseSurrogates_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_ml_DTrees_setUseSurrogates_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_ml_DTrees_getUse1SERule_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_ml_DTrees_setUse1SERule_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_ml_DTrees_getTruncatePrunedTree_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_ml_DTrees_setTruncatePrunedTree_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_ml_DTrees_getRegressionAccuracy_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_ml_DTrees_setRegressionAccuracy_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_ml_DTrees_getPriors_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_DTrees_setPriors_const_MatX(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_ml_DTrees_getRoots_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_DTrees_getNodes_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_DTrees_getSplits_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_DTrees_getSubsets_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_DTrees_create() -> Result<*mut c_void>;
		pub fn cv_ml_DTrees_load_const_StringX_const_StringX(filepath: *const c_char, node_name: *const c_char) -> Result<*mut c_void>;
		pub fn cv_ml_DTrees_Node_value_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ml_DTrees_Node_setValue_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_ml_DTrees_Node_classIdx_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_DTrees_Node_setClassIdx_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_DTrees_Node_parent_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_DTrees_Node_setParent_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_DTrees_Node_left_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_DTrees_Node_setLeft_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_DTrees_Node_right_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_DTrees_Node_setRight_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_DTrees_Node_defaultDir_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_DTrees_Node_setDefaultDir_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_DTrees_Node_split_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_DTrees_Node_setSplit_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_DTrees_Node_Node() -> Result<*mut c_void>;
		pub fn cv_ml_DTrees_Split_varIdx_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_DTrees_Split_setVarIdx_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_DTrees_Split_inversed_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_ml_DTrees_Split_setInversed_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_ml_DTrees_Split_quality_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_ml_DTrees_Split_setQuality_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_ml_DTrees_Split_next_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_DTrees_Split_setNext_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_DTrees_Split_c_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_ml_DTrees_Split_setC_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_ml_DTrees_Split_subsetOfs_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_DTrees_Split_setSubsetOfs_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_DTrees_Split_Split() -> Result<*mut c_void>;
		pub fn cv_ml_EM_getClustersNumber_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_EM_setClustersNumber_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_EM_getCovarianceMatrixType_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_EM_setCovarianceMatrixType_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_EM_getTermCriteria_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_EM_setTermCriteria_const_TermCriteriaX(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_ml_EM_getWeights_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_EM_getMeans_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_EM_getCovs_const_vector_Mat_X(instance: *mut c_void, covs: *mut c_void) -> Result_void;
		pub fn cv_ml_EM_predict_const_const__InputArrayX_const__OutputArrayX_int(instance: *mut c_void, samples: *mut c_void, results: *mut c_void, flags: i32) -> Result<f32>;
		pub fn cv_ml_EM_predict2_const_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, sample: *mut c_void, probs: *mut c_void) -> Result<core::Vec2d>;
		pub fn cv_ml_EM_trainEM_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, samples: *mut c_void, log_likelihoods: *mut c_void, labels: *mut c_void, probs: *mut c_void) -> Result<bool>;
		pub fn cv_ml_EM_trainE_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, samples: *mut c_void, means0: *mut c_void, covs0: *mut c_void, weights0: *mut c_void, log_likelihoods: *mut c_void, labels: *mut c_void, probs: *mut c_void) -> Result<bool>;
		pub fn cv_ml_EM_trainM_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, samples: *mut c_void, probs0: *mut c_void, log_likelihoods: *mut c_void, labels: *mut c_void, probs: *mut c_void) -> Result<bool>;
		pub fn cv_ml_EM_create() -> Result<*mut c_void>;
		pub fn cv_ml_EM_load_const_StringX_const_StringX(filepath: *const c_char, node_name: *const c_char) -> Result<*mut c_void>;
		pub fn cv_ml_KNearest_getDefaultK_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_KNearest_setDefaultK_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_KNearest_getIsClassifier_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_ml_KNearest_setIsClassifier_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_ml_KNearest_getEmax_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_KNearest_setEmax_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_KNearest_getAlgorithmType_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_KNearest_setAlgorithmType_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_KNearest_findNearest_const_const__InputArrayX_int_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, samples: *mut c_void, k: i32, results: *mut c_void, neighbor_responses: *mut c_void, dist: *mut c_void) -> Result<f32>;
		pub fn cv_ml_KNearest_create() -> Result<*mut c_void>;
		pub fn cv_ml_KNearest_load_const_StringX(filepath: *const c_char) -> Result<*mut c_void>;
		pub fn cv_ml_LogisticRegression_getLearningRate_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ml_LogisticRegression_setLearningRate_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_ml_LogisticRegression_getIterations_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_LogisticRegression_setIterations_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_LogisticRegression_getRegularization_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_LogisticRegression_setRegularization_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_LogisticRegression_getTrainMethod_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_LogisticRegression_setTrainMethod_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_LogisticRegression_getMiniBatchSize_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_LogisticRegression_setMiniBatchSize_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_LogisticRegression_getTermCriteria_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_LogisticRegression_setTermCriteria_TermCriteria(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_ml_LogisticRegression_predict_const_const__InputArrayX_const__OutputArrayX_int(instance: *mut c_void, samples: *mut c_void, results: *mut c_void, flags: i32) -> Result<f32>;
		pub fn cv_ml_LogisticRegression_get_learnt_thetas_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_LogisticRegression_create() -> Result<*mut c_void>;
		pub fn cv_ml_LogisticRegression_load_const_StringX_const_StringX(filepath: *const c_char, node_name: *const c_char) -> Result<*mut c_void>;
		pub fn cv_ml_NormalBayesClassifier_predictProb_const_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_int(instance: *mut c_void, inputs: *mut c_void, outputs: *mut c_void, output_probs: *mut c_void, flags: i32) -> Result<f32>;
		pub fn cv_ml_NormalBayesClassifier_create() -> Result<*mut c_void>;
		pub fn cv_ml_NormalBayesClassifier_load_const_StringX_const_StringX(filepath: *const c_char, node_name: *const c_char) -> Result<*mut c_void>;
		pub fn cv_ml_ParamGrid_minVal_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ml_ParamGrid_setMinVal_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_ml_ParamGrid_maxVal_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ml_ParamGrid_setMaxVal_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_ml_ParamGrid_logStep_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ml_ParamGrid_setLogStep_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_ml_ParamGrid_ParamGrid() -> Result<*mut c_void>;
		pub fn cv_ml_ParamGrid_ParamGrid_double_double_double(_min_val: f64, _max_val: f64, _log_step: f64) -> Result<*mut c_void>;
		pub fn cv_ml_ParamGrid_create_double_double_double(min_val: f64, max_val: f64, logstep: f64) -> Result<*mut c_void>;
		pub fn cv_ml_RTrees_getCalculateVarImportance_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_ml_RTrees_setCalculateVarImportance_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_ml_RTrees_getActiveVarCount_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_RTrees_setActiveVarCount_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_RTrees_getTermCriteria_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_RTrees_setTermCriteria_const_TermCriteriaX(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_ml_RTrees_getVarImportance_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_RTrees_getVotes_const_const__InputArrayX_const__OutputArrayX_int(instance: *mut c_void, samples: *mut c_void, results: *mut c_void, flags: i32) -> Result_void;
		pub fn cv_ml_RTrees_create() -> Result<*mut c_void>;
		pub fn cv_ml_RTrees_load_const_StringX_const_StringX(filepath: *const c_char, node_name: *const c_char) -> Result<*mut c_void>;
		pub fn cv_ml_SVM_getType_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_SVM_setType_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ml_SVM_getGamma_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ml_SVM_setGamma_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_ml_SVM_getCoef0_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ml_SVM_setCoef0_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_ml_SVM_getDegree_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ml_SVM_setDegree_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_ml_SVM_getC_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ml_SVM_setC_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_ml_SVM_getNu_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ml_SVM_setNu_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_ml_SVM_getP_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ml_SVM_setP_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_ml_SVM_getClassWeights_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_SVM_setClassWeights_const_MatX(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_ml_SVM_getTermCriteria_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_SVM_setTermCriteria_const_TermCriteriaX(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_ml_SVM_getKernelType_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_SVM_setKernel_int(instance: *mut c_void, kernel_type: i32) -> Result_void;
		pub fn cv_ml_SVM_setCustomKernel_const_Ptr_Kernel_X(instance: *mut c_void, _kernel: *mut c_void) -> Result_void;
		pub fn cv_ml_SVM_trainAuto_const_Ptr_TrainData_X_int_ParamGrid_ParamGrid_ParamGrid_ParamGrid_ParamGrid_ParamGrid_bool(instance: *mut c_void, data: *mut c_void, k_fold: i32, cgrid: *mut c_void, gamma_grid: *mut c_void, p_grid: *mut c_void, nu_grid: *mut c_void, coeff_grid: *mut c_void, degree_grid: *mut c_void, balanced: bool) -> Result<bool>;
		pub fn cv_ml_SVM_trainAuto_const__InputArrayX_int_const__InputArrayX_int_Ptr_ParamGrid__Ptr_ParamGrid__Ptr_ParamGrid__Ptr_ParamGrid__Ptr_ParamGrid__Ptr_ParamGrid__bool(instance: *mut c_void, samples: *mut c_void, layout: i32, responses: *mut c_void, k_fold: i32, cgrid: *mut c_void, gamma_grid: *mut c_void, p_grid: *mut c_void, nu_grid: *mut c_void, coeff_grid: *mut c_void, degree_grid: *mut c_void, balanced: bool) -> Result<bool>;
		pub fn cv_ml_SVM_getSupportVectors_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_SVM_getUncompressedSupportVectors_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_SVM_getDecisionFunction_const_int_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, i: i32, alpha: *mut c_void, svidx: *mut c_void) -> Result<f64>;
		pub fn cv_ml_SVM_getDefaultGrid_int(param_id: i32) -> Result<*mut c_void>;
		pub fn cv_ml_SVM_getDefaultGridPtr_int(param_id: i32) -> Result<*mut c_void>;
		pub fn cv_ml_SVM_create() -> Result<*mut c_void>;
		pub fn cv_ml_SVM_load_const_StringX(filepath: *const c_char) -> Result<*mut c_void>;
		pub fn cv_ml_SVM_Kernel_getType_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_SVM_Kernel_calc_int_int_const_floatX_const_floatX_floatX(instance: *mut c_void, vcount: i32, n: i32, vecs: *const f32, another: *const f32, results: *mut f32) -> Result_void;
		pub fn cv_ml_SVMSGD_getWeights(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_SVMSGD_getShift(instance: *mut c_void) -> Result<f32>;
		pub fn cv_ml_SVMSGD_create() -> Result<*mut c_void>;
		pub fn cv_ml_SVMSGD_load_const_StringX_const_StringX(filepath: *const c_char, node_name: *const c_char) -> Result<*mut c_void>;
		pub fn cv_ml_SVMSGD_setOptimalParameters_int_int(instance: *mut c_void, svmsgd_type: i32, margin_type: i32) -> Result_void;
		pub fn cv_ml_SVMSGD_getSvmsgdType_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_SVMSGD_setSvmsgdType_int(instance: *mut c_void, svmsgd_type: i32) -> Result_void;
		pub fn cv_ml_SVMSGD_getMarginType_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_SVMSGD_setMarginType_int(instance: *mut c_void, margin_type: i32) -> Result_void;
		pub fn cv_ml_SVMSGD_getMarginRegularization_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_ml_SVMSGD_setMarginRegularization_float(instance: *mut c_void, margin_regularization: f32) -> Result_void;
		pub fn cv_ml_SVMSGD_getInitialStepSize_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_ml_SVMSGD_setInitialStepSize_float(instance: *mut c_void, initial_step_size: f32) -> Result_void;
		pub fn cv_ml_SVMSGD_getStepDecreasingPower_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_ml_SVMSGD_setStepDecreasingPower_float(instance: *mut c_void, step_decreasing_power: f32) -> Result_void;
		pub fn cv_ml_SVMSGD_getTermCriteria_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_SVMSGD_setTermCriteria_const_TermCriteriaX(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_ml_StatModel_getVarCount_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_StatModel_empty_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_ml_StatModel_isTrained_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_ml_StatModel_isClassifier_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_ml_StatModel_train_const_Ptr_TrainData_X_int(instance: *mut c_void, train_data: *mut c_void, flags: i32) -> Result<bool>;
		pub fn cv_ml_StatModel_train_const__InputArrayX_int_const__InputArrayX(instance: *mut c_void, samples: *mut c_void, layout: i32, responses: *mut c_void) -> Result<bool>;
		pub fn cv_ml_StatModel_calcError_const_const_Ptr_TrainData_X_bool_const__OutputArrayX(instance: *mut c_void, data: *mut c_void, test: bool, resp: *mut c_void) -> Result<f32>;
		pub fn cv_ml_StatModel_predict_const_const__InputArrayX_const__OutputArrayX_int(instance: *mut c_void, samples: *mut c_void, results: *mut c_void, flags: i32) -> Result<f32>;
		pub fn cv_ml_TrainData_missingValue() -> Result<f32>;
		pub fn cv_ml_TrainData_getLayout_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_TrainData_getNTrainSamples_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_TrainData_getNTestSamples_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_TrainData_getNSamples_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_TrainData_getNVars_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_TrainData_getNAllVars_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_TrainData_getSample_const_const__InputArrayX_int_floatX(instance: *mut c_void, var_idx: *mut c_void, sidx: i32, buf: *mut f32) -> Result_void;
		pub fn cv_ml_TrainData_getSamples_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_TrainData_getMissing_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_TrainData_getTrainSamples_const_int_bool_bool(instance: *mut c_void, layout: i32, compress_samples: bool, compress_vars: bool) -> Result<*mut c_void>;
		pub fn cv_ml_TrainData_getTrainResponses_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_TrainData_getTrainNormCatResponses_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_TrainData_getTestResponses_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_TrainData_getTestNormCatResponses_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_TrainData_getResponses_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_TrainData_getNormCatResponses_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_TrainData_getSampleWeights_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_TrainData_getTrainSampleWeights_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_TrainData_getTestSampleWeights_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_TrainData_getVarIdx_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_TrainData_getVarType_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_TrainData_getVarSymbolFlags_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_TrainData_getResponseType_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ml_TrainData_getTrainSampleIdx_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_TrainData_getTestSampleIdx_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_TrainData_getValues_const_int_const__InputArrayX_floatX(instance: *mut c_void, vi: i32, sidx: *mut c_void, values: *mut f32) -> Result_void;
		pub fn cv_ml_TrainData_getNormCatValues_const_int_const__InputArrayX_intX(instance: *mut c_void, vi: i32, sidx: *mut c_void, values: *mut i32) -> Result_void;
		pub fn cv_ml_TrainData_getDefaultSubstValues_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_TrainData_getCatCount_const_int(instance: *mut c_void, vi: i32) -> Result<i32>;
		pub fn cv_ml_TrainData_getClassLabels_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_TrainData_getCatOfs_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_TrainData_getCatMap_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_TrainData_setTrainTestSplit_int_bool(instance: *mut c_void, count: i32, shuffle: bool) -> Result_void;
		pub fn cv_ml_TrainData_setTrainTestSplitRatio_double_bool(instance: *mut c_void, ratio: f64, shuffle: bool) -> Result_void;
		pub fn cv_ml_TrainData_shuffleTrainTest(instance: *mut c_void) -> Result_void;
		pub fn cv_ml_TrainData_getTestSamples_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_TrainData_getNames_const_vector_String_X(instance: *mut c_void, names: *mut c_void) -> Result_void;
		pub fn cv_ml_TrainData_getSubVector_const_MatX_const_MatX(vec: *mut c_void, idx: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ml_TrainData_getSubMatrix_const_MatX_const_MatX_int(matrix: *mut c_void, idx: *mut c_void, layout: i32) -> Result<*mut c_void>;
		pub fn cv_ml_TrainData_loadFromCSV_const_StringX_int_int_int_const_StringX_char_char(filename: *const c_char, header_line_count: i32, response_start_idx: i32, response_end_idx: i32, var_type_spec: *const c_char, delimiter: i8, missch: i8) -> Result<*mut c_void>;
		pub fn cv_ml_TrainData_create_const__InputArrayX_int_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX(samples: *mut c_void, layout: i32, responses: *mut c_void, var_idx: *mut c_void, sample_idx: *mut c_void, sample_weights: *mut c_void, var_type: *mut c_void) -> Result<*mut c_void>;
	}
}
pub use ml_sys::*;

mod objdetect_sys {
	use super::*;

	extern "C" {
		pub fn cv_createFaceDetectionMaskGenerator() -> Result<*mut c_void>;
		pub fn cv_groupRectangles_meanshift_vector_Rect_X_vector_double_X_vector_double_X_double_Size(rect_list: *mut c_void, found_weights: *mut c_void, found_scales: *mut c_void, detect_threshold: f64, win_det_size: *const core::Size) -> Result_void;
		pub fn cv_groupRectangles_vector_Rect_X_int_double(rect_list: *mut c_void, group_threshold: i32, eps: f64) -> Result_void;
		pub fn cv_groupRectangles_vector_Rect_X_int_double_vector_int_X_vector_double_X(rect_list: *mut c_void, group_threshold: i32, eps: f64, weights: *mut c_void, level_weights: *mut c_void) -> Result_void;
		pub fn cv_groupRectangles_vector_Rect_X_vector_int_X_int_double(rect_list: *mut c_void, weights: *mut c_void, group_threshold: i32, eps: f64) -> Result_void;
		pub fn cv_groupRectangles_vector_Rect_X_vector_int_X_vector_double_X_int_double(rect_list: *mut c_void, reject_levels: *mut c_void, level_weights: *mut c_void, group_threshold: i32, eps: f64) -> Result_void;
		pub fn cv_BaseCascadeClassifier_empty_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_BaseCascadeClassifier_load_const_StringX(instance: *mut c_void, filename: *const c_char) -> Result<bool>;
		pub fn cv_BaseCascadeClassifier_detectMultiScale_const__InputArrayX_vector_Rect_X_double_int_int_Size_Size(instance: *mut c_void, image: *mut c_void, objects: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: *const core::Size, max_size: *const core::Size) -> Result_void;
		pub fn cv_BaseCascadeClassifier_detectMultiScale_const__InputArrayX_vector_Rect_X_vector_int_X_double_int_int_Size_Size(instance: *mut c_void, image: *mut c_void, objects: *mut c_void, num_detections: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: *const core::Size, max_size: *const core::Size) -> Result_void;
		pub fn cv_BaseCascadeClassifier_detectMultiScale_const__InputArrayX_vector_Rect_X_vector_int_X_vector_double_X_double_int_int_Size_Size_bool(instance: *mut c_void, image: *mut c_void, objects: *mut c_void, reject_levels: *mut c_void, level_weights: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: *const core::Size, max_size: *const core::Size, output_reject_levels: bool) -> Result_void;
		pub fn cv_BaseCascadeClassifier_isOldFormatCascade_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_BaseCascadeClassifier_getOriginalWindowSize_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_BaseCascadeClassifier_getFeatureType_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_BaseCascadeClassifier_getOldCascade(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_BaseCascadeClassifier_setMaskGenerator_const_Ptr_MaskGenerator_X(instance: *mut c_void, mask_generator: *mut c_void) -> Result_void;
		pub fn cv_BaseCascadeClassifier_getMaskGenerator(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_BaseCascadeClassifier_MaskGenerator_generateMask_const_MatX(instance: *mut c_void, src: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_BaseCascadeClassifier_MaskGenerator_initializeMask_const_MatX(instance: *mut c_void, unnamed: *mut c_void) -> Result_void;
		pub fn cv_CascadeClassifier_cc(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_CascadeClassifier_setCc_Ptr_BaseCascadeClassifier_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_CascadeClassifier_CascadeClassifier() -> Result<*mut c_void>;
		pub fn cv_CascadeClassifier_CascadeClassifier_const_StringX(filename: *const c_char) -> Result<*mut c_void>;
		pub fn cv_CascadeClassifier_empty_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_CascadeClassifier_load_const_StringX(instance: *mut c_void, filename: *const c_char) -> Result<bool>;
		pub fn cv_CascadeClassifier_read_const_FileNodeX(instance: *mut c_void, node: *mut c_void) -> Result<bool>;
		pub fn cv_CascadeClassifier_detectMultiScale_const__InputArrayX_vector_Rect_X_double_int_int_Size_Size(instance: *mut c_void, image: *mut c_void, objects: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: *const core::Size, max_size: *const core::Size) -> Result_void;
		pub fn cv_CascadeClassifier_detectMultiScale_const__InputArrayX_vector_Rect_X_vector_int_X_double_int_int_Size_Size(instance: *mut c_void, image: *mut c_void, objects: *mut c_void, num_detections: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: *const core::Size, max_size: *const core::Size) -> Result_void;
		pub fn cv_CascadeClassifier_detectMultiScale_const__InputArrayX_vector_Rect_X_vector_int_X_vector_double_X_double_int_int_Size_Size_bool(instance: *mut c_void, image: *mut c_void, objects: *mut c_void, reject_levels: *mut c_void, level_weights: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: *const core::Size, max_size: *const core::Size, output_reject_levels: bool) -> Result_void;
		pub fn cv_CascadeClassifier_isOldFormatCascade_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_CascadeClassifier_getOriginalWindowSize_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_CascadeClassifier_getFeatureType_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_CascadeClassifier_getOldCascade(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_CascadeClassifier_convert_const_StringX_const_StringX(oldcascade: *const c_char, newcascade: *const c_char) -> Result<bool>;
		pub fn cv_CascadeClassifier_setMaskGenerator_const_Ptr_MaskGenerator_X(instance: *mut c_void, mask_generator: *mut c_void) -> Result_void;
		pub fn cv_CascadeClassifier_getMaskGenerator(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_DetectionBasedTracker_DetectionBasedTracker_Ptr_IDetector__Ptr_IDetector__const_ParametersX(main_detector: *mut c_void, tracking_detector: *mut c_void, params: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_DetectionBasedTracker_run(instance: *mut c_void) -> Result<bool>;
		pub fn cv_DetectionBasedTracker_stop(instance: *mut c_void) -> Result_void;
		pub fn cv_DetectionBasedTracker_resetTracking(instance: *mut c_void) -> Result_void;
		pub fn cv_DetectionBasedTracker_process_const_MatX(instance: *mut c_void, image_gray: *mut c_void) -> Result_void;
		pub fn cv_DetectionBasedTracker_setParameters_const_ParametersX(instance: *mut c_void, params: *mut c_void) -> Result<bool>;
		pub fn cv_DetectionBasedTracker_getParameters_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_DetectionBasedTracker_getObjects_const_vector_Rect_X(instance: *mut c_void, result: *mut c_void) -> Result_void;
		pub fn cv_DetectionBasedTracker_getObjects_const_vector_ExtObject_X(instance: *mut c_void, result: *mut c_void) -> Result_void;
		pub fn cv_DetectionBasedTracker_addObject_const_RectX(instance: *mut c_void, location: *const core::Rect) -> Result<i32>;
		pub fn cv_DetectionBasedTracker_ExtObject_id_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_DetectionBasedTracker_ExtObject_setId_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_DetectionBasedTracker_ExtObject_location_const(instance: *mut c_void) -> Result<core::Rect>;
		pub fn cv_DetectionBasedTracker_ExtObject_setLocation_Rect(instance: *mut c_void, val: *const core::Rect) -> Result_void;
		pub fn cv_DetectionBasedTracker_ExtObject_status_const(instance: *mut c_void) -> Result<crate::objdetect::DetectionBasedTracker_ObjectStatus>;
		pub fn cv_DetectionBasedTracker_ExtObject_setStatus_ObjectStatus(instance: *mut c_void, val: crate::objdetect::DetectionBasedTracker_ObjectStatus) -> Result_void;
		pub fn cv_DetectionBasedTracker_ExtObject_ExtObject_int_Rect_ObjectStatus(_id: i32, _location: *const core::Rect, _status: crate::objdetect::DetectionBasedTracker_ObjectStatus) -> Result<*mut c_void>;
		pub fn cv_DetectionBasedTracker_IDetector_detect_const_MatX_vector_Rect_X(instance: *mut c_void, image: *mut c_void, objects: *mut c_void) -> Result_void;
		pub fn cv_DetectionBasedTracker_IDetector_setMinObjectSize_const_SizeX(instance: *mut c_void, min: *const core::Size) -> Result_void;
		pub fn cv_DetectionBasedTracker_IDetector_setMaxObjectSize_const_SizeX(instance: *mut c_void, max: *const core::Size) -> Result_void;
		pub fn cv_DetectionBasedTracker_IDetector_getMinObjectSize_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_DetectionBasedTracker_IDetector_getMaxObjectSize_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_DetectionBasedTracker_IDetector_getScaleFactor(instance: *mut c_void) -> Result<f32>;
		pub fn cv_DetectionBasedTracker_IDetector_setScaleFactor_float(instance: *mut c_void, value: f32) -> Result_void;
		pub fn cv_DetectionBasedTracker_IDetector_getMinNeighbours(instance: *mut c_void) -> Result<i32>;
		pub fn cv_DetectionBasedTracker_IDetector_setMinNeighbours_int(instance: *mut c_void, value: i32) -> Result_void;
		pub fn cv_DetectionBasedTracker_Parameters_maxTrackLifetime_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_DetectionBasedTracker_Parameters_setMaxTrackLifetime_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_DetectionBasedTracker_Parameters_minDetectionPeriod_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_DetectionBasedTracker_Parameters_setMinDetectionPeriod_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_DetectionBasedTracker_Parameters_Parameters() -> Result<*mut c_void>;
		pub fn cv_DetectionROI_scale_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_DetectionROI_setScale_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_DetectionROI_locations(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_DetectionROI_setLocations_vector_Point_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_DetectionROI_confidences(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_DetectionROI_setConfidences_vector_double_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_HOGDescriptor_winSize_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_HOGDescriptor_setWinSize_Size(instance: *mut c_void, val: *const core::Size) -> Result_void;
		pub fn cv_HOGDescriptor_blockSize_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_HOGDescriptor_setBlockSize_Size(instance: *mut c_void, val: *const core::Size) -> Result_void;
		pub fn cv_HOGDescriptor_blockStride_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_HOGDescriptor_setBlockStride_Size(instance: *mut c_void, val: *const core::Size) -> Result_void;
		pub fn cv_HOGDescriptor_cellSize_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_HOGDescriptor_setCellSize_Size(instance: *mut c_void, val: *const core::Size) -> Result_void;
		pub fn cv_HOGDescriptor_nbins_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_HOGDescriptor_setNbins_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_HOGDescriptor_derivAperture_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_HOGDescriptor_setDerivAperture_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_HOGDescriptor_winSigma_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_HOGDescriptor_setWinSigma_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_HOGDescriptor_histogramNormType_const(instance: *mut c_void) -> Result<crate::objdetect::HOGDescriptor_HistogramNormType>;
		pub fn cv_HOGDescriptor_setHistogramNormType_HistogramNormType(instance: *mut c_void, val: crate::objdetect::HOGDescriptor_HistogramNormType) -> Result_void;
		pub fn cv_HOGDescriptor_L2HysThreshold_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_HOGDescriptor_setL2HysThreshold_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_HOGDescriptor_gammaCorrection_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_HOGDescriptor_setGammaCorrection_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_HOGDescriptor_svmDetector(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_HOGDescriptor_setSvmDetector_vector_float_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_HOGDescriptor_oclSvmDetector(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_HOGDescriptor_setOclSvmDetector_UMat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_HOGDescriptor_free_coef_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_HOGDescriptor_setFree_coef_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_HOGDescriptor_nlevels_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_HOGDescriptor_setNlevels_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_HOGDescriptor_signedGradient_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_HOGDescriptor_setSignedGradient_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_HOGDescriptor_HOGDescriptor() -> Result<*mut c_void>;
		pub fn cv_HOGDescriptor_HOGDescriptor_Size_Size_Size_Size_int_int_double_HistogramNormType_double_bool_int_bool(_win_size: *const core::Size, _block_size: *const core::Size, _block_stride: *const core::Size, _cell_size: *const core::Size, _nbins: i32, _deriv_aperture: i32, _win_sigma: f64, _histogram_norm_type: crate::objdetect::HOGDescriptor_HistogramNormType, _l2_hys_threshold: f64, _gamma_correction: bool, _nlevels: i32, _signed_gradient: bool) -> Result<*mut c_void>;
		pub fn cv_HOGDescriptor_HOGDescriptor_const_StringX(filename: *const c_char) -> Result<*mut c_void>;
		pub fn cv_HOGDescriptor_HOGDescriptor_const_HOGDescriptorX(d: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_HOGDescriptor_getDescriptorSize_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_HOGDescriptor_checkDetectorSize_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_HOGDescriptor_getWinSigma_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_HOGDescriptor_setSVMDetector_const__InputArrayX(instance: *mut c_void, svmdetector: *mut c_void) -> Result_void;
		pub fn cv_HOGDescriptor_read_FileNodeX(instance: *mut c_void, fn_: *mut c_void) -> Result<bool>;
		pub fn cv_HOGDescriptor_write_const_FileStorageX_const_StringX(instance: *mut c_void, fs: *mut c_void, objname: *const c_char) -> Result_void;
		pub fn cv_HOGDescriptor_load_const_StringX_const_StringX(instance: *mut c_void, filename: *const c_char, objname: *const c_char) -> Result<bool>;
		pub fn cv_HOGDescriptor_save_const_const_StringX_const_StringX(instance: *mut c_void, filename: *const c_char, objname: *const c_char) -> Result_void;
		pub fn cv_HOGDescriptor_copyTo_const_HOGDescriptorX(instance: *mut c_void, c: *mut c_void) -> Result_void;
		pub fn cv_HOGDescriptor_compute_const_const__InputArrayX_vector_float_X_Size_Size_const_vector_Point_X(instance: *mut c_void, img: *mut c_void, descriptors: *mut c_void, win_stride: *const core::Size, padding: *const core::Size, locations: *mut c_void) -> Result_void;
		pub fn cv_HOGDescriptor_detect_const_const__InputArrayX_vector_Point_X_vector_double_X_double_Size_Size_const_vector_Point_X(instance: *mut c_void, img: *mut c_void, found_locations: *mut c_void, weights: *mut c_void, hit_threshold: f64, win_stride: *const core::Size, padding: *const core::Size, search_locations: *mut c_void) -> Result_void;
		pub fn cv_HOGDescriptor_detect_const_const__InputArrayX_vector_Point_X_double_Size_Size_const_vector_Point_X(instance: *mut c_void, img: *mut c_void, found_locations: *mut c_void, hit_threshold: f64, win_stride: *const core::Size, padding: *const core::Size, search_locations: *mut c_void) -> Result_void;
		pub fn cv_HOGDescriptor_detectMultiScale_const_const__InputArrayX_vector_Rect_X_vector_double_X_double_Size_Size_double_double_bool(instance: *mut c_void, img: *mut c_void, found_locations: *mut c_void, found_weights: *mut c_void, hit_threshold: f64, win_stride: *const core::Size, padding: *const core::Size, scale: f64, final_threshold: f64, use_meanshift_grouping: bool) -> Result_void;
		pub fn cv_HOGDescriptor_detectMultiScale_const_const__InputArrayX_vector_Rect_X_double_Size_Size_double_double_bool(instance: *mut c_void, img: *mut c_void, found_locations: *mut c_void, hit_threshold: f64, win_stride: *const core::Size, padding: *const core::Size, scale: f64, final_threshold: f64, use_meanshift_grouping: bool) -> Result_void;
		pub fn cv_HOGDescriptor_computeGradient_const_const__InputArrayX_const__InputOutputArrayX_const__InputOutputArrayX_Size_Size(instance: *mut c_void, img: *mut c_void, grad: *mut c_void, angle_ofs: *mut c_void, padding_tl: *const core::Size, padding_br: *const core::Size) -> Result_void;
		pub fn cv_HOGDescriptor_getDefaultPeopleDetector() -> Result<*mut c_void>;
		pub fn cv_HOGDescriptor_getDaimlerPeopleDetector() -> Result<*mut c_void>;
		pub fn cv_HOGDescriptor_detectROI_const_const__InputArrayX_const_vector_Point_X_vector_Point_X_vector_double_X_double_Size_Size(instance: *mut c_void, img: *mut c_void, locations: *mut c_void, found_locations: *mut c_void, confidences: *mut c_void, hit_threshold: f64, win_stride: *const core::Size, padding: *const core::Size) -> Result_void;
		pub fn cv_HOGDescriptor_detectMultiScaleROI_const_const__InputArrayX_vector_Rect_X_vector_DetectionROI_X_double_int(instance: *mut c_void, img: *mut c_void, found_locations: *mut c_void, locations: *mut c_void, hit_threshold: f64, group_threshold: i32) -> Result_void;
		pub fn cv_HOGDescriptor_groupRectangles_const_vector_Rect_X_vector_double_X_int_double(instance: *mut c_void, rect_list: *mut c_void, weights: *mut c_void, group_threshold: i32, eps: f64) -> Result_void;
		pub fn cv_QRCodeDetector_QRCodeDetector() -> Result<*mut c_void>;
		pub fn cv_QRCodeDetector_setEpsX_double(instance: *mut c_void, eps_x: f64) -> Result_void;
		pub fn cv_QRCodeDetector_setEpsY_double(instance: *mut c_void, eps_y: f64) -> Result_void;
		pub fn cv_QRCodeDetector_detect_const_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, img: *mut c_void, points: *mut c_void) -> Result<bool>;
		pub fn cv_QRCodeDetector_decode_const__InputArrayX_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, img: *mut c_void, points: *mut c_void, straight_qrcode: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_QRCodeDetector_detectAndDecode_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, img: *mut c_void, points: *mut c_void, straight_qrcode: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_SimilarRects_eps_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_SimilarRects_setEps_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_SimilarRects_SimilarRects_double(_eps: f64) -> Result<*mut c_void>;
	}
}
pub use objdetect_sys::*;

#[cfg(feature = "contrib")]
mod phase_unwrapping_sys {
	use super::*;

	extern "C" {
		pub fn cv_phase_unwrapping_HistogramPhaseUnwrapping_create_const_ParamsX(parameters: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_phase_unwrapping_HistogramPhaseUnwrapping_getInverseReliabilityMap_const__OutputArrayX(instance: *mut c_void, reliability_map: *mut c_void) -> Result_void;
		pub fn cv_phase_unwrapping_HistogramPhaseUnwrapping_Params_width_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_phase_unwrapping_HistogramPhaseUnwrapping_Params_setWidth_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_phase_unwrapping_HistogramPhaseUnwrapping_Params_height_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_phase_unwrapping_HistogramPhaseUnwrapping_Params_setHeight_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_phase_unwrapping_HistogramPhaseUnwrapping_Params_histThresh_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_phase_unwrapping_HistogramPhaseUnwrapping_Params_setHistThresh_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_phase_unwrapping_HistogramPhaseUnwrapping_Params_nbrOfSmallBins_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_phase_unwrapping_HistogramPhaseUnwrapping_Params_setNbrOfSmallBins_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_phase_unwrapping_HistogramPhaseUnwrapping_Params_nbrOfLargeBins_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_phase_unwrapping_HistogramPhaseUnwrapping_Params_setNbrOfLargeBins_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_phase_unwrapping_HistogramPhaseUnwrapping_Params_Params() -> Result<*mut c_void>;
		pub fn cv_phase_unwrapping_PhaseUnwrapping_unwrapPhaseMap_const__InputArrayX_const__OutputArrayX_const__InputArrayX(instance: *mut c_void, wrapped_phase_map: *mut c_void, unwrapped_phase_map: *mut c_void, shadow_mask: *mut c_void) -> Result_void;
	}
}
#[cfg(feature = "contrib")]
pub use phase_unwrapping_sys::*;

mod photo_sys {
	use super::*;

	extern "C" {
		pub fn cv_colorChange_const__InputArrayX_const__InputArrayX_const__OutputArrayX_float_float_float(src: *mut c_void, mask: *mut c_void, dst: *mut c_void, red_mul: f32, green_mul: f32, blue_mul: f32) -> Result_void;
		pub fn cv_createAlignMTB_int_int_bool(max_bits: i32, exclude_range: i32, cut: bool) -> Result<*mut c_void>;
		pub fn cv_createCalibrateDebevec_int_float_bool(samples: i32, lambda: f32, random: bool) -> Result<*mut c_void>;
		pub fn cv_createCalibrateRobertson_int_float(max_iter: i32, threshold: f32) -> Result<*mut c_void>;
		pub fn cv_createMergeDebevec() -> Result<*mut c_void>;
		pub fn cv_createMergeMertens_float_float_float(contrast_weight: f32, saturation_weight: f32, exposure_weight: f32) -> Result<*mut c_void>;
		pub fn cv_createMergeRobertson() -> Result<*mut c_void>;
		pub fn cv_createTonemapDrago_float_float_float(gamma: f32, saturation: f32, bias: f32) -> Result<*mut c_void>;
		pub fn cv_createTonemapMantiuk_float_float_float(gamma: f32, scale: f32, saturation: f32) -> Result<*mut c_void>;
		pub fn cv_createTonemapReinhard_float_float_float_float(gamma: f32, intensity: f32, light_adapt: f32, color_adapt: f32) -> Result<*mut c_void>;
		pub fn cv_createTonemap_float(gamma: f32) -> Result<*mut c_void>;
		pub fn cv_decolor_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(src: *mut c_void, grayscale: *mut c_void, color_boost: *mut c_void) -> Result_void;
		pub fn cv_denoise_TVL1_const_vector_Mat_X_MatX_double_int(observations: *mut c_void, result: *mut c_void, lambda: f64, niters: i32) -> Result_void;
		pub fn cv_detailEnhance_const__InputArrayX_const__OutputArrayX_float_float(src: *mut c_void, dst: *mut c_void, sigma_s: f32, sigma_r: f32) -> Result_void;
		pub fn cv_edgePreservingFilter_const__InputArrayX_const__OutputArrayX_int_float_float(src: *mut c_void, dst: *mut c_void, flags: i32, sigma_s: f32, sigma_r: f32) -> Result_void;
		pub fn cv_fastNlMeansDenoisingColoredMulti_const__InputArrayX_const__OutputArrayX_int_int_float_float_int_int(src_imgs: *mut c_void, dst: *mut c_void, img_to_denoise_index: i32, temporal_window_size: i32, h: f32, h_color: f32, template_window_size: i32, search_window_size: i32) -> Result_void;
		pub fn cv_fastNlMeansDenoisingColored_const__InputArrayX_const__OutputArrayX_float_float_int_int(src: *mut c_void, dst: *mut c_void, h: f32, h_color: f32, template_window_size: i32, search_window_size: i32) -> Result_void;
		pub fn cv_fastNlMeansDenoisingMulti_const__InputArrayX_const__OutputArrayX_int_int_const_vector_float_X_int_int_int(src_imgs: *mut c_void, dst: *mut c_void, img_to_denoise_index: i32, temporal_window_size: i32, h: *mut c_void, template_window_size: i32, search_window_size: i32, norm_type: i32) -> Result_void;
		pub fn cv_fastNlMeansDenoisingMulti_const__InputArrayX_const__OutputArrayX_int_int_float_int_int(src_imgs: *mut c_void, dst: *mut c_void, img_to_denoise_index: i32, temporal_window_size: i32, h: f32, template_window_size: i32, search_window_size: i32) -> Result_void;
		pub fn cv_fastNlMeansDenoising_const__InputArrayX_const__OutputArrayX_const_vector_float_X_int_int_int(src: *mut c_void, dst: *mut c_void, h: *mut c_void, template_window_size: i32, search_window_size: i32, norm_type: i32) -> Result_void;
		pub fn cv_fastNlMeansDenoising_const__InputArrayX_const__OutputArrayX_float_int_int(src: *mut c_void, dst: *mut c_void, h: f32, template_window_size: i32, search_window_size: i32) -> Result_void;
		pub fn cv_illuminationChange_const__InputArrayX_const__InputArrayX_const__OutputArrayX_float_float(src: *mut c_void, mask: *mut c_void, dst: *mut c_void, alpha: f32, beta: f32) -> Result_void;
		pub fn cv_inpaint_const__InputArrayX_const__InputArrayX_const__OutputArrayX_double_int(src: *mut c_void, inpaint_mask: *mut c_void, dst: *mut c_void, inpaint_radius: f64, flags: i32) -> Result_void;
		pub fn cv_pencilSketch_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_float_float_float(src: *mut c_void, dst1: *mut c_void, dst2: *mut c_void, sigma_s: f32, sigma_r: f32, shade_factor: f32) -> Result_void;
		pub fn cv_seamlessClone_const__InputArrayX_const__InputArrayX_const__InputArrayX_Point_const__OutputArrayX_int(src: *mut c_void, dst: *mut c_void, mask: *mut c_void, p: *const core::Point, blend: *mut c_void, flags: i32) -> Result_void;
		pub fn cv_stylization_const__InputArrayX_const__OutputArrayX_float_float(src: *mut c_void, dst: *mut c_void, sigma_s: f32, sigma_r: f32) -> Result_void;
		pub fn cv_textureFlattening_const__InputArrayX_const__InputArrayX_const__OutputArrayX_float_float_int(src: *mut c_void, mask: *mut c_void, dst: *mut c_void, low_threshold: f32, high_threshold: f32, kernel_size: i32) -> Result_void;
		pub fn cv_AlignExposures_process_const__InputArrayX_vector_Mat_X_const__InputArrayX_const__InputArrayX(instance: *mut c_void, src: *mut c_void, dst: *mut c_void, times: *mut c_void, response: *mut c_void) -> Result_void;
		pub fn cv_AlignMTB_process_const__InputArrayX_vector_Mat_X_const__InputArrayX_const__InputArrayX(instance: *mut c_void, src: *mut c_void, dst: *mut c_void, times: *mut c_void, response: *mut c_void) -> Result_void;
		pub fn cv_AlignMTB_process_const__InputArrayX_vector_Mat_X(instance: *mut c_void, src: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_AlignMTB_calculateShift_const__InputArrayX_const__InputArrayX(instance: *mut c_void, img0: *mut c_void, img1: *mut c_void) -> Result<core::Point>;
		pub fn cv_AlignMTB_shiftMat_const__InputArrayX_const__OutputArrayX_Point(instance: *mut c_void, src: *mut c_void, dst: *mut c_void, shift: *const core::Point) -> Result_void;
		pub fn cv_AlignMTB_computeBitmaps_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, img: *mut c_void, tb: *mut c_void, eb: *mut c_void) -> Result_void;
		pub fn cv_AlignMTB_getMaxBits_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_AlignMTB_setMaxBits_int(instance: *mut c_void, max_bits: i32) -> Result_void;
		pub fn cv_AlignMTB_getExcludeRange_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_AlignMTB_setExcludeRange_int(instance: *mut c_void, exclude_range: i32) -> Result_void;
		pub fn cv_AlignMTB_getCut_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_AlignMTB_setCut_bool(instance: *mut c_void, value: bool) -> Result_void;
		pub fn cv_CalibrateCRF_process_const__InputArrayX_const__OutputArrayX_const__InputArrayX(instance: *mut c_void, src: *mut c_void, dst: *mut c_void, times: *mut c_void) -> Result_void;
		pub fn cv_CalibrateDebevec_getLambda_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_CalibrateDebevec_setLambda_float(instance: *mut c_void, lambda: f32) -> Result_void;
		pub fn cv_CalibrateDebevec_getSamples_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_CalibrateDebevec_setSamples_int(instance: *mut c_void, samples: i32) -> Result_void;
		pub fn cv_CalibrateDebevec_getRandom_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_CalibrateDebevec_setRandom_bool(instance: *mut c_void, random: bool) -> Result_void;
		pub fn cv_CalibrateRobertson_getMaxIter_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_CalibrateRobertson_setMaxIter_int(instance: *mut c_void, max_iter: i32) -> Result_void;
		pub fn cv_CalibrateRobertson_getThreshold_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_CalibrateRobertson_setThreshold_float(instance: *mut c_void, threshold: f32) -> Result_void;
		pub fn cv_CalibrateRobertson_getRadiance_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_MergeDebevec_process_const__InputArrayX_const__OutputArrayX_const__InputArrayX_const__InputArrayX(instance: *mut c_void, src: *mut c_void, dst: *mut c_void, times: *mut c_void, response: *mut c_void) -> Result_void;
		pub fn cv_MergeDebevec_process_const__InputArrayX_const__OutputArrayX_const__InputArrayX(instance: *mut c_void, src: *mut c_void, dst: *mut c_void, times: *mut c_void) -> Result_void;
		pub fn cv_MergeExposures_process_const__InputArrayX_const__OutputArrayX_const__InputArrayX_const__InputArrayX(instance: *mut c_void, src: *mut c_void, dst: *mut c_void, times: *mut c_void, response: *mut c_void) -> Result_void;
		pub fn cv_MergeMertens_process_const__InputArrayX_const__OutputArrayX_const__InputArrayX_const__InputArrayX(instance: *mut c_void, src: *mut c_void, dst: *mut c_void, times: *mut c_void, response: *mut c_void) -> Result_void;
		pub fn cv_MergeMertens_process_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, src: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_MergeMertens_getContrastWeight_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_MergeMertens_setContrastWeight_float(instance: *mut c_void, contrast_weiht: f32) -> Result_void;
		pub fn cv_MergeMertens_getSaturationWeight_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_MergeMertens_setSaturationWeight_float(instance: *mut c_void, saturation_weight: f32) -> Result_void;
		pub fn cv_MergeMertens_getExposureWeight_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_MergeMertens_setExposureWeight_float(instance: *mut c_void, exposure_weight: f32) -> Result_void;
		pub fn cv_MergeRobertson_process_const__InputArrayX_const__OutputArrayX_const__InputArrayX_const__InputArrayX(instance: *mut c_void, src: *mut c_void, dst: *mut c_void, times: *mut c_void, response: *mut c_void) -> Result_void;
		pub fn cv_MergeRobertson_process_const__InputArrayX_const__OutputArrayX_const__InputArrayX(instance: *mut c_void, src: *mut c_void, dst: *mut c_void, times: *mut c_void) -> Result_void;
		pub fn cv_Tonemap_process_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, src: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_Tonemap_getGamma_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_Tonemap_setGamma_float(instance: *mut c_void, gamma: f32) -> Result_void;
		pub fn cv_TonemapDrago_getSaturation_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_TonemapDrago_setSaturation_float(instance: *mut c_void, saturation: f32) -> Result_void;
		pub fn cv_TonemapDrago_getBias_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_TonemapDrago_setBias_float(instance: *mut c_void, bias: f32) -> Result_void;
		pub fn cv_TonemapMantiuk_getScale_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_TonemapMantiuk_setScale_float(instance: *mut c_void, scale: f32) -> Result_void;
		pub fn cv_TonemapMantiuk_getSaturation_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_TonemapMantiuk_setSaturation_float(instance: *mut c_void, saturation: f32) -> Result_void;
		pub fn cv_TonemapReinhard_getIntensity_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_TonemapReinhard_setIntensity_float(instance: *mut c_void, intensity: f32) -> Result_void;
		pub fn cv_TonemapReinhard_getLightAdaptation_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_TonemapReinhard_setLightAdaptation_float(instance: *mut c_void, light_adapt: f32) -> Result_void;
		pub fn cv_TonemapReinhard_getColorAdaptation_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_TonemapReinhard_setColorAdaptation_float(instance: *mut c_void, color_adapt: f32) -> Result_void;
	}
}
pub use photo_sys::*;

#[cfg(feature = "contrib")]
mod plot_sys {
	use super::*;

	extern "C" {
		pub fn cv_plot_Plot2d_setMinX_double(instance: *mut c_void, _plot_min_x: f64) -> Result_void;
		pub fn cv_plot_Plot2d_setMinY_double(instance: *mut c_void, _plot_min_y: f64) -> Result_void;
		pub fn cv_plot_Plot2d_setMaxX_double(instance: *mut c_void, _plot_max_x: f64) -> Result_void;
		pub fn cv_plot_Plot2d_setMaxY_double(instance: *mut c_void, _plot_max_y: f64) -> Result_void;
		pub fn cv_plot_Plot2d_setPlotLineWidth_int(instance: *mut c_void, _plot_line_width: i32) -> Result_void;
		pub fn cv_plot_Plot2d_setNeedPlotLine_bool(instance: *mut c_void, _need_plot_line: bool) -> Result_void;
		pub fn cv_plot_Plot2d_setPlotLineColor_Scalar(instance: *mut c_void, _plot_line_color: *const core::Scalar) -> Result_void;
		pub fn cv_plot_Plot2d_setPlotBackgroundColor_Scalar(instance: *mut c_void, _plot_background_color: *const core::Scalar) -> Result_void;
		pub fn cv_plot_Plot2d_setPlotAxisColor_Scalar(instance: *mut c_void, _plot_axis_color: *const core::Scalar) -> Result_void;
		pub fn cv_plot_Plot2d_setPlotGridColor_Scalar(instance: *mut c_void, _plot_grid_color: *const core::Scalar) -> Result_void;
		pub fn cv_plot_Plot2d_setPlotTextColor_Scalar(instance: *mut c_void, _plot_text_color: *const core::Scalar) -> Result_void;
		pub fn cv_plot_Plot2d_setPlotSize_int_int(instance: *mut c_void, _plot_size_width: i32, _plot_size_height: i32) -> Result_void;
		pub fn cv_plot_Plot2d_setShowGrid_bool(instance: *mut c_void, need_show_grid: bool) -> Result_void;
		pub fn cv_plot_Plot2d_setShowText_bool(instance: *mut c_void, need_show_text: bool) -> Result_void;
		pub fn cv_plot_Plot2d_setGridLinesNumber_int(instance: *mut c_void, grid_lines_number: i32) -> Result_void;
		pub fn cv_plot_Plot2d_setInvertOrientation_bool(instance: *mut c_void, _invert_orientation: bool) -> Result_void;
		pub fn cv_plot_Plot2d_setPointIdxToPrint_int(instance: *mut c_void, point_idx: i32) -> Result_void;
		pub fn cv_plot_Plot2d_render_const__OutputArrayX(instance: *mut c_void, _plot_result: *mut c_void) -> Result_void;
		pub fn cv_plot_Plot2d_create_const__InputArrayX(data: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_plot_Plot2d_create_const__InputArrayX_const__InputArrayX(data_x: *mut c_void, data_y: *mut c_void) -> Result<*mut c_void>;
	}
}
#[cfg(feature = "contrib")]
pub use plot_sys::*;

#[cfg(feature = "contrib")]
mod sfm_sys {
	use super::*;

	extern "C" {
		pub fn cv_sfm_KRtFromProjection_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX(p: *mut c_void, k: *mut c_void, r: *mut c_void, t: *mut c_void) -> Result_void;
		pub fn cv_sfm_applyTransformationToPoints_const__InputArrayX_const__InputArrayX_const__OutputArrayX(points: *mut c_void, t: *mut c_void, transformed_points: *mut c_void) -> Result_void;
		pub fn cv_sfm_computeOrientation_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_double(x1: *mut c_void, x2: *mut c_void, r: *mut c_void, t: *mut c_void, s: f64) -> Result_void;
		pub fn cv_sfm_depth_const__InputArrayX_const__InputArrayX_const__InputArrayX(r: *mut c_void, t: *mut c_void, x: *mut c_void) -> Result<f64>;
		pub fn cv_sfm_essentialFromFundamental_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX(f: *mut c_void, k1: *mut c_void, k2: *mut c_void, e: *mut c_void) -> Result_void;
		pub fn cv_sfm_essentialFromRt_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX(r1: *mut c_void, t1: *mut c_void, r2: *mut c_void, t2: *mut c_void, e: *mut c_void) -> Result_void;
		pub fn cv_sfm_euclideanToHomogeneous_const__InputArrayX_const__OutputArrayX(src: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_sfm_fundamentalFromCorrespondences7PointRobust_const__InputArrayX_const__InputArrayX_double_const__OutputArrayX_const__OutputArrayX_double(x1: *mut c_void, x2: *mut c_void, max_error: f64, f: *mut c_void, inliers: *mut c_void, outliers_probability: f64) -> Result<f64>;
		pub fn cv_sfm_fundamentalFromCorrespondences8PointRobust_const__InputArrayX_const__InputArrayX_double_const__OutputArrayX_const__OutputArrayX_double(x1: *mut c_void, x2: *mut c_void, max_error: f64, f: *mut c_void, inliers: *mut c_void, outliers_probability: f64) -> Result<f64>;
		pub fn cv_sfm_fundamentalFromEssential_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX(e: *mut c_void, k1: *mut c_void, k2: *mut c_void, f: *mut c_void) -> Result_void;
		pub fn cv_sfm_fundamentalFromProjections_const__InputArrayX_const__InputArrayX_const__OutputArrayX(p1: *mut c_void, p2: *mut c_void, f: *mut c_void) -> Result_void;
		pub fn cv_sfm_homogeneousToEuclidean_const__InputArrayX_const__OutputArrayX(src: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_sfm_importReconstruction_const_StringX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX_int(file: *const c_char, rs: *mut c_void, ts: *mut c_void, ks: *mut c_void, points3d: *mut c_void, file_format: i32) -> Result_void;
		pub fn cv_sfm_isotropicPreconditionerFromPoints_const__InputArrayX_const__OutputArrayX(points: *mut c_void, t: *mut c_void) -> Result_void;
		pub fn cv_sfm_meanAndVarianceAlongRows_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(a: *mut c_void, mean: *mut c_void, variance: *mut c_void) -> Result_void;
		pub fn cv_sfm_motionFromEssentialChooseSolution_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX(rs: *mut c_void, ts: *mut c_void, k1: *mut c_void, x1: *mut c_void, k2: *mut c_void, x2: *mut c_void) -> Result<i32>;
		pub fn cv_sfm_motionFromEssential_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(e: *mut c_void, rs: *mut c_void, ts: *mut c_void) -> Result_void;
		pub fn cv_sfm_normalizeFundamental_const__InputArrayX_const__OutputArrayX(f: *mut c_void, f_normalized: *mut c_void) -> Result_void;
		pub fn cv_sfm_normalizeIsotropicPoints_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(points: *mut c_void, normalized_points: *mut c_void, t: *mut c_void) -> Result_void;
		pub fn cv_sfm_normalizePoints_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(points: *mut c_void, normalized_points: *mut c_void, t: *mut c_void) -> Result_void;
		pub fn cv_sfm_normalizedEightPointSolver_const__InputArrayX_const__InputArrayX_const__OutputArrayX(x1: *mut c_void, x2: *mut c_void, f: *mut c_void) -> Result_void;
		pub fn cv_sfm_preconditionerFromPoints_const__InputArrayX_const__OutputArrayX(points: *mut c_void, t: *mut c_void) -> Result_void;
		pub fn cv_sfm_projectionFromKRt_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX(k: *mut c_void, r: *mut c_void, t: *mut c_void, p: *mut c_void) -> Result_void;
		pub fn cv_sfm_projectionsFromFundamental_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(f: *mut c_void, p1: *mut c_void, p2: *mut c_void) -> Result_void;
		pub fn cv_sfm_reconstruct_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_const__InputOutputArrayX_bool(points2d: *mut c_void, ps: *mut c_void, points3d: *mut c_void, k: *mut c_void, is_projective: bool) -> Result_void;
		pub fn cv_sfm_reconstruct_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_const__InputOutputArrayX_const__OutputArrayX_bool(points2d: *mut c_void, rs: *mut c_void, ts: *mut c_void, k: *mut c_void, points3d: *mut c_void, is_projective: bool) -> Result_void;
		pub fn cv_sfm_reconstruct_vector_String__const__OutputArrayX_const__OutputArrayX_const__InputOutputArrayX_bool(images: *mut c_void, ps: *mut c_void, points3d: *mut c_void, k: *mut c_void, is_projective: bool) -> Result_void;
		pub fn cv_sfm_reconstruct_vector_String__const__OutputArrayX_const__OutputArrayX_const__InputOutputArrayX_const__OutputArrayX_bool(images: *mut c_void, rs: *mut c_void, ts: *mut c_void, k: *mut c_void, points3d: *mut c_void, is_projective: bool) -> Result_void;
		pub fn cv_sfm_relativeCameraMotion_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(r1: *mut c_void, t1: *mut c_void, r2: *mut c_void, t2: *mut c_void, r: *mut c_void, t: *mut c_void) -> Result_void;
		pub fn cv_sfm_skew_const__InputArrayX(x: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_sfm_triangulatePoints_const__InputArrayX_const__InputArrayX_const__OutputArrayX(points2d: *mut c_void, projection_matrices: *mut c_void, points3d: *mut c_void) -> Result_void;
		pub fn cv_sfm_BaseSFM_run_const__InputArrayX(instance: *mut c_void, points2d: *mut c_void) -> Result_void;
		pub fn cv_sfm_BaseSFM_run_const__InputArrayX_const__InputOutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, points2d: *mut c_void, k: *mut c_void, rs: *mut c_void, ts: *mut c_void, points3d: *mut c_void) -> Result_void;
		pub fn cv_sfm_BaseSFM_run_const_vector_String_X(instance: *mut c_void, images: *mut c_void) -> Result_void;
		pub fn cv_sfm_BaseSFM_run_const_vector_String_X_const__InputOutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, images: *mut c_void, k: *mut c_void, rs: *mut c_void, ts: *mut c_void, points3d: *mut c_void) -> Result_void;
		pub fn cv_sfm_BaseSFM_getError_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_sfm_BaseSFM_getPoints_const__OutputArrayX(instance: *mut c_void, points3d: *mut c_void) -> Result_void;
		pub fn cv_sfm_BaseSFM_getIntrinsics_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_sfm_BaseSFM_getCameras_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, rs: *mut c_void, ts: *mut c_void) -> Result_void;
		pub fn cv_sfm_BaseSFM_setReconstructionOptions_const_libmv_ReconstructionOptionsX(instance: *mut c_void, libmv_reconstruction_options: *const crate::sfm::libmv_ReconstructionOptions) -> Result_void;
		pub fn cv_sfm_BaseSFM_setCameraIntrinsicOptions_const_libmv_CameraIntrinsicsOptionsX(instance: *mut c_void, libmv_camera_intrinsics_options: *const crate::sfm::libmv_CameraIntrinsicsOptions) -> Result_void;
		pub fn cv_sfm_SFMLibmvEuclideanReconstruction_run_const__InputArrayX(instance: *mut c_void, points2d: *mut c_void) -> Result_void;
		pub fn cv_sfm_SFMLibmvEuclideanReconstruction_run_const__InputArrayX_const__InputOutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, points2d: *mut c_void, k: *mut c_void, rs: *mut c_void, ts: *mut c_void, points3d: *mut c_void) -> Result_void;
		pub fn cv_sfm_SFMLibmvEuclideanReconstruction_run_const_vector_String_X(instance: *mut c_void, images: *mut c_void) -> Result_void;
		pub fn cv_sfm_SFMLibmvEuclideanReconstruction_run_const_vector_String_X_const__InputOutputArrayX_const__OutputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, images: *mut c_void, k: *mut c_void, rs: *mut c_void, ts: *mut c_void, points3d: *mut c_void) -> Result_void;
		pub fn cv_sfm_SFMLibmvEuclideanReconstruction_getError_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_sfm_SFMLibmvEuclideanReconstruction_getPoints_const__OutputArrayX(instance: *mut c_void, points3d: *mut c_void) -> Result_void;
		pub fn cv_sfm_SFMLibmvEuclideanReconstruction_getIntrinsics_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_sfm_SFMLibmvEuclideanReconstruction_getCameras_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, rs: *mut c_void, ts: *mut c_void) -> Result_void;
		pub fn cv_sfm_SFMLibmvEuclideanReconstruction_setReconstructionOptions_const_libmv_ReconstructionOptionsX(instance: *mut c_void, libmv_reconstruction_options: *const crate::sfm::libmv_ReconstructionOptions) -> Result_void;
		pub fn cv_sfm_SFMLibmvEuclideanReconstruction_setCameraIntrinsicOptions_const_libmv_CameraIntrinsicsOptionsX(instance: *mut c_void, libmv_camera_intrinsics_options: *const crate::sfm::libmv_CameraIntrinsicsOptions) -> Result_void;
		pub fn cv_sfm_SFMLibmvEuclideanReconstruction_create_const_libmv_CameraIntrinsicsOptionsX_const_libmv_ReconstructionOptionsX(camera_instrinsic_options: *const crate::sfm::libmv_CameraIntrinsicsOptions, reconstruction_options: *const crate::sfm::libmv_ReconstructionOptions) -> Result<*mut c_void>;
		pub fn cv_sfm_libmv_CameraIntrinsicsOptions_libmv_CameraIntrinsicsOptions_int_double_double_double_double_double_double_double_double_double(_distortion_model: i32, _focal_length_x: f64, _focal_length_y: f64, _principal_point_x: f64, _principal_point_y: f64, _polynomial_k1: f64, _polynomial_k2: f64, _polynomial_k3: f64, _polynomial_p1: f64, _polynomial_p2: f64) -> Result<crate::sfm::libmv_CameraIntrinsicsOptions>;
		pub fn cv_sfm_libmv_ReconstructionOptions_libmv_ReconstructionOptions_int_int_int_int_int(_keyframe1: i32, _keyframe2: i32, _refine_intrinsics: i32, _select_keyframes: i32, _verbosity_level: i32) -> Result<crate::sfm::libmv_ReconstructionOptions>;
	}
}
#[cfg(feature = "contrib")]
pub use sfm_sys::*;

#[cfg(feature = "contrib")]
mod shape_sys {
	use super::*;

	extern "C" {
		pub fn cv_EMDL1_const__InputArrayX_const__InputArrayX(signature1: *mut c_void, signature2: *mut c_void) -> Result<f32>;
		pub fn cv_createAffineTransformer_bool(full_affine: bool) -> Result<*mut c_void>;
		pub fn cv_createChiHistogramCostExtractor_int_float(n_dummies: i32, default_cost: f32) -> Result<*mut c_void>;
		pub fn cv_createEMDHistogramCostExtractor_int_int_float(flag: i32, n_dummies: i32, default_cost: f32) -> Result<*mut c_void>;
		pub fn cv_createEMDL1HistogramCostExtractor_int_float(n_dummies: i32, default_cost: f32) -> Result<*mut c_void>;
		pub fn cv_createHausdorffDistanceExtractor_int_float(distance_flag: i32, rank_prop: f32) -> Result<*mut c_void>;
		pub fn cv_createNormHistogramCostExtractor_int_int_float(flag: i32, n_dummies: i32, default_cost: f32) -> Result<*mut c_void>;
		pub fn cv_createShapeContextDistanceExtractor_int_int_float_float_int_const_Ptr_HistogramCostExtractor_X_const_Ptr_ShapeTransformer_X(n_angular_bins: i32, n_radial_bins: i32, inner_radius: f32, outer_radius: f32, iterations: i32, comparer: *mut c_void, transformer: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_createThinPlateSplineShapeTransformer_double(regularization_parameter: f64) -> Result<*mut c_void>;
		pub fn cv_AffineTransformer_setFullAffine_bool(instance: *mut c_void, full_affine: bool) -> Result_void;
		pub fn cv_AffineTransformer_getFullAffine_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_EMDHistogramCostExtractor_setNormFlag_int(instance: *mut c_void, flag: i32) -> Result_void;
		pub fn cv_EMDHistogramCostExtractor_getNormFlag_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_HausdorffDistanceExtractor_setDistanceFlag_int(instance: *mut c_void, distance_flag: i32) -> Result_void;
		pub fn cv_HausdorffDistanceExtractor_getDistanceFlag_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_HausdorffDistanceExtractor_setRankProportion_float(instance: *mut c_void, rank_proportion: f32) -> Result_void;
		pub fn cv_HausdorffDistanceExtractor_getRankProportion_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_HistogramCostExtractor_buildCostMatrix_const__InputArrayX_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, descriptors1: *mut c_void, descriptors2: *mut c_void, cost_matrix: *mut c_void) -> Result_void;
		pub fn cv_HistogramCostExtractor_setNDummies_int(instance: *mut c_void, n_dummies: i32) -> Result_void;
		pub fn cv_HistogramCostExtractor_getNDummies_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_HistogramCostExtractor_setDefaultCost_float(instance: *mut c_void, default_cost: f32) -> Result_void;
		pub fn cv_HistogramCostExtractor_getDefaultCost_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_NormHistogramCostExtractor_setNormFlag_int(instance: *mut c_void, flag: i32) -> Result_void;
		pub fn cv_NormHistogramCostExtractor_getNormFlag_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ShapeContextDistanceExtractor_setAngularBins_int(instance: *mut c_void, n_angular_bins: i32) -> Result_void;
		pub fn cv_ShapeContextDistanceExtractor_getAngularBins_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ShapeContextDistanceExtractor_setRadialBins_int(instance: *mut c_void, n_radial_bins: i32) -> Result_void;
		pub fn cv_ShapeContextDistanceExtractor_getRadialBins_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ShapeContextDistanceExtractor_setInnerRadius_float(instance: *mut c_void, inner_radius: f32) -> Result_void;
		pub fn cv_ShapeContextDistanceExtractor_getInnerRadius_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_ShapeContextDistanceExtractor_setOuterRadius_float(instance: *mut c_void, outer_radius: f32) -> Result_void;
		pub fn cv_ShapeContextDistanceExtractor_getOuterRadius_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_ShapeContextDistanceExtractor_setRotationInvariant_bool(instance: *mut c_void, rotation_invariant: bool) -> Result_void;
		pub fn cv_ShapeContextDistanceExtractor_getRotationInvariant_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_ShapeContextDistanceExtractor_setShapeContextWeight_float(instance: *mut c_void, shape_context_weight: f32) -> Result_void;
		pub fn cv_ShapeContextDistanceExtractor_getShapeContextWeight_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_ShapeContextDistanceExtractor_setImageAppearanceWeight_float(instance: *mut c_void, image_appearance_weight: f32) -> Result_void;
		pub fn cv_ShapeContextDistanceExtractor_getImageAppearanceWeight_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_ShapeContextDistanceExtractor_setBendingEnergyWeight_float(instance: *mut c_void, bending_energy_weight: f32) -> Result_void;
		pub fn cv_ShapeContextDistanceExtractor_getBendingEnergyWeight_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_ShapeContextDistanceExtractor_setImages_const__InputArrayX_const__InputArrayX(instance: *mut c_void, image1: *mut c_void, image2: *mut c_void) -> Result_void;
		pub fn cv_ShapeContextDistanceExtractor_getImages_const_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, image1: *mut c_void, image2: *mut c_void) -> Result_void;
		pub fn cv_ShapeContextDistanceExtractor_setIterations_int(instance: *mut c_void, iterations: i32) -> Result_void;
		pub fn cv_ShapeContextDistanceExtractor_getIterations_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ShapeContextDistanceExtractor_setCostExtractor_Ptr_HistogramCostExtractor_(instance: *mut c_void, comparer: *mut c_void) -> Result_void;
		pub fn cv_ShapeContextDistanceExtractor_getCostExtractor_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ShapeContextDistanceExtractor_setStdDev_float(instance: *mut c_void, sigma: f32) -> Result_void;
		pub fn cv_ShapeContextDistanceExtractor_getStdDev_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_ShapeContextDistanceExtractor_setTransformAlgorithm_Ptr_ShapeTransformer_(instance: *mut c_void, transformer: *mut c_void) -> Result_void;
		pub fn cv_ShapeContextDistanceExtractor_getTransformAlgorithm_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ShapeDistanceExtractor_computeDistance_const__InputArrayX_const__InputArrayX(instance: *mut c_void, contour1: *mut c_void, contour2: *mut c_void) -> Result<f32>;
		pub fn cv_ShapeTransformer_estimateTransformation_const__InputArrayX_const__InputArrayX_vector_DMatch_X(instance: *mut c_void, transforming_shape: *mut c_void, target_shape: *mut c_void, matches: *mut c_void) -> Result_void;
		pub fn cv_ShapeTransformer_applyTransformation_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, input: *mut c_void, output: *mut c_void) -> Result<f32>;
		pub fn cv_ShapeTransformer_warpImage_const_const__InputArrayX_const__OutputArrayX_int_int_const_ScalarX(instance: *mut c_void, transforming_image: *mut c_void, output: *mut c_void, flags: i32, border_mode: i32, border_value: *const core::Scalar) -> Result_void;
		pub fn cv_ThinPlateSplineShapeTransformer_setRegularizationParameter_double(instance: *mut c_void, beta: f64) -> Result_void;
		pub fn cv_ThinPlateSplineShapeTransformer_getRegularizationParameter_const(instance: *mut c_void) -> Result<f64>;
	}
}
#[cfg(feature = "contrib")]
pub use shape_sys::*;

mod stitching_sys {
	use super::*;

	extern "C" {
		pub fn cv_createStitcherScans_bool(try_use_gpu: bool) -> Result<*mut c_void>;
		pub fn cv_createStitcher_bool(try_use_gpu: bool) -> Result<*mut c_void>;
		pub fn cv_detail_computeImageFeatures_const_Ptr_Feature2D_X_const__InputArrayX_ImageFeaturesX_const__InputArrayX(features_finder: *mut c_void, image: *mut c_void, features: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_detail_computeImageFeatures_const_Ptr_Feature2D_X_const__InputArrayX_vector_ImageFeatures_X_const__InputArrayX(features_finder: *mut c_void, images: *mut c_void, features: *mut c_void, masks: *mut c_void) -> Result_void;
		pub fn cv_detail_createLaplacePyrGpu_const__InputArrayX_int_vector_UMat_X(img: *mut c_void, num_levels: i32, pyr: *mut c_void) -> Result_void;
		pub fn cv_detail_createLaplacePyr_const__InputArrayX_int_vector_UMat_X(img: *mut c_void, num_levels: i32, pyr: *mut c_void) -> Result_void;
		pub fn cv_detail_createWeightMap_const__InputArrayX_float_const__InputOutputArrayX(mask: *mut c_void, sharpness: f32, weight: *mut c_void) -> Result_void;
		pub fn cv_detail_findMaxSpanningTree_int_const_vector_MatchesInfo_X_GraphX_vector_int_X(num_images: i32, pairwise_matches: *mut c_void, span_tree: *mut c_void, centers: *mut c_void) -> Result_void;
		pub fn cv_detail_leaveBiggestComponent_vector_ImageFeatures_X_vector_MatchesInfo_X_float(features: *mut c_void, pairwise_matches: *mut c_void, conf_threshold: f32) -> Result<*mut c_void>;
		pub fn cv_detail_matchesGraphAsString_vector_String_X_vector_MatchesInfo_X_float(pathes: *mut c_void, pairwise_matches: *mut c_void, conf_threshold: f32) -> Result<*mut c_void>;
		pub fn cv_detail_normalizeUsingWeightMap_const__InputArrayX_const__InputOutputArrayX(weight: *mut c_void, src: *mut c_void) -> Result_void;
		pub fn cv_detail_overlapRoi_Point_Point_Size_Size_RectX(tl1: *const core::Point, tl2: *const core::Point, sz1: *const core::Size, sz2: *const core::Size, roi: *mut core::Rect) -> Result<bool>;
		pub fn cv_detail_restoreImageFromLaplacePyrGpu_vector_UMat_X(pyr: *mut c_void) -> Result_void;
		pub fn cv_detail_restoreImageFromLaplacePyr_vector_UMat_X(pyr: *mut c_void) -> Result_void;
		pub fn cv_detail_resultRoiIntersection_const_vector_Point_X_const_vector_Size_X(corners: *mut c_void, sizes: *mut c_void) -> Result<core::Rect>;
		pub fn cv_detail_resultRoi_const_vector_Point_X_const_vector_Size_X(corners: *mut c_void, sizes: *mut c_void) -> Result<core::Rect>;
		pub fn cv_detail_resultRoi_const_vector_Point_X_const_vector_UMat_X(corners: *mut c_void, images: *mut c_void) -> Result<core::Rect>;
		pub fn cv_detail_resultTl_const_vector_Point_X(corners: *mut c_void) -> Result<core::Point>;
		pub fn cv_detail_selectRandomSubset_int_int_vector_int_X(count: i32, size: i32, subset: *mut c_void) -> Result_void;
		pub fn cv_detail_stitchingLogLevel() -> Result<i32>;
		pub fn cv_detail_waveCorrect_vector_Mat_X_WaveCorrectKind(rmats: *mut c_void, kind: crate::stitching::Detail_WaveCorrectKind) -> Result_void;
		pub fn cv_AffineWarper_create_const_float(instance: *mut c_void, scale: f32) -> Result<*mut c_void>;
		pub fn cv_CompressedRectilinearPortraitWarper_CompressedRectilinearPortraitWarper_float_float(a: f32, b: f32) -> Result<*mut c_void>;
		pub fn cv_CompressedRectilinearPortraitWarper_create_const_float(instance: *mut c_void, scale: f32) -> Result<*mut c_void>;
		pub fn cv_CompressedRectilinearWarper_CompressedRectilinearWarper_float_float(a: f32, b: f32) -> Result<*mut c_void>;
		pub fn cv_CompressedRectilinearWarper_create_const_float(instance: *mut c_void, scale: f32) -> Result<*mut c_void>;
		pub fn cv_CylindricalWarper_create_const_float(instance: *mut c_void, scale: f32) -> Result<*mut c_void>;
		pub fn cv_FisheyeWarper_create_const_float(instance: *mut c_void, scale: f32) -> Result<*mut c_void>;
		pub fn cv_MercatorWarper_create_const_float(instance: *mut c_void, scale: f32) -> Result<*mut c_void>;
		pub fn cv_PaniniPortraitWarper_PaniniPortraitWarper_float_float(a: f32, b: f32) -> Result<*mut c_void>;
		pub fn cv_PaniniPortraitWarper_create_const_float(instance: *mut c_void, scale: f32) -> Result<*mut c_void>;
		pub fn cv_PaniniWarper_PaniniWarper_float_float(a: f32, b: f32) -> Result<*mut c_void>;
		pub fn cv_PaniniWarper_create_const_float(instance: *mut c_void, scale: f32) -> Result<*mut c_void>;
		pub fn cv_PlaneWarper_create_const_float(instance: *mut c_void, scale: f32) -> Result<*mut c_void>;
		pub fn cv_PyRotationWarper_PyRotationWarper_String_float(typ: *mut c_char, scale: f32) -> Result<*mut c_void>;
		pub fn cv_PyRotationWarper_PyRotationWarper() -> Result<*mut c_void>;
		pub fn cv_PyRotationWarper_warpPoint_const_Point2fX_const__InputArrayX_const__InputArrayX(instance: *mut c_void, pt: *const core::Point2f, k: *mut c_void, r: *mut c_void) -> Result<core::Point2f>;
		pub fn cv_PyRotationWarper_buildMaps_Size_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, src_size: *const core::Size, k: *mut c_void, r: *mut c_void, xmap: *mut c_void, ymap: *mut c_void) -> Result<core::Rect>;
		pub fn cv_PyRotationWarper_warp_const__InputArrayX_const__InputArrayX_const__InputArrayX_int_int_const__OutputArrayX(instance: *mut c_void, src: *mut c_void, k: *mut c_void, r: *mut c_void, interp_mode: i32, border_mode: i32, dst: *mut c_void) -> Result<core::Point>;
		pub fn cv_PyRotationWarper_warpBackward_const__InputArrayX_const__InputArrayX_const__InputArrayX_int_int_Size_const__OutputArrayX(instance: *mut c_void, src: *mut c_void, k: *mut c_void, r: *mut c_void, interp_mode: i32, border_mode: i32, dst_size: *const core::Size, dst: *mut c_void) -> Result_void;
		pub fn cv_PyRotationWarper_warpRoi_Size_const__InputArrayX_const__InputArrayX(instance: *mut c_void, src_size: *const core::Size, k: *mut c_void, r: *mut c_void) -> Result<core::Rect>;
		pub fn cv_PyRotationWarper_getScale_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_PyRotationWarper_setScale_float(instance: *mut c_void, unnamed: f32) -> Result_void;
		pub fn cv_SphericalWarper_create_const_float(instance: *mut c_void, scale: f32) -> Result<*mut c_void>;
		pub fn cv_StereographicWarper_create_const_float(instance: *mut c_void, scale: f32) -> Result<*mut c_void>;
		pub fn cv_Stitcher_ORIG_RESOL_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_Stitcher_create_Mode(mode: crate::stitching::Stitcher_Mode) -> Result<*mut c_void>;
		pub fn cv_Stitcher_registrationResol_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_Stitcher_setRegistrationResol_double(instance: *mut c_void, resol_mpx: f64) -> Result_void;
		pub fn cv_Stitcher_seamEstimationResol_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_Stitcher_setSeamEstimationResol_double(instance: *mut c_void, resol_mpx: f64) -> Result_void;
		pub fn cv_Stitcher_compositingResol_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_Stitcher_setCompositingResol_double(instance: *mut c_void, resol_mpx: f64) -> Result_void;
		pub fn cv_Stitcher_panoConfidenceThresh_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_Stitcher_setPanoConfidenceThresh_double(instance: *mut c_void, conf_thresh: f64) -> Result_void;
		pub fn cv_Stitcher_waveCorrection_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_Stitcher_setWaveCorrection_bool(instance: *mut c_void, flag: bool) -> Result_void;
		pub fn cv_Stitcher_interpolationFlags_const(instance: *mut c_void) -> Result<crate::imgproc::InterpolationFlags>;
		pub fn cv_Stitcher_setInterpolationFlags_InterpolationFlags(instance: *mut c_void, interp_flags: crate::imgproc::InterpolationFlags) -> Result_void;
		pub fn cv_Stitcher_waveCorrectKind_const(instance: *mut c_void) -> Result<crate::stitching::Detail_WaveCorrectKind>;
		pub fn cv_Stitcher_setWaveCorrectKind_WaveCorrectKind(instance: *mut c_void, kind: crate::stitching::Detail_WaveCorrectKind) -> Result_void;
		pub fn cv_Stitcher_featuresFinder(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Stitcher_featuresFinder_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Stitcher_setFeaturesFinder_Ptr_Feature2D_(instance: *mut c_void, features_finder: *mut c_void) -> Result_void;
		pub fn cv_Stitcher_featuresMatcher(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Stitcher_featuresMatcher_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Stitcher_setFeaturesMatcher_Ptr_FeaturesMatcher_(instance: *mut c_void, features_matcher: *mut c_void) -> Result_void;
		pub fn cv_Stitcher_matchingMask_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Stitcher_setMatchingMask_const_UMatX(instance: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_Stitcher_bundleAdjuster(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Stitcher_bundleAdjuster_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Stitcher_setBundleAdjuster_Ptr_BundleAdjusterBase_(instance: *mut c_void, bundle_adjuster: *mut c_void) -> Result_void;
		pub fn cv_Stitcher_estimator(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Stitcher_estimator_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Stitcher_setEstimator_Ptr_Estimator_(instance: *mut c_void, estimator: *mut c_void) -> Result_void;
		pub fn cv_Stitcher_warper(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Stitcher_warper_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Stitcher_setWarper_Ptr_WarperCreator_(instance: *mut c_void, creator: *mut c_void) -> Result_void;
		pub fn cv_Stitcher_exposureCompensator(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Stitcher_exposureCompensator_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Stitcher_setExposureCompensator_Ptr_ExposureCompensator_(instance: *mut c_void, exposure_comp: *mut c_void) -> Result_void;
		pub fn cv_Stitcher_seamFinder(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Stitcher_seamFinder_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Stitcher_setSeamFinder_Ptr_SeamFinder_(instance: *mut c_void, seam_finder: *mut c_void) -> Result_void;
		pub fn cv_Stitcher_blender(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Stitcher_blender_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Stitcher_setBlender_Ptr_Blender_(instance: *mut c_void, b: *mut c_void) -> Result_void;
		pub fn cv_Stitcher_estimateTransform_const__InputArrayX_const__InputArrayX(instance: *mut c_void, images: *mut c_void, masks: *mut c_void) -> Result<crate::stitching::Stitcher_Status>;
		pub fn cv_Stitcher_composePanorama_const__OutputArrayX(instance: *mut c_void, pano: *mut c_void) -> Result<crate::stitching::Stitcher_Status>;
		pub fn cv_Stitcher_composePanorama_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, images: *mut c_void, pano: *mut c_void) -> Result<crate::stitching::Stitcher_Status>;
		pub fn cv_Stitcher_stitch_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, images: *mut c_void, pano: *mut c_void) -> Result<crate::stitching::Stitcher_Status>;
		pub fn cv_Stitcher_stitch_const__InputArrayX_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, images: *mut c_void, masks: *mut c_void, pano: *mut c_void) -> Result<crate::stitching::Stitcher_Status>;
		pub fn cv_Stitcher_component_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Stitcher_cameras_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_Stitcher_workScale_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_Stitcher_resultMask_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_TransverseMercatorWarper_create_const_float(instance: *mut c_void, scale: f32) -> Result<*mut c_void>;
		pub fn cv_WarperCreator_create_const_float(instance: *mut c_void, scale: f32) -> Result<*mut c_void>;
		pub fn cv_detail_AffineBasedEstimator_AffineBasedEstimator() -> Result<*mut c_void>;
		pub fn cv_detail_AffineBestOf2NearestMatcher_AffineBestOf2NearestMatcher_bool_bool_float_int(full_affine: bool, try_use_gpu: bool, match_conf: f32, num_matches_thresh1: i32) -> Result<*mut c_void>;
		pub fn cv_detail_AffineWarper_AffineWarper_float(scale: f32) -> Result<*mut c_void>;
		pub fn cv_detail_AffineWarper_warpPoint_const_Point2fX_const__InputArrayX_const__InputArrayX(instance: *mut c_void, pt: *const core::Point2f, k: *mut c_void, h: *mut c_void) -> Result<core::Point2f>;
		pub fn cv_detail_AffineWarper_buildMaps_Size_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, src_size: *const core::Size, k: *mut c_void, h: *mut c_void, xmap: *mut c_void, ymap: *mut c_void) -> Result<core::Rect>;
		pub fn cv_detail_AffineWarper_warp_const__InputArrayX_const__InputArrayX_const__InputArrayX_int_int_const__OutputArrayX(instance: *mut c_void, src: *mut c_void, k: *mut c_void, h: *mut c_void, interp_mode: i32, border_mode: i32, dst: *mut c_void) -> Result<core::Point>;
		pub fn cv_detail_AffineWarper_warpRoi_Size_const__InputArrayX_const__InputArrayX(instance: *mut c_void, src_size: *const core::Size, k: *mut c_void, h: *mut c_void) -> Result<core::Rect>;
		pub fn cv_detail_BestOf2NearestMatcher_BestOf2NearestMatcher_bool_float_int_int(try_use_gpu: bool, match_conf: f32, num_matches_thresh1: i32, num_matches_thresh2: i32) -> Result<*mut c_void>;
		pub fn cv_detail_BestOf2NearestMatcher_collectGarbage(instance: *mut c_void) -> Result_void;
		pub fn cv_detail_BestOf2NearestMatcher_create_bool_float_int_int(try_use_gpu: bool, match_conf: f32, num_matches_thresh1: i32, num_matches_thresh2: i32) -> Result<*mut c_void>;
		pub fn cv_detail_BestOf2NearestRangeMatcher_BestOf2NearestRangeMatcher_int_bool_float_int_int(range_width: i32, try_use_gpu: bool, match_conf: f32, num_matches_thresh1: i32, num_matches_thresh2: i32) -> Result<*mut c_void>;
		pub fn cv_detail_Blender_createDefault_int_bool(typ: i32, try_gpu: bool) -> Result<*mut c_void>;
		pub fn cv_detail_Blender_prepare_const_vector_Point_X_const_vector_Size_X(instance: *mut c_void, corners: *mut c_void, sizes: *mut c_void) -> Result_void;
		pub fn cv_detail_Blender_prepare_Rect(instance: *mut c_void, dst_roi: *const core::Rect) -> Result_void;
		pub fn cv_detail_Blender_feed_const__InputArrayX_const__InputArrayX_Point(instance: *mut c_void, img: *mut c_void, mask: *mut c_void, tl: *const core::Point) -> Result_void;
		pub fn cv_detail_Blender_blend_const__InputOutputArrayX_const__InputOutputArrayX(instance: *mut c_void, dst: *mut c_void, dst_mask: *mut c_void) -> Result_void;
		pub fn cv_detail_BlocksChannelsCompensator_BlocksChannelsCompensator_int_int_int(bl_width: i32, bl_height: i32, nr_feeds: i32) -> Result<*mut c_void>;
		pub fn cv_detail_BlocksCompensator_apply_int_Point_const__InputOutputArrayX_const__InputArrayX(instance: *mut c_void, index: i32, corner: *const core::Point, image: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_detail_BlocksCompensator_getMatGains_vector_Mat_X(instance: *mut c_void, umv: *mut c_void) -> Result_void;
		pub fn cv_detail_BlocksCompensator_setMatGains_vector_Mat_X(instance: *mut c_void, umv: *mut c_void) -> Result_void;
		pub fn cv_detail_BlocksCompensator_setNrFeeds_int(instance: *mut c_void, nr_feeds: i32) -> Result_void;
		pub fn cv_detail_BlocksCompensator_getNrFeeds(instance: *mut c_void) -> Result<i32>;
		pub fn cv_detail_BlocksCompensator_setBlockSize_int_int(instance: *mut c_void, width: i32, height: i32) -> Result_void;
		pub fn cv_detail_BlocksCompensator_setBlockSize_Size(instance: *mut c_void, size: *const core::Size) -> Result_void;
		pub fn cv_detail_BlocksCompensator_getBlockSize_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_detail_BlocksCompensator_setNrGainsFilteringIterations_int(instance: *mut c_void, nr_iterations: i32) -> Result_void;
		pub fn cv_detail_BlocksCompensator_getNrGainsFilteringIterations_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_detail_BlocksGainCompensator_BlocksGainCompensator_int_int(bl_width: i32, bl_height: i32) -> Result<*mut c_void>;
		pub fn cv_detail_BlocksGainCompensator_BlocksGainCompensator_int_int_int(bl_width: i32, bl_height: i32, nr_feeds: i32) -> Result<*mut c_void>;
		pub fn cv_detail_BlocksGainCompensator_apply_int_Point_const__InputOutputArrayX_const__InputArrayX(instance: *mut c_void, index: i32, corner: *const core::Point, image: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_detail_BlocksGainCompensator_getMatGains_vector_Mat_X(instance: *mut c_void, umv: *mut c_void) -> Result_void;
		pub fn cv_detail_BlocksGainCompensator_setMatGains_vector_Mat_X(instance: *mut c_void, umv: *mut c_void) -> Result_void;
		pub fn cv_detail_BundleAdjusterAffine_BundleAdjusterAffine() -> Result<*mut c_void>;
		pub fn cv_detail_BundleAdjusterAffinePartial_BundleAdjusterAffinePartial() -> Result<*mut c_void>;
		pub fn cv_detail_BundleAdjusterBase_refinementMask_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_detail_BundleAdjusterBase_setRefinementMask_const_MatX(instance: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_detail_BundleAdjusterBase_confThresh_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_detail_BundleAdjusterBase_setConfThresh_double(instance: *mut c_void, conf_thresh: f64) -> Result_void;
		pub fn cv_detail_BundleAdjusterBase_termCriteria(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_detail_BundleAdjusterBase_setTermCriteria_const_TermCriteriaX(instance: *mut c_void, term_criteria: *mut c_void) -> Result_void;
		pub fn cv_detail_BundleAdjusterRay_BundleAdjusterRay() -> Result<*mut c_void>;
		pub fn cv_detail_BundleAdjusterReproj_BundleAdjusterReproj() -> Result<*mut c_void>;
		pub fn cv_detail_CameraParams_focal_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_detail_CameraParams_setFocal_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_detail_CameraParams_aspect_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_detail_CameraParams_setAspect_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_detail_CameraParams_ppx_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_detail_CameraParams_setPpx_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_detail_CameraParams_ppy_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_detail_CameraParams_setPpy_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_detail_CameraParams_R(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_detail_CameraParams_setR_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_detail_CameraParams_t(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_detail_CameraParams_setT_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_detail_CameraParams_CameraParams() -> Result<*mut c_void>;
		pub fn cv_detail_CameraParams_CameraParams_const_CameraParamsX(other: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_detail_CameraParams_K_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_detail_ChannelsCompensator_ChannelsCompensator_int(nr_feeds: i32) -> Result<*mut c_void>;
		pub fn cv_detail_ChannelsCompensator_apply_int_Point_const__InputOutputArrayX_const__InputArrayX(instance: *mut c_void, index: i32, corner: *const core::Point, image: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_detail_ChannelsCompensator_getMatGains_vector_Mat_X(instance: *mut c_void, umv: *mut c_void) -> Result_void;
		pub fn cv_detail_ChannelsCompensator_setMatGains_vector_Mat_X(instance: *mut c_void, umv: *mut c_void) -> Result_void;
		pub fn cv_detail_ChannelsCompensator_setNrFeeds_int(instance: *mut c_void, nr_feeds: i32) -> Result_void;
		pub fn cv_detail_ChannelsCompensator_getNrFeeds(instance: *mut c_void) -> Result<i32>;
		pub fn cv_detail_ChannelsCompensator_gains_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_detail_CompressedRectilinearPortraitProjector_a_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_detail_CompressedRectilinearPortraitProjector_setA_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_detail_CompressedRectilinearPortraitProjector_b_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_detail_CompressedRectilinearPortraitProjector_setB_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_detail_CompressedRectilinearPortraitProjector_mapForward_float_float_floatX_floatX(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32) -> Result_void;
		pub fn cv_detail_CompressedRectilinearPortraitProjector_mapBackward_float_float_floatX_floatX(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32) -> Result_void;
		pub fn cv_detail_CompressedRectilinearPortraitWarper_CompressedRectilinearPortraitWarper_float_float_float(scale: f32, a: f32, b: f32) -> Result<*mut c_void>;
		pub fn cv_detail_CompressedRectilinearProjector_a_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_detail_CompressedRectilinearProjector_setA_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_detail_CompressedRectilinearProjector_b_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_detail_CompressedRectilinearProjector_setB_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_detail_CompressedRectilinearProjector_mapForward_float_float_floatX_floatX(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32) -> Result_void;
		pub fn cv_detail_CompressedRectilinearProjector_mapBackward_float_float_floatX_floatX(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32) -> Result_void;
		pub fn cv_detail_CompressedRectilinearWarper_CompressedRectilinearWarper_float_float_float(scale: f32, a: f32, b: f32) -> Result<*mut c_void>;
		pub fn cv_detail_CylindricalPortraitProjector_mapForward_float_float_floatX_floatX(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32) -> Result_void;
		pub fn cv_detail_CylindricalPortraitProjector_mapBackward_float_float_floatX_floatX(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32) -> Result_void;
		pub fn cv_detail_CylindricalPortraitWarper_CylindricalPortraitWarper_float(scale: f32) -> Result<*mut c_void>;
		pub fn cv_detail_CylindricalProjector_mapForward_float_float_floatX_floatX(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32) -> Result_void;
		pub fn cv_detail_CylindricalProjector_mapBackward_float_float_floatX_floatX(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32) -> Result_void;
		pub fn cv_detail_CylindricalWarper_CylindricalWarper_float(scale: f32) -> Result<*mut c_void>;
		pub fn cv_detail_CylindricalWarper_buildMaps_Size_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, src_size: *const core::Size, k: *mut c_void, r: *mut c_void, xmap: *mut c_void, ymap: *mut c_void) -> Result<core::Rect>;
		pub fn cv_detail_CylindricalWarper_warp_const__InputArrayX_const__InputArrayX_const__InputArrayX_int_int_const__OutputArrayX(instance: *mut c_void, src: *mut c_void, k: *mut c_void, r: *mut c_void, interp_mode: i32, border_mode: i32, dst: *mut c_void) -> Result<core::Point>;
		pub fn cv_detail_CylindricalWarperGpu_CylindricalWarperGpu_float(scale: f32) -> Result<*mut c_void>;
		pub fn cv_detail_CylindricalWarperGpu_buildMaps_Size_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, src_size: *const core::Size, k: *mut c_void, r: *mut c_void, xmap: *mut c_void, ymap: *mut c_void) -> Result<core::Rect>;
		pub fn cv_detail_CylindricalWarperGpu_warp_const__InputArrayX_const__InputArrayX_const__InputArrayX_int_int_const__OutputArrayX(instance: *mut c_void, src: *mut c_void, k: *mut c_void, r: *mut c_void, interp_mode: i32, border_mode: i32, dst: *mut c_void) -> Result<core::Point>;
		pub fn cv_detail_DisjointSets_parent(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_detail_DisjointSets_setParent_vector_int_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_detail_DisjointSets_size(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_detail_DisjointSets_setSize_vector_int_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_detail_DisjointSets_DisjointSets_int(elem_count: i32) -> Result<*mut c_void>;
		pub fn cv_detail_DisjointSets_createOneElemSets_int(instance: *mut c_void, elem_count: i32) -> Result_void;
		pub fn cv_detail_DisjointSets_findSetByElem_int(instance: *mut c_void, elem: i32) -> Result<i32>;
		pub fn cv_detail_DisjointSets_mergeSets_int_int(instance: *mut c_void, set1: i32, set2: i32) -> Result<i32>;
		pub fn cv_detail_DpSeamFinder_DpSeamFinder_CostFunction(cost_func: crate::stitching::Detail_DpSeamFinder_CostFunction) -> Result<*mut c_void>;
		pub fn cv_detail_DpSeamFinder_DpSeamFinder_String(cost_func: *mut c_char) -> Result<*mut c_void>;
		pub fn cv_detail_DpSeamFinder_costFunction_const(instance: *mut c_void) -> Result<crate::stitching::Detail_DpSeamFinder_CostFunction>;
		pub fn cv_detail_DpSeamFinder_setCostFunction_CostFunction(instance: *mut c_void, val: crate::stitching::Detail_DpSeamFinder_CostFunction) -> Result_void;
		pub fn cv_detail_DpSeamFinder_setCostFunction_String(instance: *mut c_void, val: *mut c_char) -> Result_void;
		pub fn cv_detail_DpSeamFinder_find_const_vector_UMat_X_const_vector_Point_X_vector_UMat_X(instance: *mut c_void, src: *mut c_void, corners: *mut c_void, masks: *mut c_void) -> Result_void;
		pub fn cv_detail_ExposureCompensator_createDefault_int(typ: i32) -> Result<*mut c_void>;
		pub fn cv_detail_ExposureCompensator_feed_const_vector_Point_X_const_vector_UMat_X_const_vector_UMat_X(instance: *mut c_void, corners: *mut c_void, images: *mut c_void, masks: *mut c_void) -> Result_void;
		pub fn cv_detail_ExposureCompensator_apply_int_Point_const__InputOutputArrayX_const__InputArrayX(instance: *mut c_void, index: i32, corner: *const core::Point, image: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_detail_ExposureCompensator_getMatGains_vector_Mat_X(instance: *mut c_void, unnamed: *mut c_void) -> Result_void;
		pub fn cv_detail_ExposureCompensator_setMatGains_vector_Mat_X(instance: *mut c_void, unnamed: *mut c_void) -> Result_void;
		pub fn cv_detail_ExposureCompensator_setUpdateGain_bool(instance: *mut c_void, b: bool) -> Result_void;
		pub fn cv_detail_ExposureCompensator_getUpdateGain(instance: *mut c_void) -> Result<bool>;
		pub fn cv_detail_FeatherBlender_FeatherBlender_float(sharpness: f32) -> Result<*mut c_void>;
		pub fn cv_detail_FeatherBlender_sharpness_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_detail_FeatherBlender_setSharpness_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_detail_FeatherBlender_prepare_Rect(instance: *mut c_void, dst_roi: *const core::Rect) -> Result_void;
		pub fn cv_detail_FeatherBlender_feed_const__InputArrayX_const__InputArrayX_Point(instance: *mut c_void, img: *mut c_void, mask: *mut c_void, tl: *const core::Point) -> Result_void;
		pub fn cv_detail_FeatherBlender_blend_const__InputOutputArrayX_const__InputOutputArrayX(instance: *mut c_void, dst: *mut c_void, dst_mask: *mut c_void) -> Result_void;
		pub fn cv_detail_FeatherBlender_createWeightMaps_const_vector_UMat_X_const_vector_Point_X_vector_UMat_X(instance: *mut c_void, masks: *mut c_void, corners: *mut c_void, weight_maps: *mut c_void) -> Result<core::Rect>;
		pub fn cv_detail_FeaturesMatcher_isThreadSafe_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_detail_FeaturesMatcher_collectGarbage(instance: *mut c_void) -> Result_void;
		pub fn cv_detail_FisheyeProjector_mapForward_float_float_floatX_floatX(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32) -> Result_void;
		pub fn cv_detail_FisheyeProjector_mapBackward_float_float_floatX_floatX(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32) -> Result_void;
		pub fn cv_detail_FisheyeWarper_FisheyeWarper_float(scale: f32) -> Result<*mut c_void>;
		pub fn cv_detail_GainCompensator_GainCompensator() -> Result<*mut c_void>;
		pub fn cv_detail_GainCompensator_GainCompensator_int(nr_feeds: i32) -> Result<*mut c_void>;
		pub fn cv_detail_GainCompensator_apply_int_Point_const__InputOutputArrayX_const__InputArrayX(instance: *mut c_void, index: i32, corner: *const core::Point, image: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_detail_GainCompensator_getMatGains_vector_Mat_X(instance: *mut c_void, umv: *mut c_void) -> Result_void;
		pub fn cv_detail_GainCompensator_setMatGains_vector_Mat_X(instance: *mut c_void, umv: *mut c_void) -> Result_void;
		pub fn cv_detail_GainCompensator_setNrFeeds_int(instance: *mut c_void, nr_feeds: i32) -> Result_void;
		pub fn cv_detail_GainCompensator_getNrFeeds(instance: *mut c_void) -> Result<i32>;
		pub fn cv_detail_GainCompensator_gains_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_detail_Graph_Graph_int(num_vertices: i32) -> Result<*mut c_void>;
		pub fn cv_detail_Graph_create_int(instance: *mut c_void, num_vertices: i32) -> Result_void;
		pub fn cv_detail_Graph_numVertices_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_detail_Graph_addEdge_int_int_float(instance: *mut c_void, from: i32, to: i32, weight: f32) -> Result_void;
		pub fn cv_detail_GraphCutSeamFinder_GraphCutSeamFinder_int_float_float(cost_type: i32, terminal_cost: f32, bad_region_penalty: f32) -> Result<*mut c_void>;
		pub fn cv_detail_GraphCutSeamFinder_GraphCutSeamFinder_String_float_float(cost_type: *mut c_char, terminal_cost: f32, bad_region_penalty: f32) -> Result<*mut c_void>;
		pub fn cv_detail_GraphCutSeamFinder_find_const_vector_UMat_X_const_vector_Point_X_vector_UMat_X(instance: *mut c_void, src: *mut c_void, corners: *mut c_void, masks: *mut c_void) -> Result_void;
		pub fn cv_detail_GraphEdge_from_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_detail_GraphEdge_setFrom_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_detail_GraphEdge_to_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_detail_GraphEdge_setTo_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_detail_GraphEdge_weight_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_detail_GraphEdge_setWeight_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_detail_GraphEdge_GraphEdge_int_int_float(from: i32, to: i32, weight: f32) -> Result<*mut c_void>;
		pub fn cv_detail_HomographyBasedEstimator_HomographyBasedEstimator_bool(is_focals_estimated: bool) -> Result<*mut c_void>;
		pub fn cv_detail_ImageFeatures_img_idx_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_detail_ImageFeatures_setImg_idx_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_detail_ImageFeatures_img_size_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_detail_ImageFeatures_setImg_size_Size(instance: *mut c_void, val: *const core::Size) -> Result_void;
		pub fn cv_detail_ImageFeatures_keypoints(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_detail_ImageFeatures_setKeypoints_vector_KeyPoint_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_detail_ImageFeatures_descriptors(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_detail_ImageFeatures_setDescriptors_UMat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_detail_ImageFeatures_getKeypoints(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_detail_MatchesInfo_src_img_idx_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_detail_MatchesInfo_setSrc_img_idx_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_detail_MatchesInfo_dst_img_idx_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_detail_MatchesInfo_setDst_img_idx_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_detail_MatchesInfo_matches(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_detail_MatchesInfo_setMatches_vector_DMatch_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_detail_MatchesInfo_inliers_mask(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_detail_MatchesInfo_setInliers_mask_vector_unsigned_char_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_detail_MatchesInfo_num_inliers_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_detail_MatchesInfo_setNum_inliers_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_detail_MatchesInfo_H(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_detail_MatchesInfo_setH_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_detail_MatchesInfo_confidence_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_detail_MatchesInfo_setConfidence_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_detail_MatchesInfo_MatchesInfo() -> Result<*mut c_void>;
		pub fn cv_detail_MatchesInfo_MatchesInfo_const_MatchesInfoX(other: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_detail_MatchesInfo_getMatches(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_detail_MatchesInfo_getInliers(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_detail_MercatorProjector_mapForward_float_float_floatX_floatX(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32) -> Result_void;
		pub fn cv_detail_MercatorProjector_mapBackward_float_float_floatX_floatX(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32) -> Result_void;
		pub fn cv_detail_MercatorWarper_MercatorWarper_float(scale: f32) -> Result<*mut c_void>;
		pub fn cv_detail_MultiBandBlender_MultiBandBlender_int_int_int(try_gpu: i32, num_bands: i32, weight_type: i32) -> Result<*mut c_void>;
		pub fn cv_detail_MultiBandBlender_numBands_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_detail_MultiBandBlender_setNumBands_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_detail_MultiBandBlender_prepare_Rect(instance: *mut c_void, dst_roi: *const core::Rect) -> Result_void;
		pub fn cv_detail_MultiBandBlender_feed_const__InputArrayX_const__InputArrayX_Point(instance: *mut c_void, img: *mut c_void, mask: *mut c_void, tl: *const core::Point) -> Result_void;
		pub fn cv_detail_MultiBandBlender_blend_const__InputOutputArrayX_const__InputOutputArrayX(instance: *mut c_void, dst: *mut c_void, dst_mask: *mut c_void) -> Result_void;
		pub fn cv_detail_NoBundleAdjuster_NoBundleAdjuster() -> Result<*mut c_void>;
		pub fn cv_detail_NoExposureCompensator_apply_int_Point_const__InputOutputArrayX_const__InputArrayX(instance: *mut c_void, unnamed: i32, unnamed: *const core::Point, unnamed: *mut c_void, unnamed: *mut c_void) -> Result_void;
		pub fn cv_detail_NoExposureCompensator_getMatGains_vector_Mat_X(instance: *mut c_void, umv: *mut c_void) -> Result_void;
		pub fn cv_detail_NoExposureCompensator_setMatGains_vector_Mat_X(instance: *mut c_void, umv: *mut c_void) -> Result_void;
		pub fn cv_detail_NoSeamFinder_find_const_vector_UMat_X_const_vector_Point_X_vector_UMat_X(instance: *mut c_void, unnamed: *mut c_void, unnamed: *mut c_void, unnamed: *mut c_void) -> Result_void;
		pub fn cv_detail_PairwiseSeamFinder_find_const_vector_UMat_X_const_vector_Point_X_vector_UMat_X(instance: *mut c_void, src: *mut c_void, corners: *mut c_void, masks: *mut c_void) -> Result_void;
		pub fn cv_detail_PaniniPortraitProjector_a_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_detail_PaniniPortraitProjector_setA_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_detail_PaniniPortraitProjector_b_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_detail_PaniniPortraitProjector_setB_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_detail_PaniniPortraitProjector_mapForward_float_float_floatX_floatX(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32) -> Result_void;
		pub fn cv_detail_PaniniPortraitProjector_mapBackward_float_float_floatX_floatX(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32) -> Result_void;
		pub fn cv_detail_PaniniPortraitWarper_PaniniPortraitWarper_float_float_float(scale: f32, a: f32, b: f32) -> Result<*mut c_void>;
		pub fn cv_detail_PaniniProjector_a_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_detail_PaniniProjector_setA_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_detail_PaniniProjector_b_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_detail_PaniniProjector_setB_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_detail_PaniniProjector_mapForward_float_float_floatX_floatX(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32) -> Result_void;
		pub fn cv_detail_PaniniProjector_mapBackward_float_float_floatX_floatX(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32) -> Result_void;
		pub fn cv_detail_PaniniWarper_PaniniWarper_float_float_float(scale: f32, a: f32, b: f32) -> Result<*mut c_void>;
		pub fn cv_detail_PlanePortraitProjector_mapForward_float_float_floatX_floatX(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32) -> Result_void;
		pub fn cv_detail_PlanePortraitProjector_mapBackward_float_float_floatX_floatX(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32) -> Result_void;
		pub fn cv_detail_PlanePortraitWarper_PlanePortraitWarper_float(scale: f32) -> Result<*mut c_void>;
		pub fn cv_detail_PlaneProjector_mapForward_float_float_floatX_floatX(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32) -> Result_void;
		pub fn cv_detail_PlaneProjector_mapBackward_float_float_floatX_floatX(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32) -> Result_void;
		pub fn cv_detail_PlaneWarper_PlaneWarper_float(scale: f32) -> Result<*mut c_void>;
		pub fn cv_detail_PlaneWarper_warpPoint_const_Point2fX_const__InputArrayX_const__InputArrayX(instance: *mut c_void, pt: *const core::Point2f, k: *mut c_void, r: *mut c_void) -> Result<core::Point2f>;
		pub fn cv_detail_PlaneWarper_warpPoint_const_Point2fX_const__InputArrayX_const__InputArrayX_const__InputArrayX(instance: *mut c_void, pt: *const core::Point2f, k: *mut c_void, r: *mut c_void, t: *mut c_void) -> Result<core::Point2f>;
		pub fn cv_detail_PlaneWarper_buildMaps_Size_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, src_size: *const core::Size, k: *mut c_void, r: *mut c_void, t: *mut c_void, xmap: *mut c_void, ymap: *mut c_void) -> Result<core::Rect>;
		pub fn cv_detail_PlaneWarper_buildMaps_Size_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, src_size: *const core::Size, k: *mut c_void, r: *mut c_void, xmap: *mut c_void, ymap: *mut c_void) -> Result<core::Rect>;
		pub fn cv_detail_PlaneWarper_warp_const__InputArrayX_const__InputArrayX_const__InputArrayX_int_int_const__OutputArrayX(instance: *mut c_void, src: *mut c_void, k: *mut c_void, r: *mut c_void, interp_mode: i32, border_mode: i32, dst: *mut c_void) -> Result<core::Point>;
		pub fn cv_detail_PlaneWarper_warp_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_int_int_const__OutputArrayX(instance: *mut c_void, src: *mut c_void, k: *mut c_void, r: *mut c_void, t: *mut c_void, interp_mode: i32, border_mode: i32, dst: *mut c_void) -> Result<core::Point>;
		pub fn cv_detail_PlaneWarper_warpRoi_Size_const__InputArrayX_const__InputArrayX(instance: *mut c_void, src_size: *const core::Size, k: *mut c_void, r: *mut c_void) -> Result<core::Rect>;
		pub fn cv_detail_PlaneWarper_warpRoi_Size_const__InputArrayX_const__InputArrayX_const__InputArrayX(instance: *mut c_void, src_size: *const core::Size, k: *mut c_void, r: *mut c_void, t: *mut c_void) -> Result<core::Rect>;
		pub fn cv_detail_PlaneWarperGpu_PlaneWarperGpu_float(scale: f32) -> Result<*mut c_void>;
		pub fn cv_detail_PlaneWarperGpu_buildMaps_Size_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, src_size: *const core::Size, k: *mut c_void, r: *mut c_void, xmap: *mut c_void, ymap: *mut c_void) -> Result<core::Rect>;
		pub fn cv_detail_PlaneWarperGpu_buildMaps_Size_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, src_size: *const core::Size, k: *mut c_void, r: *mut c_void, t: *mut c_void, xmap: *mut c_void, ymap: *mut c_void) -> Result<core::Rect>;
		pub fn cv_detail_PlaneWarperGpu_warp_const__InputArrayX_const__InputArrayX_const__InputArrayX_int_int_const__OutputArrayX(instance: *mut c_void, src: *mut c_void, k: *mut c_void, r: *mut c_void, interp_mode: i32, border_mode: i32, dst: *mut c_void) -> Result<core::Point>;
		pub fn cv_detail_PlaneWarperGpu_warp_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX_int_int_const__OutputArrayX(instance: *mut c_void, src: *mut c_void, k: *mut c_void, r: *mut c_void, t: *mut c_void, interp_mode: i32, border_mode: i32, dst: *mut c_void) -> Result<core::Point>;
		pub fn cv_detail_ProjectorBase_scale_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_detail_ProjectorBase_setScale_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_detail_ProjectorBase_k(instance: *mut c_void) -> Result<*mut [f32; 9]>;
		pub fn cv_detail_ProjectorBase_rinv(instance: *mut c_void) -> Result<*mut [f32; 9]>;
		pub fn cv_detail_ProjectorBase_r_kinv(instance: *mut c_void) -> Result<*mut [f32; 9]>;
		pub fn cv_detail_ProjectorBase_k_rinv(instance: *mut c_void) -> Result<*mut [f32; 9]>;
		pub fn cv_detail_ProjectorBase_t(instance: *mut c_void) -> Result<*mut [f32; 3]>;
		pub fn cv_detail_ProjectorBase_setCameraParams_const__InputArrayX_const__InputArrayX_const__InputArrayX(instance: *mut c_void, k: *mut c_void, r: *mut c_void, t: *mut c_void) -> Result_void;
		pub fn cv_detail_RotationWarper_warpPoint_const_Point2fX_const__InputArrayX_const__InputArrayX(instance: *mut c_void, pt: *const core::Point2f, k: *mut c_void, r: *mut c_void) -> Result<core::Point2f>;
		pub fn cv_detail_RotationWarper_buildMaps_Size_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, src_size: *const core::Size, k: *mut c_void, r: *mut c_void, xmap: *mut c_void, ymap: *mut c_void) -> Result<core::Rect>;
		pub fn cv_detail_RotationWarper_warp_const__InputArrayX_const__InputArrayX_const__InputArrayX_int_int_const__OutputArrayX(instance: *mut c_void, src: *mut c_void, k: *mut c_void, r: *mut c_void, interp_mode: i32, border_mode: i32, dst: *mut c_void) -> Result<core::Point>;
		pub fn cv_detail_RotationWarper_warpBackward_const__InputArrayX_const__InputArrayX_const__InputArrayX_int_int_Size_const__OutputArrayX(instance: *mut c_void, src: *mut c_void, k: *mut c_void, r: *mut c_void, interp_mode: i32, border_mode: i32, dst_size: *const core::Size, dst: *mut c_void) -> Result_void;
		pub fn cv_detail_RotationWarper_warpRoi_Size_const__InputArrayX_const__InputArrayX(instance: *mut c_void, src_size: *const core::Size, k: *mut c_void, r: *mut c_void) -> Result<core::Rect>;
		pub fn cv_detail_RotationWarper_getScale_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_detail_RotationWarper_setScale_float(instance: *mut c_void, unnamed: f32) -> Result_void;
		pub fn cv_detail_SeamFinder_find_const_vector_UMat_X_const_vector_Point_X_vector_UMat_X(instance: *mut c_void, src: *mut c_void, corners: *mut c_void, masks: *mut c_void) -> Result_void;
		pub fn cv_detail_SeamFinder_createDefault_int(typ: i32) -> Result<*mut c_void>;
		pub fn cv_detail_SphericalPortraitProjector_mapForward_float_float_floatX_floatX(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32) -> Result_void;
		pub fn cv_detail_SphericalPortraitProjector_mapBackward_float_float_floatX_floatX(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32) -> Result_void;
		pub fn cv_detail_SphericalPortraitWarper_SphericalPortraitWarper_float(scale: f32) -> Result<*mut c_void>;
		pub fn cv_detail_SphericalProjector_mapForward_float_float_floatX_floatX(instance: *const crate::stitching::Detail_SphericalProjector, x: f32, y: f32, u: *mut f32, v: *mut f32) -> Result_void;
		pub fn cv_detail_SphericalProjector_mapBackward_float_float_floatX_floatX(instance: *const crate::stitching::Detail_SphericalProjector, u: f32, v: f32, x: *mut f32, y: *mut f32) -> Result_void;
		pub fn cv_detail_SphericalWarper_SphericalWarper_float(scale: f32) -> Result<*mut c_void>;
		pub fn cv_detail_SphericalWarper_buildMaps_Size_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, src_size: *const core::Size, k: *mut c_void, r: *mut c_void, xmap: *mut c_void, ymap: *mut c_void) -> Result<core::Rect>;
		pub fn cv_detail_SphericalWarper_warp_const__InputArrayX_const__InputArrayX_const__InputArrayX_int_int_const__OutputArrayX(instance: *mut c_void, src: *mut c_void, k: *mut c_void, r: *mut c_void, interp_mode: i32, border_mode: i32, dst: *mut c_void) -> Result<core::Point>;
		pub fn cv_detail_SphericalWarperGpu_SphericalWarperGpu_float(scale: f32) -> Result<*mut c_void>;
		pub fn cv_detail_SphericalWarperGpu_buildMaps_Size_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, src_size: *const core::Size, k: *mut c_void, r: *mut c_void, xmap: *mut c_void, ymap: *mut c_void) -> Result<core::Rect>;
		pub fn cv_detail_SphericalWarperGpu_warp_const__InputArrayX_const__InputArrayX_const__InputArrayX_int_int_const__OutputArrayX(instance: *mut c_void, src: *mut c_void, k: *mut c_void, r: *mut c_void, interp_mode: i32, border_mode: i32, dst: *mut c_void) -> Result<core::Point>;
		pub fn cv_detail_StereographicProjector_mapForward_float_float_floatX_floatX(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32) -> Result_void;
		pub fn cv_detail_StereographicProjector_mapBackward_float_float_floatX_floatX(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32) -> Result_void;
		pub fn cv_detail_StereographicWarper_StereographicWarper_float(scale: f32) -> Result<*mut c_void>;
		pub fn cv_detail_TransverseMercatorProjector_mapForward_float_float_floatX_floatX(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32) -> Result_void;
		pub fn cv_detail_TransverseMercatorProjector_mapBackward_float_float_floatX_floatX(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32) -> Result_void;
		pub fn cv_detail_TransverseMercatorWarper_TransverseMercatorWarper_float(scale: f32) -> Result<*mut c_void>;
		pub fn cv_detail_VoronoiSeamFinder_find_const_vector_UMat_X_const_vector_Point_X_vector_UMat_X(instance: *mut c_void, src: *mut c_void, corners: *mut c_void, masks: *mut c_void) -> Result_void;
		pub fn cv_detail_VoronoiSeamFinder_find_const_vector_Size_X_const_vector_Point_X_vector_UMat_X(instance: *mut c_void, size: *mut c_void, corners: *mut c_void, masks: *mut c_void) -> Result_void;
	}
}
pub use stitching_sys::*;

#[cfg(feature = "contrib")]
mod structured_light_sys {
	use super::*;

	extern "C" {
		pub fn cv_structured_light_GrayCodePattern_create_const_ParamsX(parameters: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_structured_light_GrayCodePattern_create_int_int(width: i32, height: i32) -> Result<*mut c_void>;
		pub fn cv_structured_light_GrayCodePattern_getNumberOfPatternImages_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_structured_light_GrayCodePattern_setWhiteThreshold_size_t(instance: *mut c_void, value: size_t) -> Result_void;
		pub fn cv_structured_light_GrayCodePattern_setBlackThreshold_size_t(instance: *mut c_void, value: size_t) -> Result_void;
		pub fn cv_structured_light_GrayCodePattern_getImagesForShadowMasks_const_const__InputOutputArrayX_const__InputOutputArrayX(instance: *mut c_void, black_image: *mut c_void, white_image: *mut c_void) -> Result_void;
		pub fn cv_structured_light_GrayCodePattern_getProjPixel_const_const__InputArrayX_int_int_PointX(instance: *mut c_void, pattern_images: *mut c_void, x: i32, y: i32, proj_pix: *mut core::Point) -> Result<bool>;
		pub fn cv_structured_light_GrayCodePattern_Params_width_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_structured_light_GrayCodePattern_Params_setWidth_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_structured_light_GrayCodePattern_Params_height_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_structured_light_GrayCodePattern_Params_setHeight_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_structured_light_GrayCodePattern_Params_Params() -> Result<*mut c_void>;
		pub fn cv_structured_light_SinusoidalPattern_create_Ptr_Params_(parameters: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_structured_light_SinusoidalPattern_computePhaseMap_const__InputArrayX_const__OutputArrayX_const__OutputArrayX_const__InputArrayX(instance: *mut c_void, pattern_images: *mut c_void, wrapped_phase_map: *mut c_void, shadow_mask: *mut c_void, fundamental: *mut c_void) -> Result_void;
		pub fn cv_structured_light_SinusoidalPattern_unwrapPhaseMap_const__InputArrayX_const__OutputArrayX_Size_const__InputArrayX(instance: *mut c_void, wrapped_phase_map: *mut c_void, unwrapped_phase_map: *mut c_void, cam_size: *const core::Size, shadow_mask: *mut c_void) -> Result_void;
		pub fn cv_structured_light_SinusoidalPattern_findProCamMatches_const__InputArrayX_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, proj_unwrapped_phase_map: *mut c_void, cam_unwrapped_phase_map: *mut c_void, matches: *mut c_void) -> Result_void;
		pub fn cv_structured_light_SinusoidalPattern_computeDataModulationTerm_const__InputArrayX_const__OutputArrayX_const__InputArrayX(instance: *mut c_void, pattern_images: *mut c_void, data_modulation_term: *mut c_void, shadow_mask: *mut c_void) -> Result_void;
		pub fn cv_structured_light_SinusoidalPattern_Params_width_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_structured_light_SinusoidalPattern_Params_setWidth_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_structured_light_SinusoidalPattern_Params_height_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_structured_light_SinusoidalPattern_Params_setHeight_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_structured_light_SinusoidalPattern_Params_nbrOfPeriods_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_structured_light_SinusoidalPattern_Params_setNbrOfPeriods_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_structured_light_SinusoidalPattern_Params_shiftValue_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_structured_light_SinusoidalPattern_Params_setShiftValue_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_structured_light_SinusoidalPattern_Params_methodId_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_structured_light_SinusoidalPattern_Params_setMethodId_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_structured_light_SinusoidalPattern_Params_nbrOfPixelsBetweenMarkers_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_structured_light_SinusoidalPattern_Params_setNbrOfPixelsBetweenMarkers_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_structured_light_SinusoidalPattern_Params_horizontal_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_structured_light_SinusoidalPattern_Params_setHorizontal_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_structured_light_SinusoidalPattern_Params_setMarkers_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_structured_light_SinusoidalPattern_Params_setSetMarkers_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_structured_light_SinusoidalPattern_Params_markersLocation(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_structured_light_SinusoidalPattern_Params_setMarkersLocation_vector_Point2f_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_structured_light_SinusoidalPattern_Params_Params() -> Result<*mut c_void>;
		pub fn cv_structured_light_StructuredLightPattern_generate_const__OutputArrayX(instance: *mut c_void, pattern_images: *mut c_void) -> Result<bool>;
		pub fn cv_structured_light_StructuredLightPattern_decode_const_const_vector_vector_Mat__X_const__OutputArrayX_const__InputArrayX_const__InputArrayX_int(instance: *mut c_void, pattern_images: *mut c_void, disparity_map: *mut c_void, black_images: *mut c_void, white_images: *mut c_void, flags: i32) -> Result<bool>;
	}
}
#[cfg(feature = "contrib")]
pub use structured_light_sys::*;

#[cfg(feature = "contrib")]
mod superres_sys {
	use super::*;

	extern "C" {
		pub fn cv_superres_createFrameSource_Camera_int(device_id: i32) -> Result<*mut c_void>;
		pub fn cv_superres_createFrameSource_Empty() -> Result<*mut c_void>;
		pub fn cv_superres_createFrameSource_Video_CUDA_const_StringX(file_name: *const c_char) -> Result<*mut c_void>;
		pub fn cv_superres_createFrameSource_Video_const_StringX(file_name: *const c_char) -> Result<*mut c_void>;
		pub fn cv_superres_createOptFlow_Brox_CUDA() -> Result<*mut c_void>;
		pub fn cv_superres_createOptFlow_DualTVL1() -> Result<*mut c_void>;
		pub fn cv_superres_createOptFlow_DualTVL1_CUDA() -> Result<*mut c_void>;
		pub fn cv_superres_createOptFlow_Farneback() -> Result<*mut c_void>;
		pub fn cv_superres_createOptFlow_Farneback_CUDA() -> Result<*mut c_void>;
		pub fn cv_superres_createOptFlow_PyrLK_CUDA() -> Result<*mut c_void>;
		pub fn cv_superres_createSuperResolution_BTVL1() -> Result<*mut c_void>;
		pub fn cv_superres_createSuperResolution_BTVL1_CUDA() -> Result<*mut c_void>;
		pub fn cv_superres_BroxOpticalFlow_getAlpha_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_superres_BroxOpticalFlow_setAlpha_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_superres_BroxOpticalFlow_getGamma_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_superres_BroxOpticalFlow_setGamma_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_superres_BroxOpticalFlow_getScaleFactor_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_superres_BroxOpticalFlow_setScaleFactor_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_superres_BroxOpticalFlow_getInnerIterations_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_superres_BroxOpticalFlow_setInnerIterations_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_superres_BroxOpticalFlow_getOuterIterations_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_superres_BroxOpticalFlow_setOuterIterations_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_superres_BroxOpticalFlow_getSolverIterations_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_superres_BroxOpticalFlow_setSolverIterations_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_superres_DenseOpticalFlowExt_calc_const__InputArrayX_const__InputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, frame0: *mut c_void, frame1: *mut c_void, flow1: *mut c_void, flow2: *mut c_void) -> Result_void;
		pub fn cv_superres_DenseOpticalFlowExt_collectGarbage(instance: *mut c_void) -> Result_void;
		pub fn cv_superres_DualTVL1OpticalFlow_getTau_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_superres_DualTVL1OpticalFlow_setTau_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_superres_DualTVL1OpticalFlow_getLambda_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_superres_DualTVL1OpticalFlow_setLambda_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_superres_DualTVL1OpticalFlow_getTheta_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_superres_DualTVL1OpticalFlow_setTheta_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_superres_DualTVL1OpticalFlow_getScalesNumber_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_superres_DualTVL1OpticalFlow_setScalesNumber_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_superres_DualTVL1OpticalFlow_getWarpingsNumber_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_superres_DualTVL1OpticalFlow_setWarpingsNumber_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_superres_DualTVL1OpticalFlow_getEpsilon_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_superres_DualTVL1OpticalFlow_setEpsilon_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_superres_DualTVL1OpticalFlow_getIterations_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_superres_DualTVL1OpticalFlow_setIterations_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_superres_DualTVL1OpticalFlow_getUseInitialFlow_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_superres_DualTVL1OpticalFlow_setUseInitialFlow_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_superres_FarnebackOpticalFlow_getPyrScale_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_superres_FarnebackOpticalFlow_setPyrScale_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_superres_FarnebackOpticalFlow_getLevelsNumber_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_superres_FarnebackOpticalFlow_setLevelsNumber_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_superres_FarnebackOpticalFlow_getWindowSize_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_superres_FarnebackOpticalFlow_setWindowSize_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_superres_FarnebackOpticalFlow_getIterations_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_superres_FarnebackOpticalFlow_setIterations_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_superres_FarnebackOpticalFlow_getPolyN_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_superres_FarnebackOpticalFlow_setPolyN_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_superres_FarnebackOpticalFlow_getPolySigma_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_superres_FarnebackOpticalFlow_setPolySigma_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_superres_FarnebackOpticalFlow_getFlags_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_superres_FarnebackOpticalFlow_setFlags_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_superres_FrameSource_nextFrame_const__OutputArrayX(instance: *mut c_void, frame: *mut c_void) -> Result_void;
		pub fn cv_superres_FrameSource_reset(instance: *mut c_void) -> Result_void;
		pub fn cv_superres_PyrLKOpticalFlow_getWindowSize_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_superres_PyrLKOpticalFlow_setWindowSize_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_superres_PyrLKOpticalFlow_getMaxLevel_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_superres_PyrLKOpticalFlow_setMaxLevel_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_superres_PyrLKOpticalFlow_getIterations_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_superres_PyrLKOpticalFlow_setIterations_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_superres_SuperResolution_setInput_const_Ptr_FrameSource_X(instance: *mut c_void, frame_source: *mut c_void) -> Result_void;
		pub fn cv_superres_SuperResolution_nextFrame_const__OutputArrayX(instance: *mut c_void, frame: *mut c_void) -> Result_void;
		pub fn cv_superres_SuperResolution_reset(instance: *mut c_void) -> Result_void;
		pub fn cv_superres_SuperResolution_collectGarbage(instance: *mut c_void) -> Result_void;
		pub fn cv_superres_SuperResolution_getScale_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_superres_SuperResolution_setScale_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_superres_SuperResolution_getIterations_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_superres_SuperResolution_setIterations_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_superres_SuperResolution_getTau_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_superres_SuperResolution_setTau_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_superres_SuperResolution_getLambda_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_superres_SuperResolution_setLambda_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_superres_SuperResolution_getAlpha_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_superres_SuperResolution_setAlpha_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_superres_SuperResolution_getKernelSize_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_superres_SuperResolution_setKernelSize_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_superres_SuperResolution_getBlurKernelSize_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_superres_SuperResolution_setBlurKernelSize_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_superres_SuperResolution_getBlurSigma_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_superres_SuperResolution_setBlurSigma_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_superres_SuperResolution_getTemporalAreaRadius_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_superres_SuperResolution_setTemporalAreaRadius_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_superres_SuperResolution_getOpticalFlow_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_superres_SuperResolution_setOpticalFlow_const_Ptr_DenseOpticalFlowExt_X(instance: *mut c_void, val: *mut c_void) -> Result_void;
	}
}
#[cfg(feature = "contrib")]
pub use superres_sys::*;

#[cfg(feature = "contrib")]
mod surface_matching_sys {
	use super::*;

	extern "C" {
		pub fn cv_ppf_match_3d_ICP_ICP() -> Result<*mut c_void>;
		pub fn cv_ppf_match_3d_ICP_ICP_int_float_float_int_int_int(iterations: i32, tolerence: f32, rejection_scale: f32, num_levels: i32, sample_type: i32, num_max_corr: i32) -> Result<*mut c_void>;
		pub fn cv_ppf_match_3d_ICP_registerModelToScene_const_MatX_const_MatX_vector_Pose3DPtr_X(instance: *mut c_void, src_pc: *mut c_void, dst_pc: *mut c_void, poses: *mut c_void) -> Result<i32>;
		pub fn cv_ppf_match_3d_PPF3DDetector_PPF3DDetector() -> Result<*mut c_void>;
		pub fn cv_ppf_match_3d_PPF3DDetector_PPF3DDetector_double_double_double(relative_sampling_step: f64, relative_distance_step: f64, num_angles: f64) -> Result<*mut c_void>;
		pub fn cv_ppf_match_3d_PPF3DDetector_setSearchParams_double_double_bool(instance: *mut c_void, position_threshold: f64, rotation_threshold: f64, use_weighted_clustering: bool) -> Result_void;
		pub fn cv_ppf_match_3d_PPF3DDetector_trainModel_const_MatX(instance: *mut c_void, model: *mut c_void) -> Result_void;
		pub fn cv_ppf_match_3d_PPF3DDetector_match_const_MatX_vector_Pose3DPtr_X_double_double(instance: *mut c_void, scene: *mut c_void, results: *mut c_void, relative_scene_sample_step: f64, relative_scene_distance: f64) -> Result_void;
		pub fn cv_ppf_match_3d_PPF3DDetector_read_const_FileNodeX(instance: *mut c_void, fn_: *mut c_void) -> Result_void;
		pub fn cv_ppf_match_3d_PPF3DDetector_write_const_FileStorageX(instance: *mut c_void, fs: *mut c_void) -> Result_void;
		pub fn cv_ppf_match_3d_Pose3D_alpha_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ppf_match_3d_Pose3D_setAlpha_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_ppf_match_3d_Pose3D_residual_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ppf_match_3d_Pose3D_setResidual_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_ppf_match_3d_Pose3D_modelIndex_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_ppf_match_3d_Pose3D_setModelIndex_size_t(instance: *mut c_void, val: size_t) -> Result_void;
		pub fn cv_ppf_match_3d_Pose3D_numVotes_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_ppf_match_3d_Pose3D_setNumVotes_size_t(instance: *mut c_void, val: size_t) -> Result_void;
		pub fn cv_ppf_match_3d_Pose3D_angle_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_ppf_match_3d_Pose3D_setAngle_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_ppf_match_3d_Pose3D_t_const(instance: *mut c_void) -> Result<core::Vec3d>;
		pub fn cv_ppf_match_3d_Pose3D_setT_Vec3d(instance: *mut c_void, val: *const core::Vec3d) -> Result_void;
		pub fn cv_ppf_match_3d_Pose3D_q_const(instance: *mut c_void) -> Result<core::Vec4d>;
		pub fn cv_ppf_match_3d_Pose3D_setQ_Vec4d(instance: *mut c_void, val: *const core::Vec4d) -> Result_void;
		pub fn cv_ppf_match_3d_Pose3D_Pose3D() -> Result<*mut c_void>;
		pub fn cv_ppf_match_3d_Pose3D_Pose3D_double_size_t_size_t(alpha: f64, model_index: size_t, num_votes: size_t) -> Result<*mut c_void>;
		pub fn cv_ppf_match_3d_Pose3D_updatePoseQuat_Vec4dX_Vec3dX(instance: *mut c_void, q: *mut core::Vec4d, new_t: *mut core::Vec3d) -> Result_void;
		pub fn cv_ppf_match_3d_Pose3D_printPose(instance: *mut c_void) -> Result_void;
		pub fn cv_ppf_match_3d_Pose3D_clone(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ppf_match_3d_Pose3D_writePose_const_stringX(instance: *mut c_void, file_name: *const c_char) -> Result<i32>;
		pub fn cv_ppf_match_3d_Pose3D_readPose_const_stringX(instance: *mut c_void, file_name: *const c_char) -> Result<i32>;
		pub fn cv_ppf_match_3d_PoseCluster3D_poseList(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ppf_match_3d_PoseCluster3D_setPoseList_vector_Pose3DPtr_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_ppf_match_3d_PoseCluster3D_numVotes_const(instance: *mut c_void) -> Result<size_t>;
		pub fn cv_ppf_match_3d_PoseCluster3D_setNumVotes_size_t(instance: *mut c_void, val: size_t) -> Result_void;
		pub fn cv_ppf_match_3d_PoseCluster3D_id_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_ppf_match_3d_PoseCluster3D_setId_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_ppf_match_3d_PoseCluster3D_PoseCluster3D() -> Result<*mut c_void>;
		pub fn cv_ppf_match_3d_PoseCluster3D_PoseCluster3D_Pose3DPtr(new_pose: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_ppf_match_3d_PoseCluster3D_PoseCluster3D_Pose3DPtr_int(new_pose: *mut c_void, new_id: i32) -> Result<*mut c_void>;
		pub fn cv_ppf_match_3d_PoseCluster3D_addPose_Pose3DPtr(instance: *mut c_void, new_pose: *mut c_void) -> Result_void;
		pub fn cv_ppf_match_3d_PoseCluster3D_writePoseCluster_const_stringX(instance: *mut c_void, file_name: *const c_char) -> Result<i32>;
		pub fn cv_ppf_match_3d_PoseCluster3D_readPoseCluster_const_stringX(instance: *mut c_void, file_name: *const c_char) -> Result<i32>;
	}
}
#[cfg(feature = "contrib")]
pub use surface_matching_sys::*;

#[cfg(feature = "contrib")]
mod text_sys {
	use super::*;

	extern "C" {
		pub fn cv_text_MSERsToERStats_const__InputArrayX_vector_vector_Point__X_vector_vector_ERStat__X(image: *mut c_void, contours: *mut c_void, regions: *mut c_void) -> Result_void;
		pub fn cv_text_computeNMChannels_const__InputArrayX_const__OutputArrayX_int(_src: *mut c_void, _channels: *mut c_void, _mode: i32) -> Result_void;
		pub fn cv_text_createERFilterNM1_const_Ptr_Callback_X_int_float_float_float_bool_float(cb: *mut c_void, threshold_delta: i32, min_area: f32, max_area: f32, min_probability: f32, non_max_suppression: bool, min_probability_diff: f32) -> Result<*mut c_void>;
		pub fn cv_text_createERFilterNM1_const_StringX_int_float_float_float_bool_float(filename: *const c_char, threshold_delta: i32, min_area: f32, max_area: f32, min_probability: f32, non_max_suppression: bool, min_probability_diff: f32) -> Result<*mut c_void>;
		pub fn cv_text_createERFilterNM2_const_Ptr_Callback_X_float(cb: *mut c_void, min_probability: f32) -> Result<*mut c_void>;
		pub fn cv_text_createERFilterNM2_const_StringX_float(filename: *const c_char, min_probability: f32) -> Result<*mut c_void>;
		pub fn cv_text_createOCRHMMTransitionsTable_const_StringX_vector_String_X(vocabulary: *const c_char, lexicon: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_text_createOCRHMMTransitionsTable_stringX_vector_string_X_const__OutputArrayX(vocabulary: *mut *mut c_void, lexicon: *mut c_void, transition_probabilities_table: *mut c_void) -> Result_void;
		pub fn cv_text_detectRegions_const__InputArrayX_const_Ptr_ERFilter_X_const_Ptr_ERFilter_X_vector_Rect_X_int_const_StringX_float(image: *mut c_void, er_filter1: *mut c_void, er_filter2: *mut c_void, groups_rects: *mut c_void, method: i32, filename: *const c_char, min_probability: f32) -> Result_void;
		pub fn cv_text_detectRegions_const__InputArrayX_const_Ptr_ERFilter_X_const_Ptr_ERFilter_X_vector_vector_Point__X(image: *mut c_void, er_filter1: *mut c_void, er_filter2: *mut c_void, regions: *mut c_void) -> Result_void;
		pub fn cv_text_erGrouping_const__InputArrayX_const__InputArrayX_vector_vector_ERStat__X_vector_vector_Vec2i__X_vector_Rect_X_int_const_stringX_float(img: *mut c_void, channels: *mut c_void, regions: *mut c_void, groups: *mut c_void, groups_rects: *mut c_void, method: i32, filename: *const c_char, min_probablity: f32) -> Result_void;
		pub fn cv_text_erGrouping_const__InputArrayX_const__InputArrayX_vector_vector_Point___vector_Rect_X_int_const_StringX_float(image: *mut c_void, channel: *mut c_void, regions: *mut c_void, groups_rects: *mut c_void, method: i32, filename: *const c_char, min_probablity: f32) -> Result_void;
		pub fn cv_text_loadClassifierNM1_const_StringX(filename: *const c_char) -> Result<*mut c_void>;
		pub fn cv_text_loadClassifierNM2_const_StringX(filename: *const c_char) -> Result<*mut c_void>;
		pub fn cv_text_loadOCRBeamSearchClassifierCNN_const_StringX(filename: *const c_char) -> Result<*mut c_void>;
		pub fn cv_text_loadOCRHMMClassifierCNN_const_StringX(filename: *const c_char) -> Result<*mut c_void>;
		pub fn cv_text_loadOCRHMMClassifierNM_const_StringX(filename: *const c_char) -> Result<*mut c_void>;
		pub fn cv_text_loadOCRHMMClassifier_const_StringX_int(filename: *const c_char, classifier: i32) -> Result<*mut c_void>;
		pub fn cv_text_BaseOCR_run_MatX_stringX_vector_Rect_X_vector_string_X_vector_float_X_int(instance: *mut c_void, image: *mut c_void, output_text: *mut *mut c_void, component_rects: *mut c_void, component_texts: *mut c_void, component_confidences: *mut c_void, component_level: i32) -> Result_void;
		pub fn cv_text_BaseOCR_run_MatX_MatX_stringX_vector_Rect_X_vector_string_X_vector_float_X_int(instance: *mut c_void, image: *mut c_void, mask: *mut c_void, output_text: *mut *mut c_void, component_rects: *mut c_void, component_texts: *mut c_void, component_confidences: *mut c_void, component_level: i32) -> Result_void;
		pub fn cv_text_ERFilter_run_const__InputArrayX_vector_ERStat_X(instance: *mut c_void, image: *mut c_void, regions: *mut c_void) -> Result_void;
		pub fn cv_text_ERFilter_setCallback_const_Ptr_Callback_X(instance: *mut c_void, cb: *mut c_void) -> Result_void;
		pub fn cv_text_ERFilter_setThresholdDelta_int(instance: *mut c_void, threshold_delta: i32) -> Result_void;
		pub fn cv_text_ERFilter_setMinArea_float(instance: *mut c_void, min_area: f32) -> Result_void;
		pub fn cv_text_ERFilter_setMaxArea_float(instance: *mut c_void, max_area: f32) -> Result_void;
		pub fn cv_text_ERFilter_setMinProbability_float(instance: *mut c_void, min_probability: f32) -> Result_void;
		pub fn cv_text_ERFilter_setMinProbabilityDiff_float(instance: *mut c_void, min_probability_diff: f32) -> Result_void;
		pub fn cv_text_ERFilter_setNonMaxSuppression_bool(instance: *mut c_void, non_max_suppression: bool) -> Result_void;
		pub fn cv_text_ERFilter_getNumRejected_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_text_ERFilter_Callback_eval_const_ERStatX(instance: *mut c_void, stat: *mut c_void) -> Result<f64>;
		pub fn cv_text_ERStat_pixel_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_text_ERStat_setPixel_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_text_ERStat_level_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_text_ERStat_setLevel_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_text_ERStat_area_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_text_ERStat_setArea_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_text_ERStat_perimeter_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_text_ERStat_setPerimeter_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_text_ERStat_euler_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_text_ERStat_setEuler_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_text_ERStat_rect_const(instance: *mut c_void) -> Result<core::Rect>;
		pub fn cv_text_ERStat_setRect_Rect(instance: *mut c_void, val: *const core::Rect) -> Result_void;
		pub fn cv_text_ERStat_raw_moments(instance: *mut c_void) -> Result<*mut [f64; 2]>;
		pub fn cv_text_ERStat_central_moments(instance: *mut c_void) -> Result<*mut [f64; 3]>;
		pub fn cv_text_ERStat_med_crossings_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_text_ERStat_setMed_crossings_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_text_ERStat_hole_area_ratio_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_text_ERStat_setHole_area_ratio_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_text_ERStat_convex_hull_ratio_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_text_ERStat_setConvex_hull_ratio_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_text_ERStat_num_inflexion_points_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_text_ERStat_setNum_inflexion_points_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_text_ERStat_pixels(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_text_ERStat_setPixels_vector_int_X(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_text_ERStat_probability_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_text_ERStat_setProbability_double(instance: *mut c_void, val: f64) -> Result_void;
		pub fn cv_text_ERStat_parent(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_text_ERStat_setParent_ERStatX(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_text_ERStat_child(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_text_ERStat_setChild_ERStatX(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_text_ERStat_next(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_text_ERStat_setNext_ERStatX(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_text_ERStat_prev(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_text_ERStat_setPrev_ERStatX(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_text_ERStat_local_maxima_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_text_ERStat_setLocal_maxima_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_text_ERStat_max_probability_ancestor(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_text_ERStat_setMax_probability_ancestor_ERStatX(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_text_ERStat_min_probability_ancestor(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_text_ERStat_setMin_probability_ancestor_ERStatX(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_text_ERStat_ERStat_int_int_int_int(level: i32, pixel: i32, x: i32, y: i32) -> Result<*mut c_void>;
		pub fn cv_text_OCRBeamSearchDecoder_run_MatX_stringX_vector_Rect_X_vector_string_X_vector_float_X_int(instance: *mut c_void, image: *mut c_void, output_text: *mut *mut c_void, component_rects: *mut c_void, component_texts: *mut c_void, component_confidences: *mut c_void, component_level: i32) -> Result_void;
		pub fn cv_text_OCRBeamSearchDecoder_run_MatX_MatX_stringX_vector_Rect_X_vector_string_X_vector_float_X_int(instance: *mut c_void, image: *mut c_void, mask: *mut c_void, output_text: *mut *mut c_void, component_rects: *mut c_void, component_texts: *mut c_void, component_confidences: *mut c_void, component_level: i32) -> Result_void;
		pub fn cv_text_OCRBeamSearchDecoder_run_const__InputArrayX_int_int(instance: *mut c_void, image: *mut c_void, min_confidence: i32, component_level: i32) -> Result<*mut c_void>;
		pub fn cv_text_OCRBeamSearchDecoder_run_const__InputArrayX_const__InputArrayX_int_int(instance: *mut c_void, image: *mut c_void, mask: *mut c_void, min_confidence: i32, component_level: i32) -> Result<*mut c_void>;
		pub fn cv_text_OCRBeamSearchDecoder_create_Ptr_ClassifierCallback__const_stringX_const__InputArrayX_const__InputArrayX_decoder_mode_int(classifier: *mut c_void, vocabulary: *const c_char, transition_probabilities_table: *mut c_void, emission_probabilities_table: *mut c_void, mode: crate::text::decoder_mode, beam_size: i32) -> Result<*mut c_void>;
		pub fn cv_text_OCRBeamSearchDecoder_create_Ptr_ClassifierCallback__const_StringX_const__InputArrayX_const__InputArrayX_int_int(classifier: *mut c_void, vocabulary: *const c_char, transition_probabilities_table: *mut c_void, emission_probabilities_table: *mut c_void, mode: i32, beam_size: i32) -> Result<*mut c_void>;
		pub fn cv_text_OCRBeamSearchDecoder_create_const_StringX_const_StringX_const__InputArrayX_const__InputArrayX_int_int(filename: *const c_char, vocabulary: *const c_char, transition_probabilities_table: *mut c_void, emission_probabilities_table: *mut c_void, mode: i32, beam_size: i32) -> Result<*mut c_void>;
		pub fn cv_text_OCRBeamSearchDecoder_ClassifierCallback_eval_const__InputArrayX_vector_vector_double__X_vector_int_X(instance: *mut c_void, image: *mut c_void, recognition_probabilities: *mut c_void, oversegmentation: *mut c_void) -> Result_void;
		pub fn cv_text_OCRBeamSearchDecoder_ClassifierCallback_getWindowSize(instance: *mut c_void) -> Result<i32>;
		pub fn cv_text_OCRBeamSearchDecoder_ClassifierCallback_getStepSize(instance: *mut c_void) -> Result<i32>;
		pub fn cv_text_OCRHMMDecoder_run_MatX_stringX_vector_Rect_X_vector_string_X_vector_float_X_int(instance: *mut c_void, image: *mut c_void, output_text: *mut *mut c_void, component_rects: *mut c_void, component_texts: *mut c_void, component_confidences: *mut c_void, component_level: i32) -> Result_void;
		pub fn cv_text_OCRHMMDecoder_run_MatX_MatX_stringX_vector_Rect_X_vector_string_X_vector_float_X_int(instance: *mut c_void, image: *mut c_void, mask: *mut c_void, output_text: *mut *mut c_void, component_rects: *mut c_void, component_texts: *mut c_void, component_confidences: *mut c_void, component_level: i32) -> Result_void;
		pub fn cv_text_OCRHMMDecoder_run_const__InputArrayX_int_int(instance: *mut c_void, image: *mut c_void, min_confidence: i32, component_level: i32) -> Result<*mut c_void>;
		pub fn cv_text_OCRHMMDecoder_run_const__InputArrayX_const__InputArrayX_int_int(instance: *mut c_void, image: *mut c_void, mask: *mut c_void, min_confidence: i32, component_level: i32) -> Result<*mut c_void>;
		pub fn cv_text_OCRHMMDecoder_create_Ptr_ClassifierCallback__const_StringX_const__InputArrayX_const__InputArrayX_int(classifier: *mut c_void, vocabulary: *const c_char, transition_probabilities_table: *mut c_void, emission_probabilities_table: *mut c_void, mode: i32) -> Result<*mut c_void>;
		pub fn cv_text_OCRHMMDecoder_create_const_StringX_const_StringX_const__InputArrayX_const__InputArrayX_int_int(filename: *const c_char, vocabulary: *const c_char, transition_probabilities_table: *mut c_void, emission_probabilities_table: *mut c_void, mode: i32, classifier: i32) -> Result<*mut c_void>;
		pub fn cv_text_OCRHMMDecoder_ClassifierCallback_eval_const__InputArrayX_vector_int_X_vector_double_X(instance: *mut c_void, image: *mut c_void, out_class: *mut c_void, out_confidence: *mut c_void) -> Result_void;
		pub fn cv_text_OCRHolisticWordRecognizer_run_MatX_stringX_vector_Rect_X_vector_string_X_vector_float_X_int(instance: *mut c_void, image: *mut c_void, output_text: *mut *mut c_void, component_rects: *mut c_void, component_texts: *mut c_void, component_confidences: *mut c_void, component_level: i32) -> Result_void;
		pub fn cv_text_OCRHolisticWordRecognizer_run_MatX_MatX_stringX_vector_Rect_X_vector_string_X_vector_float_X_int(instance: *mut c_void, image: *mut c_void, mask: *mut c_void, output_text: *mut *mut c_void, component_rects: *mut c_void, component_texts: *mut c_void, component_confidences: *mut c_void, component_level: i32) -> Result_void;
		pub fn cv_text_OCRHolisticWordRecognizer_create_const_stringX_const_stringX_const_stringX(arch_filename: *const c_char, weights_filename: *const c_char, words_filename: *const c_char) -> Result<*mut c_void>;
		pub fn cv_text_OCRTesseract_run_MatX_stringX_vector_Rect_X_vector_string_X_vector_float_X_int(instance: *mut c_void, image: *mut c_void, output_text: *mut *mut c_void, component_rects: *mut c_void, component_texts: *mut c_void, component_confidences: *mut c_void, component_level: i32) -> Result_void;
		pub fn cv_text_OCRTesseract_run_MatX_MatX_stringX_vector_Rect_X_vector_string_X_vector_float_X_int(instance: *mut c_void, image: *mut c_void, mask: *mut c_void, output_text: *mut *mut c_void, component_rects: *mut c_void, component_texts: *mut c_void, component_confidences: *mut c_void, component_level: i32) -> Result_void;
		pub fn cv_text_OCRTesseract_run_const__InputArrayX_int_int(instance: *mut c_void, image: *mut c_void, min_confidence: i32, component_level: i32) -> Result<*mut c_void>;
		pub fn cv_text_OCRTesseract_run_const__InputArrayX_const__InputArrayX_int_int(instance: *mut c_void, image: *mut c_void, mask: *mut c_void, min_confidence: i32, component_level: i32) -> Result<*mut c_void>;
		pub fn cv_text_OCRTesseract_setWhiteList_const_StringX(instance: *mut c_void, char_whitelist: *const c_char) -> Result_void;
		pub fn cv_text_OCRTesseract_create_const_charX_const_charX_const_charX_int_int(datapath: *const c_char, language: *const c_char, char_whitelist: *const c_char, oem: i32, psmode: i32) -> Result<*mut c_void>;
		pub fn cv_text_TextDetector_detect_const__InputArrayX_vector_Rect_X_vector_float_X(instance: *mut c_void, input_image: *mut c_void, bbox: *mut c_void, confidence: *mut c_void) -> Result_void;
		pub fn cv_text_TextDetectorCNN_detect_const__InputArrayX_vector_Rect_X_vector_float_X(instance: *mut c_void, input_image: *mut c_void, bbox: *mut c_void, confidence: *mut c_void) -> Result_void;
		pub fn cv_text_TextDetectorCNN_create_const_StringX_const_StringX_vector_Size_(model_arch_filename: *const c_char, model_weights_filename: *const c_char, detection_sizes: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_text_TextDetectorCNN_create_const_StringX_const_StringX(model_arch_filename: *const c_char, model_weights_filename: *const c_char) -> Result<*mut c_void>;
	}
}
#[cfg(feature = "contrib")]
pub use text_sys::*;

mod video_sys {
	use super::*;

	extern "C" {
		pub fn cv_CamShift_const__InputArrayX_RectX_TermCriteria(prob_image: *mut c_void, window: *mut core::Rect, criteria: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_buildOpticalFlowPyramid_const__InputArrayX_const__OutputArrayX_Size_int_bool_int_int_bool(img: *mut c_void, pyramid: *mut c_void, win_size: *const core::Size, max_level: i32, with_derivatives: bool, pyr_border: i32, deriv_border: i32, try_reuse_input_image: bool) -> Result<i32>;
		pub fn cv_calcOpticalFlowFarneback_const__InputArrayX_const__InputArrayX_const__InputOutputArrayX_double_int_int_int_int_double_int(prev: *mut c_void, next: *mut c_void, flow: *mut c_void, pyr_scale: f64, levels: i32, winsize: i32, iterations: i32, poly_n: i32, poly_sigma: f64, flags: i32) -> Result_void;
		pub fn cv_calcOpticalFlowPyrLK_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputOutputArrayX_const__OutputArrayX_const__OutputArrayX_Size_int_TermCriteria_int_double(prev_img: *mut c_void, next_img: *mut c_void, prev_pts: *mut c_void, next_pts: *mut c_void, status: *mut c_void, err: *mut c_void, win_size: *const core::Size, max_level: i32, criteria: *mut c_void, flags: i32, min_eig_threshold: f64) -> Result_void;
		pub fn cv_computeECC_const__InputArrayX_const__InputArrayX_const__InputArrayX(template_image: *mut c_void, input_image: *mut c_void, input_mask: *mut c_void) -> Result<f64>;
		pub fn cv_createBackgroundSubtractorKNN_int_double_bool(history: i32, dist2_threshold: f64, detect_shadows: bool) -> Result<*mut c_void>;
		pub fn cv_createBackgroundSubtractorMOG2_int_double_bool(history: i32, var_threshold: f64, detect_shadows: bool) -> Result<*mut c_void>;
		pub fn cv_estimateRigidTransform_const__InputArrayX_const__InputArrayX_bool(src: *mut c_void, dst: *mut c_void, full_affine: bool) -> Result<*mut c_void>;
		pub fn cv_findTransformECC_const__InputArrayX_const__InputArrayX_const__InputOutputArrayX_int_TermCriteria_const__InputArrayX(template_image: *mut c_void, input_image: *mut c_void, warp_matrix: *mut c_void, motion_type: i32, criteria: *mut c_void, input_mask: *mut c_void) -> Result<f64>;
		pub fn cv_findTransformECC_const__InputArrayX_const__InputArrayX_const__InputOutputArrayX_int_TermCriteria_const__InputArrayX_int(template_image: *mut c_void, input_image: *mut c_void, warp_matrix: *mut c_void, motion_type: i32, criteria: *mut c_void, input_mask: *mut c_void, gauss_filt_size: i32) -> Result<f64>;
		pub fn cv_meanShift_const__InputArrayX_RectX_TermCriteria(prob_image: *mut c_void, window: *mut core::Rect, criteria: *mut c_void) -> Result<i32>;
		pub fn cv_readOpticalFlow_const_StringX(path: *const c_char) -> Result<*mut c_void>;
		pub fn cv_writeOpticalFlow_const_StringX_const__InputArrayX(path: *const c_char, flow: *mut c_void) -> Result<bool>;
		pub fn cv_BackgroundSubtractor_apply_const__InputArrayX_const__OutputArrayX_double(instance: *mut c_void, image: *mut c_void, fgmask: *mut c_void, learning_rate: f64) -> Result_void;
		pub fn cv_BackgroundSubtractor_getBackgroundImage_const_const__OutputArrayX(instance: *mut c_void, background_image: *mut c_void) -> Result_void;
		pub fn cv_BackgroundSubtractorKNN_getHistory_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_BackgroundSubtractorKNN_setHistory_int(instance: *mut c_void, history: i32) -> Result_void;
		pub fn cv_BackgroundSubtractorKNN_getNSamples_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_BackgroundSubtractorKNN_setNSamples_int(instance: *mut c_void, _n_n: i32) -> Result_void;
		pub fn cv_BackgroundSubtractorKNN_getDist2Threshold_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_BackgroundSubtractorKNN_setDist2Threshold_double(instance: *mut c_void, _dist2_threshold: f64) -> Result_void;
		pub fn cv_BackgroundSubtractorKNN_getkNNSamples_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_BackgroundSubtractorKNN_setkNNSamples_int(instance: *mut c_void, _nk_nn: i32) -> Result_void;
		pub fn cv_BackgroundSubtractorKNN_getDetectShadows_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_BackgroundSubtractorKNN_setDetectShadows_bool(instance: *mut c_void, detect_shadows: bool) -> Result_void;
		pub fn cv_BackgroundSubtractorKNN_getShadowValue_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_BackgroundSubtractorKNN_setShadowValue_int(instance: *mut c_void, value: i32) -> Result_void;
		pub fn cv_BackgroundSubtractorKNN_getShadowThreshold_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_BackgroundSubtractorKNN_setShadowThreshold_double(instance: *mut c_void, threshold: f64) -> Result_void;
		pub fn cv_BackgroundSubtractorMOG2_getHistory_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_BackgroundSubtractorMOG2_setHistory_int(instance: *mut c_void, history: i32) -> Result_void;
		pub fn cv_BackgroundSubtractorMOG2_getNMixtures_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_BackgroundSubtractorMOG2_setNMixtures_int(instance: *mut c_void, nmixtures: i32) -> Result_void;
		pub fn cv_BackgroundSubtractorMOG2_getBackgroundRatio_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_BackgroundSubtractorMOG2_setBackgroundRatio_double(instance: *mut c_void, ratio: f64) -> Result_void;
		pub fn cv_BackgroundSubtractorMOG2_getVarThreshold_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_BackgroundSubtractorMOG2_setVarThreshold_double(instance: *mut c_void, var_threshold: f64) -> Result_void;
		pub fn cv_BackgroundSubtractorMOG2_getVarThresholdGen_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_BackgroundSubtractorMOG2_setVarThresholdGen_double(instance: *mut c_void, var_threshold_gen: f64) -> Result_void;
		pub fn cv_BackgroundSubtractorMOG2_getVarInit_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_BackgroundSubtractorMOG2_setVarInit_double(instance: *mut c_void, var_init: f64) -> Result_void;
		pub fn cv_BackgroundSubtractorMOG2_getVarMin_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_BackgroundSubtractorMOG2_setVarMin_double(instance: *mut c_void, var_min: f64) -> Result_void;
		pub fn cv_BackgroundSubtractorMOG2_getVarMax_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_BackgroundSubtractorMOG2_setVarMax_double(instance: *mut c_void, var_max: f64) -> Result_void;
		pub fn cv_BackgroundSubtractorMOG2_getComplexityReductionThreshold_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_BackgroundSubtractorMOG2_setComplexityReductionThreshold_double(instance: *mut c_void, ct: f64) -> Result_void;
		pub fn cv_BackgroundSubtractorMOG2_getDetectShadows_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_BackgroundSubtractorMOG2_setDetectShadows_bool(instance: *mut c_void, detect_shadows: bool) -> Result_void;
		pub fn cv_BackgroundSubtractorMOG2_getShadowValue_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_BackgroundSubtractorMOG2_setShadowValue_int(instance: *mut c_void, value: i32) -> Result_void;
		pub fn cv_BackgroundSubtractorMOG2_getShadowThreshold_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_BackgroundSubtractorMOG2_setShadowThreshold_double(instance: *mut c_void, threshold: f64) -> Result_void;
		pub fn cv_BackgroundSubtractorMOG2_apply_const__InputArrayX_const__OutputArrayX_double(instance: *mut c_void, image: *mut c_void, fgmask: *mut c_void, learning_rate: f64) -> Result_void;
		pub fn cv_DISOpticalFlow_getFinestScale_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_DISOpticalFlow_setFinestScale_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_DISOpticalFlow_getPatchSize_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_DISOpticalFlow_setPatchSize_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_DISOpticalFlow_getPatchStride_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_DISOpticalFlow_setPatchStride_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_DISOpticalFlow_getGradientDescentIterations_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_DISOpticalFlow_setGradientDescentIterations_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_DISOpticalFlow_getVariationalRefinementIterations_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_DISOpticalFlow_setVariationalRefinementIterations_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_DISOpticalFlow_getVariationalRefinementAlpha_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_DISOpticalFlow_setVariationalRefinementAlpha_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_DISOpticalFlow_getVariationalRefinementDelta_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_DISOpticalFlow_setVariationalRefinementDelta_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_DISOpticalFlow_getVariationalRefinementGamma_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_DISOpticalFlow_setVariationalRefinementGamma_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_DISOpticalFlow_getUseMeanNormalization_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_DISOpticalFlow_setUseMeanNormalization_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_DISOpticalFlow_getUseSpatialPropagation_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_DISOpticalFlow_setUseSpatialPropagation_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_DISOpticalFlow_create_int(preset: i32) -> Result<*mut c_void>;
		pub fn cv_DenseOpticalFlow_calc_const__InputArrayX_const__InputArrayX_const__InputOutputArrayX(instance: *mut c_void, i0: *mut c_void, i1: *mut c_void, flow: *mut c_void) -> Result_void;
		pub fn cv_DenseOpticalFlow_collectGarbage(instance: *mut c_void) -> Result_void;
		pub fn cv_FarnebackOpticalFlow_getNumLevels_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_FarnebackOpticalFlow_setNumLevels_int(instance: *mut c_void, num_levels: i32) -> Result_void;
		pub fn cv_FarnebackOpticalFlow_getPyrScale_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_FarnebackOpticalFlow_setPyrScale_double(instance: *mut c_void, pyr_scale: f64) -> Result_void;
		pub fn cv_FarnebackOpticalFlow_getFastPyramids_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_FarnebackOpticalFlow_setFastPyramids_bool(instance: *mut c_void, fast_pyramids: bool) -> Result_void;
		pub fn cv_FarnebackOpticalFlow_getWinSize_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_FarnebackOpticalFlow_setWinSize_int(instance: *mut c_void, win_size: i32) -> Result_void;
		pub fn cv_FarnebackOpticalFlow_getNumIters_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_FarnebackOpticalFlow_setNumIters_int(instance: *mut c_void, num_iters: i32) -> Result_void;
		pub fn cv_FarnebackOpticalFlow_getPolyN_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_FarnebackOpticalFlow_setPolyN_int(instance: *mut c_void, poly_n: i32) -> Result_void;
		pub fn cv_FarnebackOpticalFlow_getPolySigma_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_FarnebackOpticalFlow_setPolySigma_double(instance: *mut c_void, poly_sigma: f64) -> Result_void;
		pub fn cv_FarnebackOpticalFlow_getFlags_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_FarnebackOpticalFlow_setFlags_int(instance: *mut c_void, flags: i32) -> Result_void;
		pub fn cv_FarnebackOpticalFlow_create_int_double_bool_int_int_int_double_int(num_levels: i32, pyr_scale: f64, fast_pyramids: bool, win_size: i32, num_iters: i32, poly_n: i32, poly_sigma: f64, flags: i32) -> Result<*mut c_void>;
		pub fn cv_KalmanFilter_statePre(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_KalmanFilter_setStatePre_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_KalmanFilter_statePost(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_KalmanFilter_setStatePost_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_KalmanFilter_transitionMatrix(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_KalmanFilter_setTransitionMatrix_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_KalmanFilter_controlMatrix(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_KalmanFilter_setControlMatrix_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_KalmanFilter_measurementMatrix(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_KalmanFilter_setMeasurementMatrix_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_KalmanFilter_processNoiseCov(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_KalmanFilter_setProcessNoiseCov_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_KalmanFilter_measurementNoiseCov(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_KalmanFilter_setMeasurementNoiseCov_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_KalmanFilter_errorCovPre(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_KalmanFilter_setErrorCovPre_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_KalmanFilter_gain(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_KalmanFilter_setGain_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_KalmanFilter_errorCovPost(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_KalmanFilter_setErrorCovPost_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_KalmanFilter_temp1(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_KalmanFilter_setTemp1_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_KalmanFilter_temp2(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_KalmanFilter_setTemp2_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_KalmanFilter_temp3(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_KalmanFilter_setTemp3_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_KalmanFilter_temp4(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_KalmanFilter_setTemp4_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_KalmanFilter_temp5(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_KalmanFilter_setTemp5_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_KalmanFilter_KalmanFilter() -> Result<*mut c_void>;
		pub fn cv_KalmanFilter_KalmanFilter_int_int_int_int(dynam_params: i32, measure_params: i32, control_params: i32, typ: i32) -> Result<*mut c_void>;
		pub fn cv_KalmanFilter_init_int_int_int_int(instance: *mut c_void, dynam_params: i32, measure_params: i32, control_params: i32, typ: i32) -> Result_void;
		pub fn cv_KalmanFilter_predict_const_MatX(instance: *mut c_void, control: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_KalmanFilter_correct_const_MatX(instance: *mut c_void, measurement: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_SparseOpticalFlow_calc_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputOutputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, prev_img: *mut c_void, next_img: *mut c_void, prev_pts: *mut c_void, next_pts: *mut c_void, status: *mut c_void, err: *mut c_void) -> Result_void;
		pub fn cv_SparsePyrLKOpticalFlow_getWinSize_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_SparsePyrLKOpticalFlow_setWinSize_Size(instance: *mut c_void, win_size: *const core::Size) -> Result_void;
		pub fn cv_SparsePyrLKOpticalFlow_getMaxLevel_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_SparsePyrLKOpticalFlow_setMaxLevel_int(instance: *mut c_void, max_level: i32) -> Result_void;
		pub fn cv_SparsePyrLKOpticalFlow_getTermCriteria_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_SparsePyrLKOpticalFlow_setTermCriteria_TermCriteriaX(instance: *mut c_void, crit: *mut c_void) -> Result_void;
		pub fn cv_SparsePyrLKOpticalFlow_getFlags_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_SparsePyrLKOpticalFlow_setFlags_int(instance: *mut c_void, flags: i32) -> Result_void;
		pub fn cv_SparsePyrLKOpticalFlow_getMinEigThreshold_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_SparsePyrLKOpticalFlow_setMinEigThreshold_double(instance: *mut c_void, min_eig_threshold: f64) -> Result_void;
		pub fn cv_SparsePyrLKOpticalFlow_create_Size_int_TermCriteria_int_double(win_size: *const core::Size, max_level: i32, crit: *mut c_void, flags: i32, min_eig_threshold: f64) -> Result<*mut c_void>;
		pub fn cv_VariationalRefinement_calcUV_const__InputArrayX_const__InputArrayX_const__InputOutputArrayX_const__InputOutputArrayX(instance: *mut c_void, i0: *mut c_void, i1: *mut c_void, flow_u: *mut c_void, flow_v: *mut c_void) -> Result_void;
		pub fn cv_VariationalRefinement_getFixedPointIterations_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_VariationalRefinement_setFixedPointIterations_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_VariationalRefinement_getSorIterations_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_VariationalRefinement_setSorIterations_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_VariationalRefinement_getOmega_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_VariationalRefinement_setOmega_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_VariationalRefinement_getAlpha_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_VariationalRefinement_setAlpha_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_VariationalRefinement_getDelta_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_VariationalRefinement_setDelta_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_VariationalRefinement_getGamma_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_VariationalRefinement_setGamma_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_VariationalRefinement_create() -> Result<*mut c_void>;
	}
}
pub use video_sys::*;

mod videoio_sys {
	use super::*;

	extern "C" {
		pub fn cv_videoio_registry_getBackendName_VideoCaptureAPIs(api: crate::videoio::VideoCaptureAPIs) -> Result<*mut c_void>;
		pub fn cv_videoio_registry_getBackends() -> Result<*mut c_void>;
		pub fn cv_videoio_registry_getCameraBackends() -> Result<*mut c_void>;
		pub fn cv_videoio_registry_getStreamBackends() -> Result<*mut c_void>;
		pub fn cv_videoio_registry_getWriterBackends() -> Result<*mut c_void>;
		pub fn cv_videoio_registry_hasBackend_VideoCaptureAPIs(api: crate::videoio::VideoCaptureAPIs) -> Result<bool>;
		pub fn cv_VideoCapture_VideoCapture() -> Result<*mut c_void>;
		pub fn cv_VideoCapture_VideoCapture_const_StringX_int(filename: *const c_char, api_preference: i32) -> Result<*mut c_void>;
		pub fn cv_VideoCapture_VideoCapture_int_int(index: i32, api_preference: i32) -> Result<*mut c_void>;
		pub fn cv_VideoCapture_open_const_StringX_int(instance: *mut c_void, filename: *const c_char, api_preference: i32) -> Result<bool>;
		pub fn cv_VideoCapture_open_int_int(instance: *mut c_void, index: i32, api_preference: i32) -> Result<bool>;
		pub fn cv_VideoCapture_isOpened_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_VideoCapture_release(instance: *mut c_void) -> Result_void;
		pub fn cv_VideoCapture_grab(instance: *mut c_void) -> Result<bool>;
		pub fn cv_VideoCapture_retrieve_const__OutputArrayX_int(instance: *mut c_void, image: *mut c_void, flag: i32) -> Result<bool>;
		pub fn cv_VideoCapture_read_const__OutputArrayX(instance: *mut c_void, image: *mut c_void) -> Result<bool>;
		pub fn cv_VideoCapture_set_int_double(instance: *mut c_void, prop_id: i32, value: f64) -> Result<bool>;
		pub fn cv_VideoCapture_get_const_int(instance: *mut c_void, prop_id: i32) -> Result<f64>;
		pub fn cv_VideoCapture_getBackendName_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_VideoCapture_setExceptionMode_bool(instance: *mut c_void, enable: bool) -> Result_void;
		pub fn cv_VideoCapture_getExceptionMode(instance: *mut c_void) -> Result<bool>;
		pub fn cv_VideoCapture_waitAny_const_vector_VideoCapture_X_vector_int_X_int64_t(streams: *mut c_void, ready_index: *mut c_void, timeout_ns: i64) -> Result<bool>;
		pub fn cv_VideoWriter_VideoWriter() -> Result<*mut c_void>;
		pub fn cv_VideoWriter_VideoWriter_const_StringX_int_double_Size_bool(filename: *const c_char, fourcc: i32, fps: f64, frame_size: *const core::Size, is_color: bool) -> Result<*mut c_void>;
		pub fn cv_VideoWriter_VideoWriter_const_StringX_int_int_double_Size_bool(filename: *const c_char, api_preference: i32, fourcc: i32, fps: f64, frame_size: *const core::Size, is_color: bool) -> Result<*mut c_void>;
		pub fn cv_VideoWriter_open_const_StringX_int_double_Size_bool(instance: *mut c_void, filename: *const c_char, fourcc: i32, fps: f64, frame_size: *const core::Size, is_color: bool) -> Result<bool>;
		pub fn cv_VideoWriter_open_const_StringX_int_int_double_Size_bool(instance: *mut c_void, filename: *const c_char, api_preference: i32, fourcc: i32, fps: f64, frame_size: *const core::Size, is_color: bool) -> Result<bool>;
		pub fn cv_VideoWriter_isOpened_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_VideoWriter_release(instance: *mut c_void) -> Result_void;
		pub fn cv_VideoWriter_write_const__InputArrayX(instance: *mut c_void, image: *mut c_void) -> Result_void;
		pub fn cv_VideoWriter_set_int_double(instance: *mut c_void, prop_id: i32, value: f64) -> Result<bool>;
		pub fn cv_VideoWriter_get_const_int(instance: *mut c_void, prop_id: i32) -> Result<f64>;
		pub fn cv_VideoWriter_fourcc_char_char_char_char(c1: i8, c2: i8, c3: i8, c4: i8) -> Result<i32>;
		pub fn cv_VideoWriter_getBackendName_const(instance: *mut c_void) -> Result<*mut c_void>;
	}
}
pub use videoio_sys::*;

#[cfg(feature = "contrib")]
mod videostab_sys {
	use super::*;

	extern "C" {
		pub fn cv_videostab_calcBlurriness_const_MatX(frame: *mut c_void) -> Result<f32>;
		pub fn cv_videostab_calcFlowMask_const_MatX_const_MatX_const_MatX_float_const_MatX_const_MatX_MatX(flow_x: *mut c_void, flow_y: *mut c_void, errors: *mut c_void, max_error: f32, mask0: *mut c_void, mask1: *mut c_void, flow_mask: *mut c_void) -> Result_void;
		pub fn cv_videostab_completeFrameAccordingToFlow_const_MatX_const_MatX_const_MatX_const_MatX_const_MatX_float_MatX_MatX(flow_mask: *mut c_void, flow_x: *mut c_void, flow_y: *mut c_void, frame1: *mut c_void, mask1: *mut c_void, dist_thresh: f32, frame0: *mut c_void, mask0: *mut c_void) -> Result_void;
		pub fn cv_videostab_ensureInclusionConstraint_const_MatX_Size_float(m: *mut c_void, size: *const core::Size, trim_ratio: f32) -> Result<*mut c_void>;
		pub fn cv_videostab_estimateGlobalMotionLeastSquares_const__InputOutputArrayX_const__InputOutputArrayX_int_floatX(points0: *mut c_void, points1: *mut c_void, model: i32, rmse: *mut f32) -> Result<*mut c_void>;
		pub fn cv_videostab_estimateGlobalMotionRansac_const__InputArrayX_const__InputArrayX_int_const_RansacParamsX_floatX_intX(points0: *mut c_void, points1: *mut c_void, model: i32, params: *mut c_void, rmse: *mut f32, ninliers: *mut i32) -> Result<*mut c_void>;
		pub fn cv_videostab_estimateOptimalTrimRatio_const_MatX_Size(m: *mut c_void, size: *const core::Size) -> Result<f32>;
		pub fn cv_videostab_getMotion_int_int_const_vector_Mat_X(from: i32, to: i32, motions: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_ColorAverageInpainter_inpaint_int_MatX_MatX(instance: *mut c_void, idx: i32, frame: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_videostab_ColorInpainter_ColorInpainter_int_double(method: i32, radius: f64) -> Result<*mut c_void>;
		pub fn cv_videostab_ColorInpainter_inpaint_int_MatX_MatX(instance: *mut c_void, idx: i32, frame: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_videostab_ConsistentMosaicInpainter_ConsistentMosaicInpainter() -> Result<*mut c_void>;
		pub fn cv_videostab_ConsistentMosaicInpainter_setStdevThresh_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_videostab_ConsistentMosaicInpainter_stdevThresh_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_videostab_ConsistentMosaicInpainter_inpaint_int_MatX_MatX(instance: *mut c_void, idx: i32, frame: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_videostab_DeblurerBase_setRadius_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_videostab_DeblurerBase_radius_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_videostab_DeblurerBase_deblur_int_MatX(instance: *mut c_void, idx: i32, frame: *mut c_void) -> Result_void;
		pub fn cv_videostab_DeblurerBase_setFrames_const_vector_Mat_X(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_DeblurerBase_frames_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_DeblurerBase_setMotions_const_vector_Mat_X(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_DeblurerBase_motions_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_DeblurerBase_setBlurrinessRates_const_vector_float_X(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_DeblurerBase_blurrinessRates_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_FastMarchingMethod_FastMarchingMethod() -> Result<*mut c_void>;
		pub fn cv_videostab_FastMarchingMethod_distanceMap_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_FromFileMotionReader_FromFileMotionReader_const_StringX(path: *const c_char) -> Result<*mut c_void>;
		pub fn cv_videostab_FromFileMotionReader_estimate_const_MatX_const_MatX_boolX(instance: *mut c_void, frame0: *mut c_void, frame1: *mut c_void, ok: *mut bool) -> Result<*mut c_void>;
		pub fn cv_videostab_GaussianMotionFilter_GaussianMotionFilter_int_float(radius: i32, stdev: f32) -> Result<*mut c_void>;
		pub fn cv_videostab_GaussianMotionFilter_setParams_int_float(instance: *mut c_void, radius: i32, stdev: f32) -> Result_void;
		pub fn cv_videostab_GaussianMotionFilter_radius_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_videostab_GaussianMotionFilter_stdev_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_videostab_IDenseOptFlowEstimator_run_const__InputArrayX_const__InputArrayX_const__InputOutputArrayX_const__InputOutputArrayX_const__OutputArrayX(instance: *mut c_void, frame0: *mut c_void, frame1: *mut c_void, flow_x: *mut c_void, flow_y: *mut c_void, errors: *mut c_void) -> Result_void;
		pub fn cv_videostab_IFrameSource_reset(instance: *mut c_void) -> Result_void;
		pub fn cv_videostab_IFrameSource_nextFrame(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_ILog_print_const_charX(instance: *mut c_void, format: *const c_char) -> Result_void;
		pub fn cv_videostab_IOutlierRejector_process_Size_const__InputArrayX_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, frame_size: *const core::Size, points0: *mut c_void, points1: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_videostab_ISparseOptFlowEstimator_run_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputOutputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, frame0: *mut c_void, frame1: *mut c_void, points0: *mut c_void, points1: *mut c_void, status: *mut c_void, errors: *mut c_void) -> Result_void;
		pub fn cv_videostab_ImageMotionEstimatorBase_setMotionModel_MotionModel(instance: *mut c_void, val: crate::videostab::MotionModel) -> Result_void;
		pub fn cv_videostab_ImageMotionEstimatorBase_motionModel_const(instance: *mut c_void) -> Result<crate::videostab::MotionModel>;
		pub fn cv_videostab_ImageMotionEstimatorBase_setFrameMask_const__InputArrayX(instance: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_videostab_ImageMotionEstimatorBase_estimate_const_MatX_const_MatX_boolX(instance: *mut c_void, frame0: *mut c_void, frame1: *mut c_void, ok: *mut bool) -> Result<*mut c_void>;
		pub fn cv_videostab_InpainterBase_setRadius_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_videostab_InpainterBase_radius_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_videostab_InpainterBase_setMotionModel_MotionModel(instance: *mut c_void, val: crate::videostab::MotionModel) -> Result_void;
		pub fn cv_videostab_InpainterBase_motionModel_const(instance: *mut c_void) -> Result<crate::videostab::MotionModel>;
		pub fn cv_videostab_InpainterBase_inpaint_int_MatX_MatX(instance: *mut c_void, idx: i32, frame: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_videostab_InpainterBase_setFrames_const_vector_Mat_X(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_InpainterBase_frames_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_InpainterBase_setMotions_const_vector_Mat_X(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_InpainterBase_motions_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_InpainterBase_setStabilizedFrames_const_vector_Mat_X(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_InpainterBase_stabilizedFrames_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_InpainterBase_setStabilizationMotions_const_vector_Mat_X(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_InpainterBase_stabilizationMotions_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_InpaintingPipeline_pushBack_Ptr_InpainterBase_(instance: *mut c_void, inpainter: *mut c_void) -> Result_void;
		pub fn cv_videostab_InpaintingPipeline_empty_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_videostab_InpaintingPipeline_setRadius_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_videostab_InpaintingPipeline_setMotionModel_MotionModel(instance: *mut c_void, val: crate::videostab::MotionModel) -> Result_void;
		pub fn cv_videostab_InpaintingPipeline_setFrames_const_vector_Mat_X(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_InpaintingPipeline_setMotions_const_vector_Mat_X(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_InpaintingPipeline_setStabilizedFrames_const_vector_Mat_X(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_InpaintingPipeline_setStabilizationMotions_const_vector_Mat_X(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_InpaintingPipeline_inpaint_int_MatX_MatX(instance: *mut c_void, idx: i32, frame: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_videostab_KeypointBasedMotionEstimator_KeypointBasedMotionEstimator_Ptr_MotionEstimatorBase_(estimator: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_KeypointBasedMotionEstimator_setMotionModel_MotionModel(instance: *mut c_void, val: crate::videostab::MotionModel) -> Result_void;
		pub fn cv_videostab_KeypointBasedMotionEstimator_motionModel_const(instance: *mut c_void) -> Result<crate::videostab::MotionModel>;
		pub fn cv_videostab_KeypointBasedMotionEstimator_setDetector_Ptr_FeatureDetector_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_KeypointBasedMotionEstimator_detector_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_KeypointBasedMotionEstimator_setOpticalFlowEstimator_Ptr_ISparseOptFlowEstimator_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_KeypointBasedMotionEstimator_opticalFlowEstimator_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_KeypointBasedMotionEstimator_setOutlierRejector_Ptr_IOutlierRejector_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_KeypointBasedMotionEstimator_outlierRejector_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_KeypointBasedMotionEstimator_setFrameMask_const__InputArrayX(instance: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_videostab_KeypointBasedMotionEstimator_estimate_const_MatX_const_MatX_boolX(instance: *mut c_void, frame0: *mut c_void, frame1: *mut c_void, ok: *mut bool) -> Result<*mut c_void>;
		pub fn cv_videostab_KeypointBasedMotionEstimator_estimate_const__InputArrayX_const__InputArrayX_boolX(instance: *mut c_void, frame0: *mut c_void, frame1: *mut c_void, ok: *mut bool) -> Result<*mut c_void>;
		pub fn cv_videostab_LogToStdout_print_const_charX(instance: *mut c_void, format: *const c_char) -> Result_void;
		pub fn cv_videostab_LpMotionStabilizer_LpMotionStabilizer_MotionModel(model: crate::videostab::MotionModel) -> Result<*mut c_void>;
		pub fn cv_videostab_LpMotionStabilizer_setMotionModel_MotionModel(instance: *mut c_void, val: crate::videostab::MotionModel) -> Result_void;
		pub fn cv_videostab_LpMotionStabilizer_motionModel_const(instance: *mut c_void) -> Result<crate::videostab::MotionModel>;
		pub fn cv_videostab_LpMotionStabilizer_setFrameSize_Size(instance: *mut c_void, val: *const core::Size) -> Result_void;
		pub fn cv_videostab_LpMotionStabilizer_frameSize_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_videostab_LpMotionStabilizer_setTrimRatio_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_videostab_LpMotionStabilizer_trimRatio_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_videostab_LpMotionStabilizer_setWeight1_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_videostab_LpMotionStabilizer_weight1_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_videostab_LpMotionStabilizer_setWeight2_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_videostab_LpMotionStabilizer_weight2_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_videostab_LpMotionStabilizer_setWeight3_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_videostab_LpMotionStabilizer_weight3_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_videostab_LpMotionStabilizer_setWeight4_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_videostab_LpMotionStabilizer_weight4_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_videostab_MoreAccurateMotionWobbleSuppressor_suppress_int_const_MatX_MatX(instance: *mut c_void, idx: i32, frame: *mut c_void, result: *mut c_void) -> Result_void;
		pub fn cv_videostab_MoreAccurateMotionWobbleSuppressorBase_setPeriod_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_videostab_MoreAccurateMotionWobbleSuppressorBase_period_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_videostab_MotionEstimatorBase_setMotionModel_MotionModel(instance: *mut c_void, val: crate::videostab::MotionModel) -> Result_void;
		pub fn cv_videostab_MotionEstimatorBase_motionModel_const(instance: *mut c_void) -> Result<crate::videostab::MotionModel>;
		pub fn cv_videostab_MotionEstimatorBase_estimate_const__InputArrayX_const__InputArrayX_boolX(instance: *mut c_void, points0: *mut c_void, points1: *mut c_void, ok: *mut bool) -> Result<*mut c_void>;
		pub fn cv_videostab_MotionEstimatorL1_MotionEstimatorL1_MotionModel(model: crate::videostab::MotionModel) -> Result<*mut c_void>;
		pub fn cv_videostab_MotionEstimatorL1_estimate_const__InputArrayX_const__InputArrayX_boolX(instance: *mut c_void, points0: *mut c_void, points1: *mut c_void, ok: *mut bool) -> Result<*mut c_void>;
		pub fn cv_videostab_MotionEstimatorRansacL2_MotionEstimatorRansacL2_MotionModel(model: crate::videostab::MotionModel) -> Result<*mut c_void>;
		pub fn cv_videostab_MotionEstimatorRansacL2_setRansacParams_const_RansacParamsX(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_MotionEstimatorRansacL2_ransacParams_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_MotionEstimatorRansacL2_setMinInlierRatio_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_videostab_MotionEstimatorRansacL2_minInlierRatio_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_videostab_MotionEstimatorRansacL2_estimate_const__InputArrayX_const__InputArrayX_boolX(instance: *mut c_void, points0: *mut c_void, points1: *mut c_void, ok: *mut bool) -> Result<*mut c_void>;
		pub fn cv_videostab_MotionInpainter_MotionInpainter() -> Result<*mut c_void>;
		pub fn cv_videostab_MotionInpainter_setOptFlowEstimator_Ptr_IDenseOptFlowEstimator_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_MotionInpainter_optFlowEstimator_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_MotionInpainter_setFlowErrorThreshold_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_videostab_MotionInpainter_flowErrorThreshold_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_videostab_MotionInpainter_setDistThreshold_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_videostab_MotionInpainter_distThresh_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_videostab_MotionInpainter_setBorderMode_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_videostab_MotionInpainter_borderMode_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_videostab_MotionInpainter_inpaint_int_MatX_MatX(instance: *mut c_void, idx: i32, frame: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_videostab_MotionStabilizationPipeline_pushBack_Ptr_IMotionStabilizer_(instance: *mut c_void, stabilizer: *mut c_void) -> Result_void;
		pub fn cv_videostab_MotionStabilizationPipeline_empty_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_videostab_NullDeblurer_deblur_int_MatX(instance: *mut c_void, unnamed: i32, unnamed: *mut c_void) -> Result_void;
		pub fn cv_videostab_NullFrameSource_reset(instance: *mut c_void) -> Result_void;
		pub fn cv_videostab_NullFrameSource_nextFrame(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_NullInpainter_inpaint_int_MatX_MatX(instance: *mut c_void, unnamed: i32, unnamed: *mut c_void, unnamed: *mut c_void) -> Result_void;
		pub fn cv_videostab_NullLog_print_const_charX(instance: *mut c_void, unnamed: *const c_char) -> Result_void;
		pub fn cv_videostab_NullOutlierRejector_process_Size_const__InputArrayX_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, frame_size: *const core::Size, points0: *mut c_void, points1: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_videostab_NullWobbleSuppressor_suppress_int_const_MatX_MatX(instance: *mut c_void, idx: i32, frame: *mut c_void, result: *mut c_void) -> Result_void;
		pub fn cv_videostab_OnePassStabilizer_OnePassStabilizer() -> Result<*mut c_void>;
		pub fn cv_videostab_OnePassStabilizer_setMotionFilter_Ptr_MotionFilterBase_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_OnePassStabilizer_motionFilter_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_OnePassStabilizer_reset(instance: *mut c_void) -> Result_void;
		pub fn cv_videostab_OnePassStabilizer_nextFrame(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_PyrLkOptFlowEstimatorBase_PyrLkOptFlowEstimatorBase() -> Result<*mut c_void>;
		pub fn cv_videostab_PyrLkOptFlowEstimatorBase_setWinSize_Size(instance: *mut c_void, val: *const core::Size) -> Result_void;
		pub fn cv_videostab_PyrLkOptFlowEstimatorBase_winSize_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_videostab_PyrLkOptFlowEstimatorBase_setMaxLevel_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_videostab_PyrLkOptFlowEstimatorBase_maxLevel_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_videostab_RansacParams_size_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_videostab_RansacParams_setSize_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_videostab_RansacParams_thresh_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_videostab_RansacParams_setThresh_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_videostab_RansacParams_eps_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_videostab_RansacParams_setEps_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_videostab_RansacParams_prob_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_videostab_RansacParams_setProb_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_videostab_RansacParams_RansacParams() -> Result<*mut c_void>;
		pub fn cv_videostab_RansacParams_RansacParams_int_float_float_float(size: i32, thresh: f32, eps: f32, prob: f32) -> Result<*mut c_void>;
		pub fn cv_videostab_RansacParams_niters_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_videostab_RansacParams_default2dMotion_MotionModel(model: crate::videostab::MotionModel) -> Result<*mut c_void>;
		pub fn cv_videostab_SparsePyrLkOptFlowEstimator_run_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputOutputArrayX_const__OutputArrayX_const__OutputArrayX(instance: *mut c_void, frame0: *mut c_void, frame1: *mut c_void, points0: *mut c_void, points1: *mut c_void, status: *mut c_void, errors: *mut c_void) -> Result_void;
		pub fn cv_videostab_StabilizerBase_setLog_Ptr_ILog_(instance: *mut c_void, ilog: *mut c_void) -> Result_void;
		pub fn cv_videostab_StabilizerBase_log_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_StabilizerBase_setRadius_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_videostab_StabilizerBase_radius_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_videostab_StabilizerBase_setFrameSource_Ptr_IFrameSource_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_StabilizerBase_frameSource_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_StabilizerBase_setMaskSource_const_Ptr_IFrameSource_X(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_StabilizerBase_maskSource_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_StabilizerBase_setMotionEstimator_Ptr_ImageMotionEstimatorBase_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_StabilizerBase_motionEstimator_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_StabilizerBase_setDeblurer_Ptr_DeblurerBase_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_StabilizerBase_deblurrer_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_StabilizerBase_setTrimRatio_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_videostab_StabilizerBase_trimRatio_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_videostab_StabilizerBase_setCorrectionForInclusion_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_videostab_StabilizerBase_doCorrectionForInclusion_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_videostab_StabilizerBase_setBorderMode_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_videostab_StabilizerBase_borderMode_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_videostab_StabilizerBase_setInpainter_Ptr_InpainterBase_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_StabilizerBase_inpainter_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_ToFileMotionWriter_ToFileMotionWriter_const_StringX_Ptr_ImageMotionEstimatorBase_(path: *const c_char, estimator: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_ToFileMotionWriter_setMotionModel_MotionModel(instance: *mut c_void, val: crate::videostab::MotionModel) -> Result_void;
		pub fn cv_videostab_ToFileMotionWriter_motionModel_const(instance: *mut c_void) -> Result<crate::videostab::MotionModel>;
		pub fn cv_videostab_ToFileMotionWriter_setFrameMask_const__InputArrayX(instance: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_videostab_ToFileMotionWriter_estimate_const_MatX_const_MatX_boolX(instance: *mut c_void, frame0: *mut c_void, frame1: *mut c_void, ok: *mut bool) -> Result<*mut c_void>;
		pub fn cv_videostab_TranslationBasedLocalOutlierRejector_TranslationBasedLocalOutlierRejector() -> Result<*mut c_void>;
		pub fn cv_videostab_TranslationBasedLocalOutlierRejector_setCellSize_Size(instance: *mut c_void, val: *const core::Size) -> Result_void;
		pub fn cv_videostab_TranslationBasedLocalOutlierRejector_cellSize_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_videostab_TranslationBasedLocalOutlierRejector_setRansacParams_RansacParams(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_TranslationBasedLocalOutlierRejector_ransacParams_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_TranslationBasedLocalOutlierRejector_process_Size_const__InputArrayX_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, frame_size: *const core::Size, points0: *mut c_void, points1: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_videostab_TwoPassStabilizer_TwoPassStabilizer() -> Result<*mut c_void>;
		pub fn cv_videostab_TwoPassStabilizer_setMotionStabilizer_Ptr_IMotionStabilizer_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_TwoPassStabilizer_motionStabilizer_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_TwoPassStabilizer_setWobbleSuppressor_Ptr_WobbleSuppressorBase_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_TwoPassStabilizer_wobbleSuppressor_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_TwoPassStabilizer_setEstimateTrimRatio_bool(instance: *mut c_void, val: bool) -> Result_void;
		pub fn cv_videostab_TwoPassStabilizer_mustEstimateTrimaRatio_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_videostab_TwoPassStabilizer_reset(instance: *mut c_void) -> Result_void;
		pub fn cv_videostab_TwoPassStabilizer_nextFrame(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_VideoFileSource_VideoFileSource_const_StringX_bool(path: *const c_char, volatile_frame: bool) -> Result<*mut c_void>;
		pub fn cv_videostab_VideoFileSource_reset(instance: *mut c_void) -> Result_void;
		pub fn cv_videostab_VideoFileSource_nextFrame(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_VideoFileSource_width(instance: *mut c_void) -> Result<i32>;
		pub fn cv_videostab_VideoFileSource_height(instance: *mut c_void) -> Result<i32>;
		pub fn cv_videostab_VideoFileSource_count(instance: *mut c_void) -> Result<i32>;
		pub fn cv_videostab_VideoFileSource_fps(instance: *mut c_void) -> Result<f64>;
		pub fn cv_videostab_WeightingDeblurer_WeightingDeblurer() -> Result<*mut c_void>;
		pub fn cv_videostab_WeightingDeblurer_setSensitivity_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_videostab_WeightingDeblurer_sensitivity_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_videostab_WeightingDeblurer_deblur_int_MatX(instance: *mut c_void, idx: i32, frame: *mut c_void) -> Result_void;
		pub fn cv_videostab_WobbleSuppressorBase_setMotionEstimator_Ptr_ImageMotionEstimatorBase_(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_WobbleSuppressorBase_motionEstimator_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_WobbleSuppressorBase_suppress_int_const_MatX_MatX(instance: *mut c_void, idx: i32, frame: *mut c_void, result: *mut c_void) -> Result_void;
		pub fn cv_videostab_WobbleSuppressorBase_setFrameCount_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_videostab_WobbleSuppressorBase_frameCount_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_videostab_WobbleSuppressorBase_setMotions_const_vector_Mat_X(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_WobbleSuppressorBase_motions_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_WobbleSuppressorBase_setMotions2_const_vector_Mat_X(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_WobbleSuppressorBase_motions2_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_videostab_WobbleSuppressorBase_setStabilizationMotions_const_vector_Mat_X(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_videostab_WobbleSuppressorBase_stabilizationMotions_const(instance: *mut c_void) -> Result<*mut c_void>;
	}
}
#[cfg(feature = "contrib")]
pub use videostab_sys::*;

mod viz_sys {
	use super::*;

	extern "C" {
		pub fn cv_viz_computeNormals_const_MeshX_const__OutputArrayX(mesh: *mut c_void, normals: *mut c_void) -> Result_void;
		pub fn cv_viz_getWindowByName_const_StringX(window_name: *const c_char) -> Result<*mut c_void>;
		pub fn cv_viz_imshow_const_StringX_const__InputArrayX_const_SizeX(window_name: *const c_char, image: *mut c_void, window_size: *const core::Size) -> Result<*mut c_void>;
		pub fn cv_viz_readCloud_const_StringX_const__OutputArrayX_const__OutputArrayX(file: *const c_char, colors: *mut c_void, normals: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_readMesh_const_StringX(file: *const c_char) -> Result<*mut c_void>;
		pub fn cv_viz_readTrajectory_const__OutputArrayX_const_StringX_int_int_const_StringX(traj: *mut c_void, files_format: *const c_char, start: i32, end: i32, tag: *const c_char) -> Result_void;
		pub fn cv_viz_unregisterAllWindows() -> Result_void;
		pub fn cv_viz_writeCloud_const_StringX_const__InputArrayX_const__InputArrayX_const__InputArrayX_bool(file: *const c_char, cloud: *mut c_void, colors: *mut c_void, normals: *mut c_void, binary: bool) -> Result_void;
		pub fn cv_viz_writeTrajectory_const__InputArrayX_const_StringX_int_const_StringX(traj: *mut c_void, files_format: *const c_char, start: i32, tag: *const c_char) -> Result_void;
		pub fn cv_viz_Camera_Camera_double_double_double_double_const_SizeX(fx: f64, fy: f64, cx: f64, cy: f64, window_size: *const core::Size) -> Result<*mut c_void>;
		pub fn cv_viz_Camera_Camera_const_Vec2dX_const_SizeX(fov: *const core::Vec2d, window_size: *const core::Size) -> Result<*mut c_void>;
		pub fn cv_viz_Camera_getClip_const(instance: *mut c_void) -> Result<core::Vec2d>;
		pub fn cv_viz_Camera_setClip_const_Vec2dX(instance: *mut c_void, clip: *const core::Vec2d) -> Result_void;
		pub fn cv_viz_Camera_getWindowSize_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_viz_Camera_setWindowSize_const_SizeX(instance: *mut c_void, window_size: *const core::Size) -> Result_void;
		pub fn cv_viz_Camera_getFov_const(instance: *mut c_void) -> Result<core::Vec2d>;
		pub fn cv_viz_Camera_setFov_const_Vec2dX(instance: *mut c_void, fov: *const core::Vec2d) -> Result_void;
		pub fn cv_viz_Camera_getPrincipalPoint_const(instance: *mut c_void) -> Result<core::Vec2d>;
		pub fn cv_viz_Camera_getFocalLength_const(instance: *mut c_void) -> Result<core::Vec2d>;
		pub fn cv_viz_Camera_KinectCamera_const_SizeX(window_size: *const core::Size) -> Result<*mut c_void>;
		pub fn cv_viz_Color_Color() -> Result<*mut c_void>;
		pub fn cv_viz_Color_Color_double(gray: f64) -> Result<*mut c_void>;
		pub fn cv_viz_Color_Color_double_double_double(blue: f64, green: f64, red: f64) -> Result<*mut c_void>;
		pub fn cv_viz_Color_Color_const_ScalarX(color: *const core::Scalar) -> Result<*mut c_void>;
		pub fn cv_viz_Color_operator_cv_Vec3b_const(instance: *mut c_void) -> Result<core::Vec3b>;
		pub fn cv_viz_Color_black() -> Result<*mut c_void>;
		pub fn cv_viz_Color_blue() -> Result<*mut c_void>;
		pub fn cv_viz_Color_green() -> Result<*mut c_void>;
		pub fn cv_viz_Color_red() -> Result<*mut c_void>;
		pub fn cv_viz_Color_cyan() -> Result<*mut c_void>;
		pub fn cv_viz_Color_yellow() -> Result<*mut c_void>;
		pub fn cv_viz_Color_magenta() -> Result<*mut c_void>;
		pub fn cv_viz_Color_white() -> Result<*mut c_void>;
		pub fn cv_viz_Color_gray() -> Result<*mut c_void>;
		pub fn cv_viz_Color_silver() -> Result<*mut c_void>;
		pub fn cv_viz_Color_mlab() -> Result<*mut c_void>;
		pub fn cv_viz_Color_navy() -> Result<*mut c_void>;
		pub fn cv_viz_Color_maroon() -> Result<*mut c_void>;
		pub fn cv_viz_Color_teal() -> Result<*mut c_void>;
		pub fn cv_viz_Color_olive() -> Result<*mut c_void>;
		pub fn cv_viz_Color_purple() -> Result<*mut c_void>;
		pub fn cv_viz_Color_azure() -> Result<*mut c_void>;
		pub fn cv_viz_Color_chartreuse() -> Result<*mut c_void>;
		pub fn cv_viz_Color_rose() -> Result<*mut c_void>;
		pub fn cv_viz_Color_lime() -> Result<*mut c_void>;
		pub fn cv_viz_Color_gold() -> Result<*mut c_void>;
		pub fn cv_viz_Color_orange() -> Result<*mut c_void>;
		pub fn cv_viz_Color_orange_red() -> Result<*mut c_void>;
		pub fn cv_viz_Color_indigo() -> Result<*mut c_void>;
		pub fn cv_viz_Color_brown() -> Result<*mut c_void>;
		pub fn cv_viz_Color_apricot() -> Result<*mut c_void>;
		pub fn cv_viz_Color_pink() -> Result<*mut c_void>;
		pub fn cv_viz_Color_raspberry() -> Result<*mut c_void>;
		pub fn cv_viz_Color_cherry() -> Result<*mut c_void>;
		pub fn cv_viz_Color_violet() -> Result<*mut c_void>;
		pub fn cv_viz_Color_amethyst() -> Result<*mut c_void>;
		pub fn cv_viz_Color_bluberry() -> Result<*mut c_void>;
		pub fn cv_viz_Color_celestial_blue() -> Result<*mut c_void>;
		pub fn cv_viz_Color_turquoise() -> Result<*mut c_void>;
		pub fn cv_viz_Color_not_set() -> Result<*mut c_void>;
		pub fn cv_viz_KeyboardEvent_action_const(instance: *mut c_void) -> Result<crate::viz::KeyboardEvent_Action>;
		pub fn cv_viz_KeyboardEvent_setAction_Action(instance: *mut c_void, val: crate::viz::KeyboardEvent_Action) -> Result_void;
		pub fn cv_viz_KeyboardEvent_symbol_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_KeyboardEvent_setSymbol_String(instance: *mut c_void, val: *mut c_char) -> Result_void;
		pub fn cv_viz_KeyboardEvent_code_const(instance: *mut c_void) -> Result<u8>;
		pub fn cv_viz_KeyboardEvent_setCode_unsigned_char(instance: *mut c_void, val: u8) -> Result_void;
		pub fn cv_viz_KeyboardEvent_modifiers_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_viz_KeyboardEvent_setModifiers_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_viz_KeyboardEvent_KeyboardEvent_Action_const_StringX_unsigned_char_int(action: crate::viz::KeyboardEvent_Action, symbol: *const c_char, code: u8, modifiers: i32) -> Result<*mut c_void>;
		pub fn cv_viz_Mesh_cloud(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_Mesh_setCloud_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_viz_Mesh_colors(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_Mesh_setColors_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_viz_Mesh_normals(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_Mesh_setNormals_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_viz_Mesh_polygons(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_Mesh_setPolygons_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_viz_Mesh_texture(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_Mesh_setTexture_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_viz_Mesh_tcoords(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_Mesh_setTcoords_Mat(instance: *mut c_void, val: *mut c_void) -> Result_void;
		pub fn cv_viz_Mesh_load_const_StringX_int(file: *const c_char, typ: i32) -> Result<*mut c_void>;
		pub fn cv_viz_MouseEvent_type_const(instance: *mut c_void) -> Result<crate::viz::MouseEvent_Type>;
		pub fn cv_viz_MouseEvent_setType_Type(instance: *mut c_void, val: crate::viz::MouseEvent_Type) -> Result_void;
		pub fn cv_viz_MouseEvent_button_const(instance: *mut c_void) -> Result<crate::viz::MouseEvent_MouseButton>;
		pub fn cv_viz_MouseEvent_setButton_MouseButton(instance: *mut c_void, val: crate::viz::MouseEvent_MouseButton) -> Result_void;
		pub fn cv_viz_MouseEvent_pointer_const(instance: *mut c_void) -> Result<core::Point>;
		pub fn cv_viz_MouseEvent_setPointer_Point(instance: *mut c_void, val: *const core::Point) -> Result_void;
		pub fn cv_viz_MouseEvent_modifiers_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_viz_MouseEvent_setModifiers_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_viz_MouseEvent_MouseEvent_const_TypeX_const_MouseButtonX_const_PointX_int(typ: *const crate::viz::MouseEvent_Type, button: *const crate::viz::MouseEvent_MouseButton, pointer: *const core::Point, modifiers: i32) -> Result<*mut c_void>;
		pub fn cv_viz_Viz3d_Viz3d_const_StringX(window_name: *const c_char) -> Result<*mut c_void>;
		pub fn cv_viz_Viz3d_Viz3d_const_Viz3dX(unnamed: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_Viz3d_removeWidget_const_StringX(instance: *mut c_void, id: *const c_char) -> Result_void;
		pub fn cv_viz_Viz3d_getWidget_const_const_StringX(instance: *mut c_void, id: *const c_char) -> Result<*mut c_void>;
		pub fn cv_viz_Viz3d_removeAllWidgets(instance: *mut c_void) -> Result_void;
		pub fn cv_viz_Viz3d_showImage_const__InputArrayX_const_SizeX(instance: *mut c_void, image: *mut c_void, window_size: *const core::Size) -> Result_void;
		pub fn cv_viz_Viz3d_setCamera_const_CameraX(instance: *mut c_void, camera: *mut c_void) -> Result_void;
		pub fn cv_viz_Viz3d_getCamera_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_Viz3d_resetCameraViewpoint_const_StringX(instance: *mut c_void, id: *const c_char) -> Result_void;
		pub fn cv_viz_Viz3d_resetCamera(instance: *mut c_void) -> Result_void;
		pub fn cv_viz_Viz3d_convertToWindowCoordinates_const_Point3dX_Point3dX(instance: *mut c_void, pt: *const core::Point3d, window_coord: *mut core::Point3d) -> Result_void;
		pub fn cv_viz_Viz3d_converTo3DRay_const_Point3dX_Point3dX_Vec3dX(instance: *mut c_void, window_coord: *const core::Point3d, origin: *mut core::Point3d, direction: *mut core::Vec3d) -> Result_void;
		pub fn cv_viz_Viz3d_getWindowSize_const(instance: *mut c_void) -> Result<core::Size>;
		pub fn cv_viz_Viz3d_setWindowSize_const_SizeX(instance: *mut c_void, window_size: *const core::Size) -> Result_void;
		pub fn cv_viz_Viz3d_getWindowName_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_Viz3d_getScreenshot_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_Viz3d_saveScreenshot_const_StringX(instance: *mut c_void, file: *const c_char) -> Result_void;
		pub fn cv_viz_Viz3d_setWindowPosition_const_PointX(instance: *mut c_void, window_position: *const core::Point) -> Result_void;
		pub fn cv_viz_Viz3d_setFullScreen_bool(instance: *mut c_void, mode: bool) -> Result_void;
		pub fn cv_viz_Viz3d_setBackgroundColor_const_ColorX_const_ColorX(instance: *mut c_void, color: *mut c_void, color2: *mut c_void) -> Result_void;
		pub fn cv_viz_Viz3d_setBackgroundTexture_const__InputArrayX(instance: *mut c_void, image: *mut c_void) -> Result_void;
		pub fn cv_viz_Viz3d_setBackgroundMeshLab(instance: *mut c_void) -> Result_void;
		pub fn cv_viz_Viz3d_spin(instance: *mut c_void) -> Result_void;
		pub fn cv_viz_Viz3d_spinOnce_int_bool(instance: *mut c_void, time: i32, force_redraw: bool) -> Result_void;
		pub fn cv_viz_Viz3d_setOffScreenRendering(instance: *mut c_void) -> Result_void;
		pub fn cv_viz_Viz3d_removeAllLights(instance: *mut c_void) -> Result_void;
		pub fn cv_viz_Viz3d_addLight_const_Vec3dX_const_Vec3dX_const_ColorX_const_ColorX_const_ColorX_const_ColorX(instance: *mut c_void, position: *const core::Vec3d, focal_point: *const core::Vec3d, color: *mut c_void, diffuse_color: *mut c_void, ambient_color: *mut c_void, specular_color: *mut c_void) -> Result_void;
		pub fn cv_viz_Viz3d_wasStopped_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_viz_Viz3d_close(instance: *mut c_void) -> Result_void;
		pub fn cv_viz_Viz3d_registerKeyboardCallback_KeyboardCallback_voidX(instance: *mut c_void, callback: Option<extern "C" fn(*mut c_void, *mut c_void) -> ()>, cookie: *mut c_void) -> Result_void;
		pub fn cv_viz_Viz3d_registerMouseCallback_MouseCallback_voidX(instance: *mut c_void, callback: Option<extern "C" fn(*mut c_void, *mut c_void) -> ()>, cookie: *mut c_void) -> Result_void;
		pub fn cv_viz_Viz3d_setRenderingProperty_const_StringX_int_double(instance: *mut c_void, id: *const c_char, property: i32, value: f64) -> Result_void;
		pub fn cv_viz_Viz3d_getRenderingProperty_const_StringX_int(instance: *mut c_void, id: *const c_char, property: i32) -> Result<f64>;
		pub fn cv_viz_Viz3d_setRepresentation_int(instance: *mut c_void, representation: i32) -> Result_void;
		pub fn cv_viz_Viz3d_setGlobalWarnings_bool(instance: *mut c_void, enabled: bool) -> Result_void;
		pub fn cv_viz_WArrow_WArrow_const_Point3dX_const_Point3dX_double_const_ColorX(pt1: *const core::Point3d, pt2: *const core::Point3d, thickness: f64, color: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WCameraPosition_WCameraPosition_double(scale: f64) -> Result<*mut c_void>;
		pub fn cv_viz_WCameraPosition_WCameraPosition_const_Vec2dX_double_const_ColorX(fov: *const core::Vec2d, scale: f64, color: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WCameraPosition_WCameraPosition_const_Vec2dX_const__InputArrayX_double_const_ColorX(fov: *const core::Vec2d, image: *mut c_void, scale: f64, color: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WCircle_WCircle_double_double_const_ColorX(radius: f64, thickness: f64, color: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WCircle_WCircle_double_const_Point3dX_const_Vec3dX_double_const_ColorX(radius: f64, center: *const core::Point3d, normal: *const core::Vec3d, thickness: f64, color: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WCloud_WCloud_const__InputArrayX_const__InputArrayX(cloud: *mut c_void, colors: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WCloud_WCloud_const__InputArrayX_const_ColorX(cloud: *mut c_void, color: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WCloud_WCloud_const__InputArrayX_const__InputArrayX_const__InputArrayX(cloud: *mut c_void, colors: *mut c_void, normals: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WCloud_WCloud_const__InputArrayX_const_ColorX_const__InputArrayX(cloud: *mut c_void, color: *mut c_void, normals: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WCloudCollection_WCloudCollection() -> Result<*mut c_void>;
		pub fn cv_viz_WCloudCollection_finalize(instance: *mut c_void) -> Result_void;
		pub fn cv_viz_WCloudNormals_WCloudNormals_const__InputArrayX_const__InputArrayX_int_double_const_ColorX(cloud: *mut c_void, normals: *mut c_void, level: i32, scale: f64, color: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WCone_WCone_double_double_int_const_ColorX(length: f64, radius: f64, resolution: i32, color: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WCone_WCone_double_const_Point3dX_const_Point3dX_int_const_ColorX(radius: f64, center: *const core::Point3d, tip: *const core::Point3d, resolution: i32, color: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WCoordinateSystem_WCoordinateSystem_double(scale: f64) -> Result<*mut c_void>;
		pub fn cv_viz_WCube_WCube_const_Point3dX_const_Point3dX_bool_const_ColorX(min_point: *const core::Point3d, max_point: *const core::Point3d, wire_frame: bool, color: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WCylinder_WCylinder_const_Point3dX_const_Point3dX_double_int_const_ColorX(axis_point1: *const core::Point3d, axis_point2: *const core::Point3d, radius: f64, numsides: i32, color: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WGrid_WGrid_const_Vec2iX_const_Vec2dX_const_ColorX(cells: *const core::Vec2i, cells_spacing: *const core::Vec2d, color: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WGrid_WGrid_const_Point3dX_const_Vec3dX_const_Vec3dX_const_Vec2iX_const_Vec2dX_const_ColorX(center: *const core::Point3d, normal: *const core::Vec3d, new_yaxis: *const core::Vec3d, cells: *const core::Vec2i, cells_spacing: *const core::Vec2d, color: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WImage3D_WImage3D_const__InputArrayX_const_Size2dX(image: *mut c_void, size: *const core::Size2d) -> Result<*mut c_void>;
		pub fn cv_viz_WImage3D_WImage3D_const__InputArrayX_const_Size2dX_const_Vec3dX_const_Vec3dX_const_Vec3dX(image: *mut c_void, size: *const core::Size2d, center: *const core::Vec3d, normal: *const core::Vec3d, up_vector: *const core::Vec3d) -> Result<*mut c_void>;
		pub fn cv_viz_WImage3D_setImage_const__InputArrayX(instance: *mut c_void, image: *mut c_void) -> Result_void;
		pub fn cv_viz_WImage3D_setSize_const_SizeX(instance: *mut c_void, size: *const core::Size) -> Result_void;
		pub fn cv_viz_WImageOverlay_WImageOverlay_const__InputArrayX_const_RectX(image: *mut c_void, rect: *const core::Rect) -> Result<*mut c_void>;
		pub fn cv_viz_WImageOverlay_setImage_const__InputArrayX(instance: *mut c_void, image: *mut c_void) -> Result_void;
		pub fn cv_viz_WLine_WLine_const_Point3dX_const_Point3dX_const_ColorX(pt1: *const core::Point3d, pt2: *const core::Point3d, color: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WMesh_WMesh_const_MeshX(mesh: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WMesh_WMesh_const__InputArrayX_const__InputArrayX_const__InputArrayX_const__InputArrayX(cloud: *mut c_void, polygons: *mut c_void, colors: *mut c_void, normals: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WPaintedCloud_WPaintedCloud_const__InputArrayX(cloud: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WPaintedCloud_WPaintedCloud_const__InputArrayX_const_Point3dX_const_Point3dX(cloud: *mut c_void, p1: *const core::Point3d, p2: *const core::Point3d) -> Result<*mut c_void>;
		pub fn cv_viz_WPaintedCloud_WPaintedCloud_const__InputArrayX_const_Point3dX_const_Point3dX_const_ColorX_Color(cloud: *mut c_void, p1: *const core::Point3d, p2: *const core::Point3d, c1: *mut c_void, c2: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WPlane_WPlane_const_Size2dX_const_ColorX(size: *const core::Size2d, color: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WPlane_WPlane_const_Point3dX_const_Vec3dX_const_Vec3dX_const_Size2dX_const_ColorX(center: *const core::Point3d, normal: *const core::Vec3d, new_yaxis: *const core::Vec3d, size: *const core::Size2d, color: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WPolyLine_WPolyLine_const__InputArrayX_const__InputArrayX(points: *mut c_void, colors: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WPolyLine_WPolyLine_const__InputArrayX_const_ColorX(points: *mut c_void, color: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WSphere_WSphere_const_Point3dX_double_int_const_ColorX(center: *const core::Point3d, radius: f64, sphere_resolution: i32, color: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WText_WText_const_StringX_const_PointX_int_const_ColorX(text: *const c_char, pos: *const core::Point, font_size: i32, color: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WText_setText_const_StringX(instance: *mut c_void, text: *const c_char) -> Result_void;
		pub fn cv_viz_WText_getText_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WText3D_WText3D_const_StringX_const_Point3dX_double_bool_const_ColorX(text: *const c_char, position: *const core::Point3d, text_scale: f64, face_camera: bool, color: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WText3D_setText_const_StringX(instance: *mut c_void, text: *const c_char) -> Result_void;
		pub fn cv_viz_WText3D_getText_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WTrajectory_WTrajectory_const__InputArrayX_int_double_const_ColorX(path: *mut c_void, display_mode: i32, scale: f64, color: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WTrajectoryFrustums_WTrajectoryFrustums_const__InputArrayX_const_Vec2dX_double_const_ColorX(path: *mut c_void, fov: *const core::Vec2d, scale: f64, color: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WTrajectorySpheres_WTrajectorySpheres_const__InputArrayX_double_double_const_ColorX_const_ColorX(path: *mut c_void, line_length: f64, radius: f64, from: *mut c_void, to: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_WWidgetMerger_WWidgetMerger() -> Result<*mut c_void>;
		pub fn cv_viz_WWidgetMerger_finalize(instance: *mut c_void) -> Result_void;
		pub fn cv_viz_Widget_Widget() -> Result<*mut c_void>;
		pub fn cv_viz_Widget_Widget_const_WidgetX(other: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_viz_Widget_fromPlyFile_const_StringX(file_name: *const c_char) -> Result<*mut c_void>;
		pub fn cv_viz_Widget_setRenderingProperty_int_double(instance: *mut c_void, property: i32, value: f64) -> Result_void;
		pub fn cv_viz_Widget_getRenderingProperty_const_int(instance: *mut c_void, property: i32) -> Result<f64>;
		pub fn cv_viz_Widget2D_Widget2D() -> Result<*mut c_void>;
		pub fn cv_viz_Widget2D_setColor_const_ColorX(instance: *mut c_void, color: *mut c_void) -> Result_void;
		pub fn cv_viz_Widget3D_Widget3D() -> Result<*mut c_void>;
		pub fn cv_viz_Widget3D_setColor_const_ColorX(instance: *mut c_void, color: *mut c_void) -> Result_void;
	}
}
pub use viz_sys::*;

#[cfg(feature = "contrib")]
mod xfeatures2d_sys {
	use super::*;

	extern "C" {
		pub fn cv_xfeatures2d_FASTForPointSet_const__InputArrayX_vector_KeyPoint_X_int_bool_DetectorType(image: *mut c_void, keypoints: *mut c_void, threshold: i32, nonmax_suppression: bool, typ: crate::features2d::FastFeatureDetector_DetectorType) -> Result_void;
		pub fn cv_xfeatures2d_matchGMS_const_SizeX_const_SizeX_const_vector_KeyPoint_X_const_vector_KeyPoint_X_const_vector_DMatch_X_vector_DMatch_X_bool_bool_double(size1: *const core::Size, size2: *const core::Size, keypoints1: *mut c_void, keypoints2: *mut c_void, matches1to2: *mut c_void, matches_gms: *mut c_void, with_rotation: bool, with_scale: bool, threshold_factor: f64) -> Result_void;
		pub fn cv_xfeatures2d_matchLOGOS_const_vector_KeyPoint_X_const_vector_KeyPoint_X_const_vector_int_X_const_vector_int_X_vector_DMatch_X(keypoints1: *mut c_void, keypoints2: *mut c_void, nn1: *mut c_void, nn2: *mut c_void, matches1to2: *mut c_void) -> Result_void;
		pub fn cv_xfeatures2d_AffineFeature2D_create_Ptr_FeatureDetector__Ptr_DescriptorExtractor_(keypoint_detector: *mut c_void, descriptor_extractor: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_xfeatures2d_AffineFeature2D_create_Ptr_FeatureDetector_(keypoint_detector: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_xfeatures2d_AffineFeature2D_detect_const__InputArrayX_vector_Elliptic_KeyPoint_X_const__InputArrayX(instance: *mut c_void, image: *mut c_void, keypoints: *mut c_void, mask: *mut c_void) -> Result_void;
		pub fn cv_xfeatures2d_AffineFeature2D_detectAndCompute_const__InputArrayX_const__InputArrayX_vector_Elliptic_KeyPoint_X_const__OutputArrayX_bool(instance: *mut c_void, image: *mut c_void, mask: *mut c_void, keypoints: *mut c_void, descriptors: *mut c_void, use_provided_keypoints: bool) -> Result_void;
		pub fn cv_xfeatures2d_BoostDesc_create_int_bool_float(desc: i32, use_scale_orientation: bool, scale_factor: f32) -> Result<*mut c_void>;
		pub fn cv_xfeatures2d_BoostDesc_setUseScaleOrientation_bool(instance: *mut c_void, use_scale_orientation: bool) -> Result_void;
		pub fn cv_xfeatures2d_BoostDesc_getUseScaleOrientation_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_xfeatures2d_BoostDesc_setScaleFactor_float(instance: *mut c_void, scale_factor: f32) -> Result_void;
		pub fn cv_xfeatures2d_BoostDesc_getScaleFactor_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_xfeatures2d_BriefDescriptorExtractor_create_int_bool(bytes: i32, use_orientation: bool) -> Result<*mut c_void>;
		pub fn cv_xfeatures2d_DAISY_create_float_int_int_int_NormalizationType_const__InputArrayX_bool_bool(radius: f32, q_radius: i32, q_theta: i32, q_hist: i32, norm: crate::xfeatures2d::DAISY_NormalizationType, h: *mut c_void, interpolation: bool, use_orientation: bool) -> Result<*mut c_void>;
		pub fn cv_xfeatures2d_DAISY_compute_const__InputArrayX_vector_KeyPoint_X_const__OutputArrayX(instance: *mut c_void, image: *mut c_void, keypoints: *mut c_void, descriptors: *mut c_void) -> Result_void;
		pub fn cv_xfeatures2d_DAISY_compute_const__InputArrayX_vector_vector_KeyPoint__X_const__OutputArrayX(instance: *mut c_void, images: *mut c_void, keypoints: *mut c_void, descriptors: *mut c_void) -> Result_void;
		pub fn cv_xfeatures2d_DAISY_compute_const__InputArrayX_Rect_const__OutputArrayX(instance: *mut c_void, image: *mut c_void, roi: *const core::Rect, descriptors: *mut c_void) -> Result_void;
		pub fn cv_xfeatures2d_DAISY_compute_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, image: *mut c_void, descriptors: *mut c_void) -> Result_void;
		pub fn cv_xfeatures2d_DAISY_GetDescriptor_const_double_double_int_floatX(instance: *mut c_void, y: f64, x: f64, orientation: i32, descriptor: *mut f32) -> Result_void;
		pub fn cv_xfeatures2d_DAISY_GetDescriptor_const_double_double_int_floatX_doubleX(instance: *mut c_void, y: f64, x: f64, orientation: i32, descriptor: *mut f32, h: *mut f64) -> Result<bool>;
		pub fn cv_xfeatures2d_DAISY_GetUnnormalizedDescriptor_const_double_double_int_floatX(instance: *mut c_void, y: f64, x: f64, orientation: i32, descriptor: *mut f32) -> Result_void;
		pub fn cv_xfeatures2d_DAISY_GetUnnormalizedDescriptor_const_double_double_int_floatX_doubleX(instance: *mut c_void, y: f64, x: f64, orientation: i32, descriptor: *mut f32, h: *mut f64) -> Result<bool>;
		pub fn cv_xfeatures2d_Elliptic_KeyPoint_axes_const(instance: *mut c_void) -> Result<core::Size_<f32>>;
		pub fn cv_xfeatures2d_Elliptic_KeyPoint_setAxes_Size__float_(instance: *mut c_void, val: *const core::Size_<f32>) -> Result_void;
		pub fn cv_xfeatures2d_Elliptic_KeyPoint_si_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_xfeatures2d_Elliptic_KeyPoint_setSi_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_xfeatures2d_Elliptic_KeyPoint_Elliptic_KeyPoint() -> Result<*mut c_void>;
		pub fn cv_xfeatures2d_Elliptic_KeyPoint_Elliptic_KeyPoint_Point2f_float_Size_float_float(pt: *const core::Point2f, angle: f32, axes: *const core::Size, size: f32, si: f32) -> Result<*mut c_void>;
		pub fn cv_xfeatures2d_FREAK_NB_SCALES_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_xfeatures2d_FREAK_NB_PAIRS_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_xfeatures2d_FREAK_NB_ORIENPAIRS_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_xfeatures2d_FREAK_create_bool_bool_float_int_const_vector_int_X(orientation_normalized: bool, scale_normalized: bool, pattern_scale: f32, n_octaves: i32, selected_pairs: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_xfeatures2d_HarrisLaplaceFeatureDetector_create_int_float_float_int_int(num_octaves: i32, corn_thresh: f32, dog_thresh: f32, max_corners: i32, num_layers: i32) -> Result<*mut c_void>;
		pub fn cv_xfeatures2d_LATCH_create_int_bool_int_double(bytes: i32, rotation_invariance: bool, half_ssd_size: i32, sigma: f64) -> Result<*mut c_void>;
		pub fn cv_xfeatures2d_LUCID_create_int_int(lucid_kernel: i32, blur_kernel: i32) -> Result<*mut c_void>;
		pub fn cv_xfeatures2d_MSDDetector_create_int_int_int_int_float_int_float_int_bool(m_patch_radius: i32, m_search_area_radius: i32, m_nms_radius: i32, m_nms_scale_radius: i32, m_th_saliency: f32, m_k_nn: i32, m_scale_factor: f32, m_n_scales: i32, m_compute_orientation: bool) -> Result<*mut c_void>;
		pub fn cv_xfeatures2d_PCTSignatures_create_int_int_int(init_sample_count: i32, init_seed_count: i32, point_distribution: i32) -> Result<*mut c_void>;
		pub fn cv_xfeatures2d_PCTSignatures_create_const_vector_Point2f_X_int(init_sampling_points: *mut c_void, init_seed_count: i32) -> Result<*mut c_void>;
		pub fn cv_xfeatures2d_PCTSignatures_create_const_vector_Point2f_X_const_vector_int_X(init_sampling_points: *mut c_void, init_cluster_seed_indexes: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_xfeatures2d_PCTSignatures_computeSignature_const_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, image: *mut c_void, signature: *mut c_void) -> Result_void;
		pub fn cv_xfeatures2d_PCTSignatures_computeSignatures_const_const_vector_Mat_X_vector_Mat_X(instance: *mut c_void, images: *mut c_void, signatures: *mut c_void) -> Result_void;
		pub fn cv_xfeatures2d_PCTSignatures_drawSignature_const__InputArrayX_const__InputArrayX_const__OutputArrayX_float_int(source: *mut c_void, signature: *mut c_void, result: *mut c_void, radius_to_shorter_side_ratio: f32, border_thickness: i32) -> Result_void;
		pub fn cv_xfeatures2d_PCTSignatures_generateInitPoints_vector_Point2f_X_int_int(init_points: *mut c_void, count: i32, point_distribution: i32) -> Result_void;
		pub fn cv_xfeatures2d_PCTSignatures_getSampleCount_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_xfeatures2d_PCTSignatures_getGrayscaleBits_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_xfeatures2d_PCTSignatures_setGrayscaleBits_int(instance: *mut c_void, grayscale_bits: i32) -> Result_void;
		pub fn cv_xfeatures2d_PCTSignatures_getWindowRadius_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_xfeatures2d_PCTSignatures_setWindowRadius_int(instance: *mut c_void, radius: i32) -> Result_void;
		pub fn cv_xfeatures2d_PCTSignatures_getWeightX_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_xfeatures2d_PCTSignatures_setWeightX_float(instance: *mut c_void, weight: f32) -> Result_void;
		pub fn cv_xfeatures2d_PCTSignatures_getWeightY_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_xfeatures2d_PCTSignatures_setWeightY_float(instance: *mut c_void, weight: f32) -> Result_void;
		pub fn cv_xfeatures2d_PCTSignatures_getWeightL_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_xfeatures2d_PCTSignatures_setWeightL_float(instance: *mut c_void, weight: f32) -> Result_void;
		pub fn cv_xfeatures2d_PCTSignatures_getWeightA_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_xfeatures2d_PCTSignatures_setWeightA_float(instance: *mut c_void, weight: f32) -> Result_void;
		pub fn cv_xfeatures2d_PCTSignatures_getWeightB_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_xfeatures2d_PCTSignatures_setWeightB_float(instance: *mut c_void, weight: f32) -> Result_void;
		pub fn cv_xfeatures2d_PCTSignatures_getWeightContrast_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_xfeatures2d_PCTSignatures_setWeightContrast_float(instance: *mut c_void, weight: f32) -> Result_void;
		pub fn cv_xfeatures2d_PCTSignatures_getWeightEntropy_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_xfeatures2d_PCTSignatures_setWeightEntropy_float(instance: *mut c_void, weight: f32) -> Result_void;
		pub fn cv_xfeatures2d_PCTSignatures_getSamplingPoints_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_xfeatures2d_PCTSignatures_setWeight_int_float(instance: *mut c_void, idx: i32, value: f32) -> Result_void;
		pub fn cv_xfeatures2d_PCTSignatures_setWeights_const_vector_float_X(instance: *mut c_void, weights: *mut c_void) -> Result_void;
		pub fn cv_xfeatures2d_PCTSignatures_setTranslation_int_float(instance: *mut c_void, idx: i32, value: f32) -> Result_void;
		pub fn cv_xfeatures2d_PCTSignatures_setTranslations_const_vector_float_X(instance: *mut c_void, translations: *mut c_void) -> Result_void;
		pub fn cv_xfeatures2d_PCTSignatures_setSamplingPoints_vector_Point2f_(instance: *mut c_void, sampling_points: *mut c_void) -> Result_void;
		pub fn cv_xfeatures2d_PCTSignatures_getInitSeedIndexes_const(instance: *mut c_void) -> Result<*mut c_void>;
		pub fn cv_xfeatures2d_PCTSignatures_setInitSeedIndexes_vector_int_(instance: *mut c_void, init_seed_indexes: *mut c_void) -> Result_void;
		pub fn cv_xfeatures2d_PCTSignatures_getInitSeedCount_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_xfeatures2d_PCTSignatures_getIterationCount_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_xfeatures2d_PCTSignatures_setIterationCount_int(instance: *mut c_void, iteration_count: i32) -> Result_void;
		pub fn cv_xfeatures2d_PCTSignatures_getMaxClustersCount_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_xfeatures2d_PCTSignatures_setMaxClustersCount_int(instance: *mut c_void, max_clusters_count: i32) -> Result_void;
		pub fn cv_xfeatures2d_PCTSignatures_getClusterMinSize_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_xfeatures2d_PCTSignatures_setClusterMinSize_int(instance: *mut c_void, cluster_min_size: i32) -> Result_void;
		pub fn cv_xfeatures2d_PCTSignatures_getJoiningDistance_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_xfeatures2d_PCTSignatures_setJoiningDistance_float(instance: *mut c_void, joining_distance: f32) -> Result_void;
		pub fn cv_xfeatures2d_PCTSignatures_getDropThreshold_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_xfeatures2d_PCTSignatures_setDropThreshold_float(instance: *mut c_void, drop_threshold: f32) -> Result_void;
		pub fn cv_xfeatures2d_PCTSignatures_getDistanceFunction_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_xfeatures2d_PCTSignatures_setDistanceFunction_int(instance: *mut c_void, distance_function: i32) -> Result_void;
		pub fn cv_xfeatures2d_PCTSignaturesSQFD_create_int_int_float(distance_function: i32, similarity_function: i32, similarity_parameter: f32) -> Result<*mut c_void>;
		pub fn cv_xfeatures2d_PCTSignaturesSQFD_computeQuadraticFormDistance_const_const__InputArrayX_const__InputArrayX(instance: *mut c_void, _signature0: *mut c_void, _signature1: *mut c_void) -> Result<f32>;
		pub fn cv_xfeatures2d_PCTSignaturesSQFD_computeQuadraticFormDistances_const_const_MatX_const_vector_Mat_X_vector_float_X(instance: *mut c_void, source_signature: *mut c_void, image_signatures: *mut c_void, distances: *mut c_void) -> Result_void;
		pub fn cv_xfeatures2d_SIFT_create_int_int_double_double_double(nfeatures: i32, n_octave_layers: i32, contrast_threshold: f64, edge_threshold: f64, sigma: f64) -> Result<*mut c_void>;
		pub fn cv_xfeatures2d_SURF_create_double_int_int_bool_bool(hessian_threshold: f64, n_octaves: i32, n_octave_layers: i32, extended: bool, upright: bool) -> Result<*mut c_void>;
		pub fn cv_xfeatures2d_SURF_setHessianThreshold_double(instance: *mut c_void, hessian_threshold: f64) -> Result_void;
		pub fn cv_xfeatures2d_SURF_getHessianThreshold_const(instance: *mut c_void) -> Result<f64>;
		pub fn cv_xfeatures2d_SURF_setNOctaves_int(instance: *mut c_void, n_octaves: i32) -> Result_void;
		pub fn cv_xfeatures2d_SURF_getNOctaves_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_xfeatures2d_SURF_setNOctaveLayers_int(instance: *mut c_void, n_octave_layers: i32) -> Result_void;
		pub fn cv_xfeatures2d_SURF_getNOctaveLayers_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_xfeatures2d_SURF_setExtended_bool(instance: *mut c_void, extended: bool) -> Result_void;
		pub fn cv_xfeatures2d_SURF_getExtended_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_xfeatures2d_SURF_setUpright_bool(instance: *mut c_void, upright: bool) -> Result_void;
		pub fn cv_xfeatures2d_SURF_getUpright_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_xfeatures2d_StarDetector_create_int_int_int_int_int(max_size: i32, response_threshold: i32, line_threshold_projected: i32, line_threshold_binarized: i32, suppress_nonmax_size: i32) -> Result<*mut c_void>;
		pub fn cv_xfeatures2d_VGG_create_int_float_bool_bool_float_bool(desc: i32, isigma: f32, img_normalize: bool, use_scale_orientation: bool, scale_factor: f32, dsc_normalize: bool) -> Result<*mut c_void>;
		pub fn cv_xfeatures2d_VGG_setSigma_float(instance: *mut c_void, isigma: f32) -> Result_void;
		pub fn cv_xfeatures2d_VGG_getSigma_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_xfeatures2d_VGG_setUseNormalizeImage_bool(instance: *mut c_void, img_normalize: bool) -> Result_void;
		pub fn cv_xfeatures2d_VGG_getUseNormalizeImage_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_xfeatures2d_VGG_setUseScaleOrientation_bool(instance: *mut c_void, use_scale_orientation: bool) -> Result_void;
		pub fn cv_xfeatures2d_VGG_getUseScaleOrientation_const(instance: *mut c_void) -> Result<bool>;
		pub fn cv_xfeatures2d_VGG_setScaleFactor_float(instance: *mut c_void, scale_factor: f32) -> Result_void;
		pub fn cv_xfeatures2d_VGG_getScaleFactor_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_xfeatures2d_VGG_setUseNormalizeDescriptor_bool(instance: *mut c_void, dsc_normalize: bool) -> Result_void;
		pub fn cv_xfeatures2d_VGG_getUseNormalizeDescriptor_const(instance: *mut c_void) -> Result<bool>;
	}
}
#[cfg(feature = "contrib")]
pub use xfeatures2d_sys::*;

#[cfg(feature = "contrib")]
mod xobjdetect_sys {
	use super::*;

	extern "C" {
		pub fn cv_xobjdetect_WBDetector_read_const_FileNodeX(instance: *mut c_void, node: *mut c_void) -> Result_void;
		pub fn cv_xobjdetect_WBDetector_write_const_FileStorageX(instance: *mut c_void, fs: *mut c_void) -> Result_void;
		pub fn cv_xobjdetect_WBDetector_train_const_stringX_const_stringX(instance: *mut c_void, pos_samples: *const c_char, neg_imgs: *const c_char) -> Result_void;
		pub fn cv_xobjdetect_WBDetector_detect_const_MatX_vector_Rect_X_vector_double_X(instance: *mut c_void, img: *mut c_void, bboxes: *mut c_void, confidences: *mut c_void) -> Result_void;
		pub fn cv_xobjdetect_WBDetector_create() -> Result<*mut c_void>;
	}
}
#[cfg(feature = "contrib")]
pub use xobjdetect_sys::*;

#[cfg(feature = "contrib")]
mod xphoto_sys {
	use super::*;

	extern "C" {
		pub fn cv_xphoto_applyChannelGains_const__InputArrayX_const__OutputArrayX_float_float_float(src: *mut c_void, dst: *mut c_void, gain_b: f32, gain_g: f32, gain_r: f32) -> Result_void;
		pub fn cv_xphoto_bm3dDenoising_const__InputArrayX_const__InputOutputArrayX_const__OutputArrayX_float_int_int_int_int_int_int_float_int_int_int(src: *mut c_void, dst_step1: *mut c_void, dst_step2: *mut c_void, h: f32, template_window_size: i32, search_window_size: i32, block_matching_step1: i32, block_matching_step2: i32, group_size: i32, sliding_step: i32, beta: f32, norm_type: i32, step: i32, transform_type: i32) -> Result_void;
		pub fn cv_xphoto_bm3dDenoising_const__InputArrayX_const__OutputArrayX_float_int_int_int_int_int_int_float_int_int_int(src: *mut c_void, dst: *mut c_void, h: f32, template_window_size: i32, search_window_size: i32, block_matching_step1: i32, block_matching_step2: i32, group_size: i32, sliding_step: i32, beta: f32, norm_type: i32, step: i32, transform_type: i32) -> Result_void;
		pub fn cv_xphoto_createGrayworldWB() -> Result<*mut c_void>;
		pub fn cv_xphoto_createLearningBasedWB_const_StringX(path_to_model: *const c_char) -> Result<*mut c_void>;
		pub fn cv_xphoto_createSimpleWB() -> Result<*mut c_void>;
		pub fn cv_xphoto_createTonemapDurand_float_float_float_float_float(gamma: f32, contrast: f32, saturation: f32, sigma_space: f32, sigma_color: f32) -> Result<*mut c_void>;
		pub fn cv_xphoto_dctDenoising_const_MatX_MatX_double_int(src: *mut c_void, dst: *mut c_void, sigma: f64, psize: i32) -> Result_void;
		pub fn cv_xphoto_inpaint_const_MatX_const_MatX_MatX_int(src: *mut c_void, mask: *mut c_void, dst: *mut c_void, algorithm_type: i32) -> Result_void;
		pub fn cv_xphoto_oilPainting_const__InputArrayX_const__OutputArrayX_int_int(src: *mut c_void, dst: *mut c_void, size: i32, dyn_ratio: i32) -> Result_void;
		pub fn cv_xphoto_oilPainting_const__InputArrayX_const__OutputArrayX_int_int_int(src: *mut c_void, dst: *mut c_void, size: i32, dyn_ratio: i32, code: i32) -> Result_void;
		pub fn cv_xphoto_GrayworldWB_getSaturationThreshold_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_xphoto_GrayworldWB_setSaturationThreshold_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_xphoto_LearningBasedWB_extractSimpleFeatures_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, src: *mut c_void, dst: *mut c_void) -> Result_void;
		pub fn cv_xphoto_LearningBasedWB_getRangeMaxVal_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_xphoto_LearningBasedWB_setRangeMaxVal_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_xphoto_LearningBasedWB_getSaturationThreshold_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_xphoto_LearningBasedWB_setSaturationThreshold_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_xphoto_LearningBasedWB_getHistBinNum_const(instance: *mut c_void) -> Result<i32>;
		pub fn cv_xphoto_LearningBasedWB_setHistBinNum_int(instance: *mut c_void, val: i32) -> Result_void;
		pub fn cv_xphoto_SimpleWB_getInputMin_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_xphoto_SimpleWB_setInputMin_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_xphoto_SimpleWB_getInputMax_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_xphoto_SimpleWB_setInputMax_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_xphoto_SimpleWB_getOutputMin_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_xphoto_SimpleWB_setOutputMin_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_xphoto_SimpleWB_getOutputMax_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_xphoto_SimpleWB_setOutputMax_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_xphoto_SimpleWB_getP_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_xphoto_SimpleWB_setP_float(instance: *mut c_void, val: f32) -> Result_void;
		pub fn cv_xphoto_TonemapDurand_getSaturation_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_xphoto_TonemapDurand_setSaturation_float(instance: *mut c_void, saturation: f32) -> Result_void;
		pub fn cv_xphoto_TonemapDurand_getContrast_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_xphoto_TonemapDurand_setContrast_float(instance: *mut c_void, contrast: f32) -> Result_void;
		pub fn cv_xphoto_TonemapDurand_getSigmaSpace_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_xphoto_TonemapDurand_setSigmaSpace_float(instance: *mut c_void, sigma_space: f32) -> Result_void;
		pub fn cv_xphoto_TonemapDurand_getSigmaColor_const(instance: *mut c_void) -> Result<f32>;
		pub fn cv_xphoto_TonemapDurand_setSigmaColor_float(instance: *mut c_void, sigma_color: f32) -> Result_void;
		pub fn cv_xphoto_WhiteBalancer_balanceWhite_const__InputArrayX_const__OutputArrayX(instance: *mut c_void, src: *mut c_void, dst: *mut c_void) -> Result_void;
	}
}
#[cfg(feature = "contrib")]
pub use xphoto_sys::*;

pub use crate::manual::sys::*;
